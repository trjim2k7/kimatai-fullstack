http://127.0.0.1:5500/Kimatai%20v9.7.html<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Plan personalized, AI-crafted travel itineraries with KimatAI. Stop planning, start exploring.">
    <meta name="theme-color" content="#0D5C63">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="X-XSS-Protection" content="1; mode=block">
    <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://www.gstatic.com https://cdn.jsdelivr.net https://cdnjs.cloudflare.com https://unpkg.com 'unsafe-eval'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://unpkg.com; font-src 'self' https://fonts.gstatic.com; img-src 'self' data: https: blob:; connect-src 'self' http://localhost:3001 http://127.0.0.1:3001 https://identitytoolkit.googleapis.com https://firestore.googleapis.com https://securetoken.googleapis.com https://kimatai-backend.onrender.com https://generativelanguage.googleapis.com https://cdn.jsdelivr.net https://cdnjs.cloudflare.com https://unpkg.com https://www.gstatic.com https://nominatim.openstreetmap.org https://tile.openstreetmap.org https://mt0.google.com https://mt1.google.com https://mt2.google.com https://mt3.google.com; frame-src 'none'; object-src 'none';"
    <link rel="canonical" href="/">
    <!-- Preconnects for performance -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://images.unsplash.com" crossorigin>
    <link rel="preconnect" href="https://images.pexels.com" crossorigin>
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
    <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
    <title>KimatAI - Intelligent Itineraries</title>
    <!-- <script src="https://cdn.tailwindcss.com"></script> -->
    <link href="output.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <!-- Lucide Icons -->
    <script defer src="https://unpkg.com/lucide@latest/dist/umd/lucide.js" crossorigin="anonymous" onerror="loadFallbackLibraries('lucide')"></script>
    <!-- Libraries for PDF Generation -->
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js" crossorigin="anonymous"></script>
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" crossorigin="anonymous" onerror="loadFallbackLibraries('jspdf')"></script>
    <!-- Markdown Parser -->
    <script defer src="https://cdn.jsdelivr.net/npm/marked/marked.min.js" crossorigin="anonymous"></script>
    <!-- Drag & Drop Library -->
    <script defer src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js" crossorigin="anonymous" onerror="loadFallbackLibraries('sortable')"></script>
    <!-- DOMPurify for sanitization -->
    <script defer src="https://cdn.jsdelivr.net/npm/dompurify@3.1.6/dist/purify.min.js" crossorigin="anonymous"></script>
    
    <!-- Leaflet Maps -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="anonymous"/>
    <script defer src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin="anonymous"></script>
    
    <script>
        // Fallback library loader for failed CDN loads
        function loadFallbackLibraries(libName) {
            console.warn('Primary CDN failed for', libName, '- attempting fallback');
            const fallbacks = {
                'lucide': 'https://cdn.jsdelivr.net/npm/lucide@0.400.0/dist/umd/lucide.min.js',
                'jspdf': 'https://unpkg.com/jspdf@2.5.1/dist/jspdf.umd.min.js',
                'sortable': 'https://unpkg.com/sortablejs@1.15.0/Sortable.min.js'
            };
            
            if (fallbacks[libName]) {
                const script = document.createElement('script');
                script.src = fallbacks[libName];
                script.crossOrigin = 'anonymous';
                script.onerror = () => console.error('Fallback also failed for', libName);
                document.head.appendChild(script);
            }
        }
    </script>
    <style>
        :root {
            --color-primary: #0D5C63;
            --color-primary-dark: #0A4C53;
            --color-text: #0A2E36;
            --color-bg: #FDFBF7;
            --color-muted: #E0E7E9;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--color-bg); /* Off-white background */
            color: var(--color-text); /* Dark Teal Text */
        }
        .chat-bubble-user { background-color: var(--color-primary); color: white; }
        .chat-bubble-ai { background-color: var(--color-muted); color: var(--color-text); }
        .typing-indicator span {
            height: 8px; width: 8px; background-color: #9CA3AF; border-radius: 50%; display: inline-block;
            animation: bounce 1.4s infinite ease-in-out both;
        }
        .typing-indicator span:nth-child(1) { animation-delay: -0.32s; }
        .typing-indicator span:nth-child(2) { animation-delay: -0.16s; }
        @keyframes bounce { 0%,80%,100%{transform:scale(0)} 40%{transform:scale(1)} }
        .modal-backdrop {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.5); z-index: 100; justify-content: center; align-items: flex-start;
            overflow-y: auto; padding: 40px 20px;
        }
    .primary-btn { background-color: var(--color-primary); color: white; }
    .primary-btn:hover { background-color: var(--color-primary-dark); }
    .primary-text { color: var(--color-primary); }
    .primary-border { border-color: var(--color-primary); }
    .secondary-bg { background-color: var(--color-bg); }

        /* Improved Prose styling for AI output */
        .prose a { color: #0D5C63; text-decoration: underline; }
        .prose strong { font-weight: 800; display: inline; margin-top: 0; margin-bottom: 0; }
        .prose p { margin-bottom: 1em; }
        .prose ul, .prose ol { margin-bottom: 1em; }

        [contenteditable]:focus { outline: 2px solid #0D5C63; background-color: #f0fafa; border-radius: 4px; }
        .sortable-ghost { opacity: 0.4; background: #cce7e8; }

    .tab-btn.active { background-color: var(--color-primary); color: white; border-color: var(--color-primary); }

        /* Make .active match your data-selected style for interest chips */
        .interest-btn[data-selected="true"],
        .interest-btn.active {
            background-color: var(--color-primary);
            color: white;
            border-color: var(--color-primary);
        }
        /* Enhanced Itinerary Styling */
        .itinerary { 
            line-height: 1.7; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            max-width: 100%;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        /* Day Blocks */
        .day-block {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            page-break-inside: avoid;
        }
        .day-block:hover {
            box-shadow: 0 8px 25px rgba(0,0,0,0.08);
            transform: translateY(-2px);
        }
        
        /* Day Header */
        .day-header {
            position: relative;
        }
        .day-header::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, #3b82f6, transparent);
        }
        
        /* Activity Items */
        .activity-item {
            position: relative;
            padding-bottom: 1.5rem;
            margin-bottom: 0.5rem;
        }
        .activity-item:not(:last-child)::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 4.5rem;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, #f1f5f9, transparent);
        }
        .activity-item:hover .activity-content {
            background-color: rgba(59, 130, 246, 0.02);
            border-radius: 0.5rem;
            padding: 0.75rem;
            margin: -0.75rem;
            transition: all 0.2s ease;
        }
        
        /* Seamlessly Integrated Venue Links */
        .venue-link {
            display: inline;
            text-decoration: underline;
            text-decoration-style: dotted;
            text-underline-offset: 2px;
            transition: all 0.2s ease;
            cursor: pointer;
        }
        .venue-link:hover {
            text-decoration-style: solid;
            text-shadow: 0 1px 2px rgba(59, 130, 246, 0.2);
        }
        
        /* Venue Fallback Styling */
        .venue-fallback {
            display: inline;
            transition: all 0.2s ease;
        }
        
        /* Enhanced Daily Tips */
        .daily-tip {
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(10px);
        }
        .daily-tip::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.05) 0%, rgba(251, 191, 36, 0.05) 100%);
            pointer-events: none;
        }
        .tip-content {
            position: relative;
            z-index: 1;
        }
        .tip-content h6 {
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-size: 0.75rem;
        }
        .tip-content div {
            text-align: justify;
            hyphens: auto;
            line-height: 1.6;
        }
        
        /* Enhanced Booking Suggestions */
        .booking-suggestions {
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border: 1px solid #e2e8f0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }
        .booking-suggestions h3 {
            color: #1f2937;
            font-size: 1.25rem;
            margin-bottom: 1rem;
            font-weight: 700;
        }
        .booking-suggestions h4 { 
            color: var(--color-primary); 
            font-size: 1.1rem;
            margin-bottom: 0.75rem;
            font-weight: 600;
        }
        .booking-suggestions a {
            color: #3b82f6;
            font-weight: 500;
            transition: all 0.2s ease;
            text-decoration: underline;
            text-decoration-style: dotted;
            text-underline-offset: 2px;
        }
        .booking-suggestions a:hover {
            color: #1d4ed8;
            text-decoration-style: solid;
        }
        .booking-suggestions div {
            text-align: justify;
            hyphens: auto;
        }
        
        /* Activity Description Enhancements */
        .activity-description {
            word-break: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
            text-align: justify;
            text-justify: inter-word;
        }
        .activity-description p {
            margin: 0;
            text-indent: 0;
            line-height: 1.75;
        }
        
        /* Time Badge Enhancements */
        .badge-time {
            font-variant-numeric: tabular-nums;
            letter-spacing: 0.025em;
            color: white !important;
            background-color: #2563eb !important;
            font-weight: 600;
            text-align: center;
            min-width: 4.5rem;
            box-shadow: 0 2px 4px rgba(37, 99, 235, 0.2);
        }
        
        /* Time Badge Container */
        .time-badge-container {
            padding-top: 0.125rem;
        }
        
        /* Activity Content */
        .activity-content {
            transition: all 0.2s ease;
        }
        
        /* Professional Typography */
        .activity-description strong,
        .activity-description .venue-link {
            font-weight: 600;
        }
        
        /* Paragraph Spacing */
        .activity-description p + p {
            margin-top: 0.75rem;
        }
        
        /* Better Text Rendering */
        .itinerary * {
            text-rendering: optimizeLegibility;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        /* Loading State */
        .itinerary-loading {
            opacity: 0.6;
            pointer-events: none;
            filter: blur(1px);
            transition: all 0.3s ease;
        }
        
        /* Responsive Improvements */
        @media (max-width: 768px) {
            .itinerary {
                font-size: 0.95rem;
                line-height: 1.65;
            }
            .day-block {
                margin-bottom: 1.5rem;
                border-radius: 1rem;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.07);
            }
            .day-header {
                padding: 1rem 1.25rem;
            }
            .day-content {
                padding: 1.25rem;
            }
            .activity-item {
                padding-bottom: 1.25rem;
            }
            .activity-item .flex {
                flex-direction: column;
                gap: 0.75rem;
                align-items: stretch;
            }
            .time-badge-container {
                padding-top: 0;
            }
            .badge-time {
                align-self: flex-start;
                margin-bottom: 0.5rem;
                font-size: 0.875rem;
                padding: 0.5rem 1rem;
            }
            .activity-description {
                text-align: left;
                font-size: 0.95rem;
                line-height: 1.7;
            }
            .venue-link {
                display: inline;
                margin: 0;
                font-size: 0.95rem;
            }
            .daily-tip {
                margin-top: 1.25rem;
                padding: 1rem;
            }
            .tip-content h6 {
                font-size: 0.7rem;
            }
            .tip-content div {
                font-size: 0.875rem;
                line-height: 1.65;
            }
        }
        
        @media (max-width: 480px) {
            .day-header {
                padding: 0.875rem 1rem;
            }
            .day-content {
                padding: 1rem;
            }
            .activity-description {
                font-size: 0.9rem;
            }
            .badge-time {
                font-size: 0.8rem;
                padding: 0.375rem 0.875rem;
            }
        }

        /* --- Editable Itinerary Professional Styling --- */
        .day-group { position: relative; }
        .day-group.edit-collapsed .activity-list { display:none; }
        .day-group-toolbar { background: linear-gradient(90deg,#0D5C63 0%,#0A4C53 100%); color:#fff; border-radius:6px; padding:.5rem .75rem; display:flex; align-items:center; gap:.5rem; box-shadow:0 2px 4px rgba(0,0,0,.08); }
        .day-group-toolbar input.day-title-input { background: rgba(255,255,255,0.15); color:#fff; border:1px solid rgba(255,255,255,0.3); }
        .day-group-toolbar input.day-title-input::placeholder { color:rgba(255,255,255,0.6); }
        .day-group-toolbar button, .day-group-toolbar .icon-btn { display:inline-flex; align-items:center; justify-content:center; }
        .activity-item { transition:background .15s, box-shadow .15s; }
        .activity-item:focus-within { box-shadow:0 0 0 2px #0D5C6333; }
        .activity-item.dragging { opacity:.6; }
        .activity-item .activity-desc-input { line-height:1.3; }
        .activity-item .activity-time-input { font-weight:500; }
        .drag-helper-hint { font-size:.65rem; letter-spacing:.05em; text-transform:uppercase; color:#64748b; }
        .collapse-indicator { transition: transform .2s; }
        .day-group.edit-collapsed .collapse-indicator { transform: rotate(-90deg); }
        .day-group-footer { margin-top:.5rem; display:flex; justify-content:space-between; align-items:center; }
        .activity-item:hover { background:#ffffff; }
        .activity-list { padding-left:0; }
        .activity-item textarea { min-height:38px; }
        .inline-badge { background:#0D5C63; color:#fff; font-size:.55rem; font-weight:600; padding:2px 6px; border-radius:999px; letter-spacing:.05em; }
        .pro-edit-hint { font-size:.7rem; color:#475569; margin-left:.25rem; }
        /* Toggle switch styling */
        .toggle-switch-wrapper { display: flex; align-items: center; gap: 0.5rem; }
        .toggle-switch { position: relative; display: inline-block; width: 40px; height: 20px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .toggle-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .3s; border-radius: 20px; }
        .toggle-slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 2px; bottom: 2px; background-color: white; transition: .3s; border-radius: 50%; }
        .toggle-switch input:checked + .toggle-slider { background-color: #0D5C63; }
        .toggle-switch input:checked + .toggle-slider:before { transform: translateX(20px); }
        
        /* Progressive Map Animations */
        @keyframes markerPop {
            0% { transform: scale(0) rotate(0deg); opacity: 0; }
            50% { transform: scale(1.3) rotate(180deg); opacity: 0.8; }
            100% { transform: scale(1) rotate(360deg); opacity: 1; }
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(59, 130, 246, 0); }
            100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0); }
        }
        
        .progressive-status {
            animation: pulse 2s infinite;
        }
        
        .map-container {
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            overflow: hidden;
            margin: 0;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            background: white;
            height: 100%;
            min-height: 600px;
            z-index: 100;
            width: 100%;
            position: relative;
        }
        
        #map-section-wrapper {
            display: flex;
            flex-direction: column;
            margin-bottom: 0;
            padding-bottom: 0;
            height: fit-content !important;
            max-height: none !important;
        }
        
        @media (max-width: 1023px) {
            .map-container {
                margin: 1rem 0;
                min-height: 450px;
            }
        }
        
        .map-header {
            background: #f8fafc;
            padding: 12px 16px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .map-toggle-btn {
            padding: 6px 12px;
            border-radius: 6px;
            border: none;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 14px;
        }
        
        #progressive-map {
            width: 100% !important;
            height: 450px !important;
            position: relative !important;
            border-radius: 16px !important;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12) !important;
            border: 2px solid #e5e7eb !important;
            transition: all 0.3s ease !important;
            overflow: hidden !important;
            z-index: 1 !important;
            pointer-events: auto !important;
        }
        
        #progressive-map:hover {
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15) !important;
            transform: translateY(-2px) !important;
        }
        
        /* Progressive Map Container Styles */
        .progressive-map-container {
            margin: 20px 0 0 0;
            border-radius: 16px;
            position: relative;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 4px;
        }
        
        .progressive-status {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 10px 16px;
            border-radius: 25px;
            font-size: 13px;
            box-shadow: 0 4px 16px rgba(102, 126, 234, 0.3);
            z-index: 1000;
            font-weight: 600;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
        }
        
        .progressive-status.finished {
            animation: none;
            background: linear-gradient(135deg, #10b981, #059669);
        }
        
        .map-title {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(255, 255, 255, 0.95);
            color: #374151;
            padding: 10px 16px;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 700;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            backdrop-filter: blur(10px);
        }
        
        /* Smooth marker animations */
        @keyframes markerPop {
            0% { 
                transform: scale(0); 
                opacity: 0; 
            }
            60% { 
                transform: scale(1.1); 
                opacity: 0.9; 
            }
            100% { 
                transform: scale(1); 
                opacity: 1; 
            }
        }
        
        /* Removed custom marker styling - using Leaflet defaults */
        
        /* Smooth route line animation */
        @keyframes routeFadeIn {
            from { 
                opacity: 0;
                stroke-width: 1;
            }
            to { 
                opacity: 0.7;
                stroke-width: 3;
            }
        }
        
        .route-line {
            stroke: #667eea !important;
            stroke-width: 3 !important;
            opacity: 0.7 !important;
            stroke-linecap: round !important;
            stroke-linejoin: round !important;
            animation: routeFadeIn 0.8s ease-out !important;
            filter: drop-shadow(0 2px 4px rgba(102, 126, 234, 0.2)) !important;
            transition: all 0.3s ease !important;
        }
        
        /* Custom popup styling */
        .leaflet-popup-content-wrapper {
            background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%) !important;
            border-radius: 12px !important;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15) !important;
            border: 1px solid #e5e7eb !important;
        }
        
        .leaflet-popup-content {
            margin: 16px !important;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif !important;
        }
        
        .leaflet-popup-tip {
            background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%) !important;
            border: 1px solid #e5e7eb !important;
        }
        
        /* Loading animation for map */
        @keyframes mapLoad {
            0% { 
                opacity: 0; 
                transform: scale(0.95); 
            }
            100% { 
                opacity: 1; 
                transform: scale(1); 
            }
        }
        
        .progressive-map-container.loading {
            animation: mapLoad 0.6s ease-out;
        }
        
        /* Zoom controls styling */
        .leaflet-control-zoom a {
            background: linear-gradient(135deg, #667eea, #764ba2) !important;
            color: white !important;
            border: none !important;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3) !important;
            transition: all 0.3s ease !important;
        }
        
        .leaflet-control-zoom a:hover {
            background: linear-gradient(135deg, #764ba2, #667eea) !important;
            transform: scale(1.05) !important;
        }
        
        /* Enhanced Standard Marker Styles */
        .leaflet-marker-icon.leaflet-div-icon {
            background: transparent !important;
            border: none !important;
        }
        
        /* Default Leaflet markers - no custom styling */
        
        @keyframes pulse {
            0% {
                transform: scale(0.8);
                opacity: 1;
            }
            100% {
                transform: scale(2);
                opacity: 0;
            }
        }
        
        /* Enhanced Popup Styles */
        .enhanced-popup {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        .popup-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #e5e7eb;
        }
        
        .popup-header h3 {
            margin: 0;
            font-size: 16px;
            font-weight: 700;
            color: #1f2937;
            line-height: 1.3;
            flex: 1;
        }
        
        .popup-badge {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 8px;
            white-space: nowrap;
        }
        
        .popup-content {
            color: #6b7280;
        }
        
        .popup-description {
            margin: 0 0 12px 0;
            font-size: 14px;
            line-height: 1.4;
        }
        
        .popup-actions {
            display: flex;
            gap: 8px;
        }
        
        .popup-link {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 8px 12px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            text-decoration: none;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.2s ease;
        }
        
        .popup-link:hover {
            background: linear-gradient(135deg, #764ba2, #667eea);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }
        
        .custom-popup .leaflet-popup-content-wrapper {
            padding: 0 !important;
        }
        
        .custom-popup .leaflet-popup-content {
            margin: 0 !important;
            padding: 16px !important;
        }
        
        /* Layer Control Styling */
        .leaflet-control-layers {
            background: rgba(255, 255, 255, 0.95) !important;
            backdrop-filter: blur(10px) !important;
            border-radius: 12px !important;
            border: 1px solid rgba(102, 126, 234, 0.2) !important;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1) !important;
            padding: 8px !important;
        }
        
        .leaflet-control-layers-toggle {
            background: linear-gradient(135deg, #667eea, #764ba2) !important;
            color: white !important;
            border-radius: 8px !important;
            width: 32px !important;
            height: 32px !important;
        }
        
        .leaflet-control-layers-list {
            padding: 8px !important;
        }
        
        .leaflet-control-layers label {
            font-weight: 500 !important;
            color: #374151 !important;
            margin-bottom: 4px !important;
            font-size: 13px !important;
        }
        
        .leaflet-control-layers input[type="radio"] {
            accent-color: #667eea !important;
        }
        
        /* Enhanced Edit Mode Styles */
        .edit-mode .activity-item {
            transition: all 0.2s ease;
        }
        
        .activity-item:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        .activity-item.dragging {
            transform: rotate(3deg) scale(1.05);
            z-index: 1000;
            box-shadow: 0 12px 40px rgba(16, 185, 129, 0.4);
            border: 2px solid #10b981;
            background: linear-gradient(135deg, #f0fdfa, #ccfbf1) !important;
            transition: all 0.2s ease;
        }
        
        .activity-item.drag-over {
            transform: translateY(-2px);
            border-color: #3b82f6 !important;
            background-color: #eff6ff !important;
            box-shadow: 0 4px 16px rgba(59, 130, 246, 0.2);
        }

        .activity-item.drag-hover {
            transform: translateY(-1px);
            border-color: #10b981 !important;
            background: linear-gradient(135deg, #f0fdfa, #ccfbf1) !important;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }
        
        .reorder-buttons {
            display: flex;
            flex-direction: column;
            gap: 2px;
            margin-left: 8px;
            align-items: center;
        }
        
        .reorder-btn {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 24px;
            height: 24px;
        }
        
        .reorder-btn:hover {
            background: #2563eb;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.3);
        }
        
        .reorder-btn:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .activity-reorder-buttons {
            display: flex;
            flex-direction: column;
            gap: 1px;
            margin-left: 6px;
            align-items: center;
        }
        
        .activity-reorder-btn {
            background: #10b981;
            color: white;
            border: none;
            padding: 2px 6px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 20px;
            height: 20px;
        }
        
        .activity-reorder-btn:hover {
            background: #059669;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(16, 185, 129, 0.3);
        }
        
        .activity-reorder-btn:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        @keyframes activity-drop-pulse {
            0%, 100% { 
                box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
                filter: brightness(1);
            }
            50% { 
                box-shadow: 0 6px 20px rgba(16, 185, 129, 0.8);
                filter: brightness(1.3);
            }
        }
        
        @keyframes pulse-glow {
            0%, 100% { 
                box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
            }
            50% { 
                box-shadow: 0 4px 16px rgba(59, 130, 246, 0.6);
            }
        }

        /* Day reordering with buttons */
        .day-reorder-buttons {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin: 8px 0;
            align-items: center;
        }
        
        .day-reorder-btn {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 32px;
            height: 32px;
        }
        
        .day-reorder-btn:hover {
            background: #2563eb;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3);
        }
        
        .day-reorder-btn:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        @keyframes day-drop-pulse {
            0%, 100% { 
                box-shadow: 0 6px 16px rgba(59, 130, 246, 0.4);
                filter: brightness(1);
            }
            50% { 
                box-shadow: 0 8px 24px rgba(59, 130, 246, 0.8);
                filter: brightness(1.3);
            }
        }

        /* Auto-scroll indicator */
        .scroll-indicator {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .scroll-indicator.show {
            opacity: 1;
        }
        
        /* Professional button styling */
        button[id$="-btn"] {
            transition: all 0.2s ease;
        }
        
        button[id$="-btn"]:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        button[id$="-btn"]:active {
            transform: translateY(0);
        }
        
        /* Edit instructions animation */
        #edit-instructions {
            animation: slideDown 0.3s ease-out;
        }
        
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Sortable placeholder styling */
        .sortable-placeholder {
            background: #e3f2fd;
            border: 2px dashed #2196f3;
            border-radius: 8px;
            height: 60px;
            margin: 8px 0;
        }
        
        /* Map styling */
        .itinerary-map {
            height: 400px;
            width: 100%;
            border-radius: 12px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            margin: 16px 0;
        }
        
        .map-container {
            position: relative;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            padding: 16px;
            margin: 16px 0;
        }
        
        .map-header {
            display: flex;
            align-items: center;
            justify-content: between;
            margin-bottom: 12px;
        }
        
        .map-toggle-btn {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .map-toggle-btn:hover {
            background: #2563eb;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
        }
        
        .map-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 200px;
            color: #64748b;
            font-size: 14px;
        }
        
        /* Custom map marker styles */
        .custom-marker {
            background: #3b82f6;
            color: white;
            border: 3px solid white;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .leaflet-routing-line {
            color: #3b82f6 !important;
            opacity: 0.8 !important;
        }

        /* Follow-up Chat Styling */
        .inline-chat-chip {
            transition: all 0.2s ease;
            cursor: pointer;
            font-size: 0.75rem;
            white-space: nowrap;
            display: inline-flex;
            align-items: center;
        }
        
        .inline-chat-chip:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }
        
        .inline-chat-chip:active {
            transform: translateY(0);
        }
        
        /* Action buttons - force visibility */
        #action-buttons {
            position: relative !important;
            z-index: 10 !important;
            background-color: white !important;
            border-top: 1px solid #e5e7eb !important;
            display: flex !important;
        }
        
        #action-buttons button {
            opacity: 1 !important;
            visibility: visible !important;
            display: inline-flex !important;
            min-width: 120px !important;
            min-height: 40px !important;
        }
        
        /* Mobile responsive action buttons */
        @media (max-width: 768px) {
            #action-buttons {
                flex-direction: column !important;
                gap: 0.5rem !important;
                padding: 0.75rem !important;
            }
            
            #action-buttons button {
                width: 100% !important;
                min-width: unset !important;
                min-height: 44px !important;
                justify-content: center !important;
                font-size: 0.875rem !important;
                padding: 0.625rem 0.75rem !important;
            }
            
            #action-buttons button i {
                width: 1rem !important;
                height: 1rem !important;
            }
            
            #action-buttons button span {
                font-size: 0.875rem !important;
            }
        }
        
        #share-button {
            background-color: #2563eb !important;
            color: white !important;
        }
        
        #save-button {
            background-color: #0D5C63 !important;
            color: white !important;
        }
        
        #download-button {
            background-color: #e5e7eb !important;
            color: #1f2937 !important;
        }
        
        #show-map-button {
            background-color: #16a34a !important;
            color: white !important;
        }
        
        #persistent-chat-bar {
            position: relative !important;
            z-index: 10 !important;
            display: block !important;
        }

    </style>
</head>
<body class="bg-gray-50 text-gray-800">
    <a href="#main-content" class="sr-only focus:not-sr-only focus:absolute focus:top-2 focus:left-2 bg-white text-[#0D5C63] px-3 py-2 rounded">Skip to content</a>

    <!-- Header & Navigation -->
    <header class="bg-white/80 backdrop-blur-lg fixed top-0 left-0 right-0 z-50 shadow-sm">
        <div class="container mx-auto px-6 py-4">
            <div class="flex items-center justify-between">
                <div class="flex items-center space-x-3">
                    <svg width="32" height="32" viewBox="0 0 100 80" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M100 79.5C100 79.5 77.9252 56.5 50.5 35.5C23.0748 14.5 11.4252 -3 0 0.5V79.5H100Z" fill="#0D5C63"/>
                    </svg>
                    <h1 class="text-2xl font-bold text-gray-800">KimatAI</h1>
                </div>
                <nav class="hidden md:flex items-center space-x-8 main-nav">
                    <a href="#features" class="text-gray-600 hover:text-[#0D5C63] transition">Features</a>
                    <a href="#itineraries" class="text-gray-600 hover:text-[#0D5C63] transition">Samples</a>
                    <a href="#pricing" class="text-gray-600 hover:text-[#0D5C63] transition">Pricing</a>
                    <button id="about-link" class="text-gray-600 hover:text-[#0D5C63] transition">About</button>
                    <a href="#planner" class="text-gray-600 hover:text-[#0D5C63] transition">Planner</a>
                </nav>
                <div id="auth-container" class="hidden md:flex items-center space-x-4"></div>
                <button id="mobile-menu-button" class="md:hidden" aria-controls="mobile-menu" aria-expanded="false" aria-label="Open menu">
                    <i data-lucide="menu"></i>
                </button>
            </div>
        </div>
        <!-- Mobile Menu -->
        <div id="mobile-menu" class="hidden md:hidden px-6 pb-4 main-nav">
            <a href="#features" class="block py-2 text-gray-600 hover:text-[#0D5C63]">Features</a>
            <a href="#itineraries" class="block py-2 text-gray-600 hover:text-[#0D5C63]">Samples</a>
            <a href="#pricing" class="block py-2 text-gray-600 hover:text-[#0D5C63]">Pricing</a>
            <button id="about-link-mobile" class="block py-2 text-gray-600 hover:text-[#0D5C63] text-left w-full">About</button>
            <a href="#planner" class="block py-2 text-gray-600 hover:text-[#0D5C63]">Planner</a>
            <div id="mobile-auth-container" class="mt-4 border-t pt-4"></div>
        </div>
    </header>

    <!-- Main Content -->
    <main id="main-content" class="pt-20">
        <section id="hero-section" class="relative text-white overflow-hidden">
            <div class="absolute inset-0 z-[-10]">
                <img src="https://images.unsplash.com/photo-1476514525535-07fb3b4ae5f1?q=80&w=2670&auto=format&fit=crop" class="w-full h-full object-cover" alt="Scenic Lake and Mountains">
                <div class="absolute inset-0 bg-[#0A2E36] opacity-60"></div>
            </div>
            <div class="container mx-auto px-6 py-32 text-center relative z-10">
                <h2 class="text-4xl md:text-6xl font-extrabold leading-tight mb-4">Intelligent Itineraries, Crafted for You</h2>
                <p class="text-lg md:text-xl text-gray-200 max-w-3xl mx-auto mb-8">Stop planning, start exploring. Our intelligent AI crafts personalized itineraries based on your interests, budget, and travel style. Your next adventure is just a conversation away.</p>
                <a href="#planner" class="bg-white text-[#0D5C63] font-bold px-8 py-4 rounded-lg text-lg hover:bg-gray-100 transition shadow-lg">Start Planning for Free</a>
            </div>
        </section>

        <!-- My Trips Section (Initially Hidden) -->
        <section id="my-trips-section" class="hidden py-20">
            <div class="container mx-auto px-6">
                <div class="flex justify-between items-center mb-12">
                    <h3 class="text-3xl md:text-4xl font-bold">My Saved Trips</h3>
                    <button id="back-to-planner-btn" class="primary-btn font-semibold px-5 py-2 rounded-lg hover:bg-[#0A4C53] transition shadow">Plan a New Trip</button>
                </div>
                <div id="saved-itineraries-container" class="grid md:grid-cols-2 lg:grid-cols-3 gap-8"></div>
            </div>
        </section>

        <section id="features" class="py-20 secondary-bg">
            <div class="container mx-auto px-6">
                <div class="text-center mb-12">
                    <h3 class="text-3xl md:text-4xl font-bold">How It Works</h3>
                    <p class="text-gray-600 mt-2">Planning your perfect trip is as easy as 1-2-3.</p>
                </div>
                <div class="grid md:grid-cols-3 gap-12 text-center">
                    <div class="feature-item">
                        <div class="bg-[#E0E7E9] text-[#0D5C63] rounded-full p-5 inline-block mb-4"><i data-lucide="message-square-plus" class="w-8 h-8"></i></div>
                        <h4 class="text-xl font-semibold mb-2">1. Tell Us Your Dream</h4>
                        <p class="text-gray-600">Simply chat with our AI. Mention your destination, interests, budget, and travel duration.</p>
                    </div>
                    <div class="feature-item">
                        <div class="bg-[#E0E7E9] text-[#0D5C63] rounded-full p-5 inline-block mb-4"><i data-lucide="bot" class="w-8 h-8"></i></div>
                        <h4 class="text-xl font-semibold mb-2">2. AI Works Its Magic</h4>
                        <p class="text-gray-600">Our AI analyzes millions of data points to build a unique, day-by-day itinerary just for you.</p>
                    </div>
                    <div class="feature-item">
                        <div class="bg-[#E0E7E9] text-[#0D5C63] rounded-full p-5 inline-block mb-4"><i data-lucide="map" class="w-8 h-8"></i></div>
                        <h4 class="text-xl font-semibold mb-2">3. Explore with Confidence</h4>
                        <p class="text-gray-600">Receive a detailed plan with maps and suggestions. Tweak it with the AI until it's perfect.</p>
                    </div>
                </div>
            </div>
        </section>

        <section id="itineraries" class="py-20">
            <div class="container mx-auto px-6">
                <div class="text-center mb-12">
                    <h3 class="text-3xl md:text-4xl font-bold">Sample Itineraries</h3>
                    <p class="text-gray-600 mt-2">See what our AI can create for you.</p>
                </div>
                <div class="grid md:grid-cols-2 lg:grid-cols-3 gap-8">
                    <div class="sample-itinerary-card bg-white rounded-lg shadow-lg overflow-hidden transform hover:-translate-y-2 transition-transform duration-300 cursor-pointer" data-prompt="Generate a 4-Day Romantic Paris Getaway itinerary, including visits to the Louvre, romantic walks along the Seine, a day trip to Versailles, and dining at charming local bistros.">
                        <img src="https://images.unsplash.com/photo-1522093007474-d86e9bf7ba6f?q=80&w=2574&auto=format&fit=crop" class="w-full h-48 object-cover" alt="Romantic Paris" loading="lazy" decoding="async">
                        <div class="p-6"><h4 class="text-xl font-bold mb-2">4-Day Romantic Paris Getaway</h4><p class="text-gray-600">Experience the magic of Paris with visits to the Louvre, romantic walks, and charming bistros.</p></div>
                    </div>
                    <div class="sample-itinerary-card bg-white rounded-lg shadow-lg overflow-hidden transform hover:-translate-y-2 transition-transform duration-300 cursor-pointer" data-prompt="Create a 7-Day Costa Rica Adventure itinerary for thrill-seekers. Include zip-lining through cloud forests, hiking near the Arenal Volcano, surfing on Pacific beaches, and spotting exotic wildlife.">
                        <img src="https://images.pexels.com/photos/3723336/pexels-photo-3723336.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=2" class="w-full h-48 object-cover" alt="Costa Rica Adventure" loading="lazy" decoding="async">
                        <div class="p-6"><h4 class="text-xl font-bold mb-2">7-Day Costa Rica Adventure</h4><p class="text-gray-600">For thrill-seekers! Zip-lining, volcano hiking, surfing, and wildlife spotting.</p></div>
                    </div>
                    <div class="sample-itinerary-card bg-white rounded-lg shadow-lg overflow-hidden transform hover:-translate-y-2 transition-transform duration-300 cursor-pointer" data-prompt="Plan a 5-Day Tokyo Cultural Dive. The itinerary should cover ancient temples in Asakusa, the Shibuya Crossing, world-class sushi experiences, and a visit to the Tokyo Skytree for city views.">
                        <img src="https://images.unsplash.com/photo-1542051841857-5f90071e7989?q=80&w=2670&auto=format&fit=crop" class="w-full h-48 object-cover" alt="Tokyo Culture" loading="lazy" decoding="async">
                        <div class="p-6"><h4 class="text-xl font-bold mb-2">5-Day Tokyo Cultural Dive</h4><p class="text-gray-600">Immerse yourself in Japanese culture from ancient temples to modern marvels.</p></div>
                    </div>
                </div>
            </div>
        </section>

        <section id="pricing" class="py-20 secondary-bg">
            <div class="container mx-auto px-6">
                <div class="text-center mb-12">
                    <h3 class="text-3xl md:text-4xl font-bold">Simple, Transparent Pricing</h3>
                    <p class="text-gray-600 mt-2">Choose the plan that's right for your travel style.</p>
                </div>
                <div class="grid md:grid-cols-2 gap-8 max-w-4xl mx-auto">
                    <div class="border rounded-lg p-8 flex flex-col text-center bg-white">
                        <h4 class="text-2xl font-bold mb-4">Explorer</h4>
                        <p class="text-gray-600 mb-6 flex-grow">The essentials for planning, completely free.</p>
                        <p class="text-4xl font-extrabold mb-4">£0<span class="text-lg font-normal text-gray-500">/month</span></p>
                        <ul class="space-y-4 text-gray-600 mb-8 text-left">
                            <li class="flex items-center"><i data-lucide="check" class="w-5 h-5 text-green-500 mr-2"></i>AI Itinerary Planning (3 per month)</li>
                            <li class="flex items-center"><i data-lucide="check" class="w-5 h-5 text-green-500 mr-2"></i>Save Itineraries to your account</li>
                        </ul>
                        <button id="explorer-plan-button" class="w-full mt-auto bg-gray-200 text-gray-800 font-semibold py-3 rounded-lg">Your Current Plan</button>
                    </div>
                    <div class="border-2 primary-border rounded-lg p-8 flex flex-col relative shadow-2xl text-center bg-white">
                        <span class="primary-btn text-white text-xs font-bold px-3 py-1 rounded-full absolute -top-4 left-1/2 -translate-x-1/2">Most Popular</span>
                        <h4 class="text-2xl font-bold mb-4">Globetrotter Pro</h4>
                        <p class="text-gray-600 mb-6 flex-grow">For the serious traveler who wants it all.</p>
                        <p class="text-4xl font-extrabold mb-4">£9.99<span class="text-lg font-normal text-gray-500">/month</span></p>
                        <ul class="space-y-4 text-gray-600 mb-8 text-left">
                            <li class="flex items-center"><i data-lucide="check" class="w-5 h-5 text-green-500 mr-2"></i>Unlimited AI Itineraries</li>
                            <li class="flex items-center"><i data-lucide="check" class="w-5 h-5 text-green-500 mr-2"></i>Download Itineraries for Offline Use</li>
                            <li class="flex items-center"><i data-lucide="check" class="w-5 h-5 text-green-500 mr-2"></i>Real-time Flight & Hotel Deals</li>
                            <li class="flex items-center"><i data-lucide="check" class="w-5 h-5 text-green-500 mr-2"></i>Group Trip Collaboration</li>
                            <li class="flex items-center"><i data-lucide="check" class="w-5 h-5 text-green-500 mr-2"></i>Manual Itinerary Editing</li>
                        </ul>
                        <button id="upgrade-button" class="w-full mt-auto primary-btn font-semibold py-3 rounded-lg hover:bg-[#0A4C53]">Upgrade Now</button>
                    </div>
                </div>
            </div>
        </section>

        <section id="planner" class="py-20">
            <div class="container mx-auto px-6">
                <div class="text-center mb-12">
                    <h3 class="text-3xl md:text-4xl font-bold">Your Personal Travel Planner</h3>
                    <p class="text-gray-600 mt-2">Let's plan your next unforgettable journey.</p>
                </div>
                <!-- Responsive container: side-by-side on desktop, stacked on mobile -->
                <div class="flex flex-col lg:flex-row gap-6 max-w-7xl mx-auto items-start">
                    <!-- Chat Section -->
                    <div id="chat-container" class="w-full lg:w-3/5 bg-white shadow-xl overflow-visible">
                        <div id="chat-window" class="p-6 lg:h-[600px] h-96 overflow-y-auto space-y-4 rounded-t-lg">
                            <div class="flex items-start gap-3">
                                <div class="bg-[#E0E7E9] p-2 rounded-full"><i data-lucide="bot" class="w-6 h-6 text-[#0D5C63]"></i></div>
                                <div class="chat-bubble-ai p-4 rounded-lg rounded-tl-none max-w-[85%]">
                                    <p class="font-semibold mb-1">KimatAI</p>
                                    <p>Hello! I'm your AI travel planner. Where are you dreaming of going?</p>
                                </div>
                            </div>
                        </div>

                    <!-- Persistent Chat Bar (shown after itinerary generation) -->
                    <div id="persistent-chat-bar" class="hidden px-4 py-3 border-t bg-white">
                        <div class="flex items-center bg-gray-50 rounded-lg border-2 border-blue-300 shadow-sm">
                            <input type="text" id="persistent-chat-input" placeholder="Ask me anything about your trip..." class="w-full p-3 text-sm border-none focus:ring-0 rounded-lg bg-transparent" autocomplete="off">
                            <button id="persistent-send-button" class="p-3 text-blue-600 hover:text-blue-700 transition-colors">
                                <i data-lucide="send" class="w-5 h-5"></i>
                            </button>
                        </div>
                    </div>

                    <!-- Action bar (appears after an AI itinerary is shown) -->
                    <div id="action-buttons" class="hidden px-4 py-3 border-t bg-white flex justify-end gap-2">
                      <button id="share-button" class="inline-flex items-center gap-2 bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700">
                        <i data-lucide="share-2" class="w-4 h-4"></i><span class="text-white font-medium">Share Trip</span>
                      </button>
                      <button id="save-button" class="inline-flex items-center gap-2 primary-btn px-3 py-2 rounded-lg">
                        <i data-lucide="save" class="w-4 h-4"></i><span class="text-white font-medium">Save Itinerary</span>
                      </button>
                      <button id="download-button" class="inline-flex items-center gap-2 bg-gray-200 text-gray-800 px-3 py-2 rounded-lg">
                        <i data-lucide="download" class="w-4 h-4"></i><span class="text-gray-800 font-medium">Download PDF</span>
                      </button>
                    </div>

                    <!-- Prompt Helper -->
                    <div class="p-4 bg-gray-100 border-t rounded-b-lg">
                        <div class="flex border-b mb-4">
                            <button id="guided-tab-btn" class="tab-btn active font-semibold py-2 px-4 border-b-2 primary-border text-[#0D5C63]">Guided</button>
                            <button id="manual-tab-btn" class="tab-btn text-gray-500 font-semibold py-2 px-4">Manual</button>
                        </div>

                        <!-- Guided Mode Container -->
                        <div id="guided-mode-container">
                        <!-- Guided Prompt Panel -->
                        <div id="guided-panel">
                            <!-- Multi-city Toggle (Always Visible) -->
                            <div class="mb-4">
                                <div class="flex items-center justify-end mb-2">
                                    <label class="flex items-center text-sm text-gray-600">
                                        <input type="checkbox" id="multi-city-toggle" class="mr-2 rounded border-gray-300 text-[#0D5C63] focus:ring-[#0D5C63]">
                                        Multi-city trip
                                    </label>
                                </div>
                            </div>
                            
                            <!-- Multi-city destination inputs (hidden by default) -->
                            <div id="multi-destination-container" class="hidden mb-4">
                                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 min-h-[600px]">
                                            <!-- Multi-City Journey Section -->
                                            <div class="bg-gradient-to-br from-blue-50 to-indigo-50 rounded-xl border border-blue-200 p-6 min-h-[600px] flex flex-col">
                                                <div class="flex items-center gap-2 mb-3">
                                                <div class="w-8 h-8 bg-blue-100 rounded-full flex items-center justify-center">
                                                    <i data-lucide="map-pin" class="w-4 h-4 text-blue-600"></i>
                                                </div>
                                                <div>
                                                    <h4 class="font-semibold text-gray-800">Multi-City Journey</h4>
                                                    <p class="text-xs text-gray-600">Plan your route through multiple destinations</p>
                                                </div>
                                            </div>
                                            
                                            <div class="space-y-4 flex-1" id="city-list">
                                                <div class="multi-city-item bg-white rounded-lg border border-gray-200 p-4 shadow-sm hover:shadow-md transition-shadow">
                                                    <div class="flex items-center justify-between mb-3">
                                                        <div class="flex items-center gap-2">
                                                            <div class="w-6 h-6 bg-green-100 rounded-full flex items-center justify-center text-xs font-semibold text-green-600">1</div>
                                                            <span class="font-medium text-gray-700">First Stop</span>
                                                        </div>
                                                        <div class="text-xs text-gray-500">Starting point</div>
                                                    </div>
                                                    <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                                                        <div>
                                                            <label class="block text-xs font-medium text-gray-600 mb-1">Destination</label>
                                                            <input type="text" class="city-input w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all" placeholder="e.g., Paris, France">
                                                        </div>
                                                        <div>
                                                            <label class="block text-xs font-medium text-gray-600 mb-1">Duration</label>
                                                            <input type="text" class="days-input w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all" placeholder="e.g., 3 days">
                                                        </div>
                                                    </div>
                                                </div>
                                                
                                                <div class="multi-city-item bg-white rounded-lg border border-gray-200 p-4 shadow-sm hover:shadow-md transition-shadow">
                                                    <div class="flex items-center justify-between mb-3">
                                                        <div class="flex items-center gap-2">
                                                            <div class="w-6 h-6 bg-blue-100 rounded-full flex items-center justify-center text-xs font-semibold text-blue-600">2</div>
                                                            <span class="font-medium text-gray-700">Second Stop</span>
                                                        </div>
                                                        <button type="button" class="remove-city-btn p-1 text-red-500 hover:text-red-700 hover:bg-red-50 rounded-full transition-colors">
                                                            <i data-lucide="x" class="w-4 h-4"></i>
                                                        </button>
                                                    </div>
                                                    <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                                                        <div>
                                                            <label class="block text-xs font-medium text-gray-600 mb-1">Destination</label>
                                                            <input type="text" class="city-input w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all" placeholder="e.g., Rome, Italy">
                                                        </div>
                                                        <div>
                                                            <label class="block text-xs font-medium text-gray-600 mb-1">Duration</label>
                                                            <input type="text" class="days-input w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all" placeholder="e.g., 4 days">
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                            
                                            <button type="button" id="add-city-btn" class="w-full mt-4 flex items-center justify-center gap-2 py-3 px-4 border-2 border-dashed border-blue-300 rounded-lg text-blue-600 hover:text-blue-700 hover:border-blue-400 hover:bg-blue-50 transition-all font-medium">
                                                <i data-lucide="plus-circle" class="w-5 h-5"></i>
                                                <span>Add Another Destination</span>
                                            </button>
                                            
                                                <div class="mt-3 flex items-start gap-2 p-3 bg-blue-50 rounded-lg border border-blue-200">
                                                    <i data-lucide="info" class="w-4 h-4 text-blue-600 mt-0.5 flex-shrink-0"></i>
                                                    <div class="text-xs text-blue-700">
                                                        <p class="font-medium">Trip Planning Tip:</p>
                                                        <p>We'll create a seamless itinerary connecting all your destinations, including travel time and logistics between cities.</p>
                                                    </div>
                                                </div>
                                            </div>
                                            
                                            <!-- Multi-city Travel Details Section -->
                                            <div id="multi-city-travelers" class="bg-gray-50 rounded-xl p-6 border border-gray-200 hidden min-h-[600px] flex flex-col">
                                                <h3 class="text-sm font-semibold text-gray-800 mb-3 flex items-center gap-2">
                                                    <i data-lucide="users" class="w-4 h-4 text-blue-600"></i>
                                                    Travel Details
                                                </h3>
                                                <div class="grid grid-cols-1 gap-6 flex-1">
                                                    <div>
                                                        <label for="multi-travelers" class="block text-sm font-medium text-gray-700">Who's traveling?</label>
                                                        <select id="multi-travelers" class="mt-2 block w-full pl-4 pr-10 py-3 text-base border-gray-300 focus:outline-none focus:ring-[#0D5C63] focus:border-[#0D5C63] rounded-lg bg-white">
                                                            <option>Solo</option>
                                                            <option selected>Couple</option>
                                                            <option>Family with young children</option>
                                                            <option>Family with teenagers</option>
                                                            <option>Friends</option>
                                                        </select>
                                                    </div>
                                                    <div>
                                                        <label for="multi-pace" class="block text-sm font-medium text-gray-700">Travel pace</label>
                                                        <select id="multi-pace" class="mt-2 block w-full pl-4 pr-10 py-3 text-base border-gray-300 focus:outline-none focus:ring-[#0D5C63] focus:border-[#0D5C63] rounded-lg bg-white">
                                                            <option>Relaxed</option>
                                                            <option selected>Balanced</option>
                                                            <option>Action-Packed</option>
                                                        </select>
                                                    </div>
                                                    <div>
                                                        <label for="multi-budget" class="block text-sm font-medium text-gray-700">Budget</label>
                                                        <select id="multi-budget" class="mt-2 block w-full pl-4 pr-10 py-3 text-base border-gray-300 focus:outline-none focus:ring-[#0D5C63] focus:border-[#0D5C63] rounded-lg bg-white">
                                                            <option>Budget-Friendly</option>
                                                            <option selected>Mid-Range</option>
                                                            <option>Luxury</option>
                                                        </select>
                                                    </div>
                                                    <div>
                                                        <label for="multi-transport" class="block text-sm font-medium text-gray-700">How will you get around?</label>
                                                        <select id="multi-transport" class="mt-2 block w-full pl-4 pr-10 py-3 text-base border-gray-300 focus:outline-none focus:ring-[#0D5C63] focus:border-[#0D5C63] rounded-lg bg-white">
                                                            <option>Public Transport</option>
                                                            <option selected>Rental Car</option>
                                                            <option>Ride-Sharing & Taxis</option>
                                                            <option>Mostly Walking</option>
                                                        </select>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                            </div>
                            
                            <!-- Destination Suggestion Button -->
                            <div class="mb-3">
                                <button id="suggest-destination-btn-guided" type="button" class="w-full py-2.5 px-4 bg-gradient-to-r from-purple-50 to-blue-50 border-2 border-purple-300 text-gray-700 rounded-lg hover:border-purple-400 hover:from-purple-100 hover:to-blue-100 transition-all duration-300 flex items-center justify-center gap-2">
                                    <i data-lucide="compass" class="w-4 h-4"></i>
                                    <span class="text-sm font-medium">Not sure where to go? Get AI suggestions</span>
                                    <span class="ml-2 px-2 py-0.5 bg-gradient-to-r from-yellow-400 to-orange-400 text-white text-xs font-bold rounded-full">PRO</span>
                                </button>
                            </div>
                            
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                                <div>
                                    <!-- Single destination input (default) -->
                                    <div id="single-destination-container">
                                        <label for="destination" class="block text-sm font-medium text-gray-700">Destination</label>
                                        <input type="text" id="destination" placeholder="e.g., Costa Rica" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-[#0D5C63] focus:border-[#0D5C63]">
                                    </div>
                                </div>
                                <div>
                                    <label for="duration" class="block text-sm font-medium text-gray-700">Duration</label>
                                    <input type="text" id="duration" placeholder="e.g., 7 days" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-[#0D5C63] focus:border-[#0D5C63]">
                                </div>
                                
                                <!-- Travel Details Section -->
                                <div id="single-travel-details" class="md:col-span-2 bg-gray-50 rounded-lg p-4 border border-gray-200">
                                    <h3 class="text-sm font-semibold text-gray-800 mb-3 flex items-center gap-2">
                                        <i data-lucide="users" class="w-4 h-4 text-blue-600"></i>
                                        Travel Details
                                    </h3>
                                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                        <div>
                                            <label for="travelers" class="block text-sm font-medium text-gray-700">Who's traveling?</label>
                                            <select id="travelers" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-[#0D5C63] focus:border-[#0D5C63] sm:text-sm rounded-md bg-white">
                                                <option>Solo</option>
                                                <option selected>Couple</option>
                                                <option>Family with young children</option>
                                                <option>Family with teenagers</option>
                                                <option>Friends</option>
                                            </select>
                                        </div>
                                        <div>
                                            <label for="pace" class="block text-sm font-medium text-gray-700">Travel pace</label>
                                            <select id="pace" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-[#0D5C63] focus:border-[#0D5C63] sm:text-sm rounded-md bg-white">
                                                <option>Relaxed</option>
                                                <option selected>Balanced</option>
                                                <option>Action-Packed</option>
                                            </select>
                                        </div>
                                        <div>
                                            <label for="budget" class="block text-sm font-medium text-gray-700">Budget</label>
                                            <select id="budget" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-[#0D5C63] focus:border-[#0D5C63] sm:text-sm rounded-md bg-white">
                                                <option>Budget-Friendly</option>
                                                <option selected>Mid-Range</option>
                                                <option>Luxury</option>
                                            </select>
                                        </div>
                                        <div>
                                            <label for="transport" class="block text-sm font-medium text-gray-700">How will you get around?</label>
                                            <select id="transport" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-[#0D5C63] focus:border-[#0D5C63] sm:text-sm rounded-md bg-white">
                                                <option>Public Transport</option>
                                                <option selected>Rental Car</option>
                                                <option>Ride-Sharing & Taxis</option>
                                                <option>Mostly Walking</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>
                                <div class="md:col-span-2">
                                    <label class="block text-sm font-medium text-gray-700">Interests</label>
                                    <div id="interest-container" class="mt-2 flex flex-wrap gap-2">
                                        <button class="interest-btn text-sm border border-gray-300 rounded-full px-3 py-1 transition" data-selected="false">Adventure & Outdoors</button>
                                        <button class="interest-btn text-sm border border-gray-300 rounded-full px-3 py-1 transition" data-selected="false">History & Culture</button>
                                        <button class="interest-btn text-sm border border-gray-300 rounded-full px-3 py-1 transition" data-selected="false">Food & Drink</button>
                                        <button class="interest-btn text-sm border border-gray-300 rounded-full px-3 py-1 transition" data-selected="false">Beaches & Relaxation</button>
                                        <button class="interest-btn text-sm border border-gray-300 rounded-full px-3 py-1 transition" data-selected="false">Nightlife & Entertainment</button>
                                        <button class="interest-btn text-sm border border-gray-300 rounded-full px-3 py-1 transition" data-selected="false">Shopping</button>
                                    </div>
                                </div>
                            </div>
                            
                            <button id="generate-prompt-btn" class="w-full primary-btn font-semibold py-3 rounded-lg hover:bg-[#0A4C53] flex items-center justify-center space-x-2">
                                <span class="btn-text flex items-center justify-center space-x-2">
                                    <i data-lucide="sparkles"></i>
                                    <span>Generate & Plan</span>
                                </span>
                            </button>
                        </div>
                        </div>
                        
                        <!-- Manual Prompt Panel -->
                        <div id="manual-panel" class="hidden">
                            <!-- Instructions -->
                            <div class="bg-blue-50 rounded-lg p-4 mb-4 border border-blue-200">
                                <div class="flex items-start gap-3">
                                    <div class="w-8 h-8 bg-blue-100 rounded-full flex items-center justify-center flex-shrink-0 mt-1">
                                        <i data-lucide="lightbulb" class="w-4 h-4 text-blue-600"></i>
                                    </div>
                                    <div>
                                        <h3 class="font-semibold text-blue-900 mb-2">How to write a great travel prompt:</h3>
                                        <ul class="text-sm text-blue-800 space-y-1">
                                            <li>• Include your destination, duration, and travel style</li>
                                            <li>• Mention your interests (food, culture, adventure, etc.)</li>
                                            <li>• Specify your budget level and group size</li>
                                            <li>• Add any special requirements or preferences</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Example Prompts -->
                            <div class="bg-gray-50 rounded-lg p-4 mb-4 border border-gray-200">
                                <h4 class="font-medium text-gray-800 mb-2">Example prompts:</h4>
                                <div class="space-y-2 text-sm text-gray-600">
                                    <div class="bg-white p-3 rounded border-l-4 border-green-400">
                                        "Plan a 10-day romantic honeymoon to Japan for a couple who loves food, culture, and temples. Mid-range budget."
                                    </div>
                                    <div class="bg-white p-3 rounded border-l-4 border-blue-400">
                                        "Create a 5-day adventure trip to Costa Rica for 4 friends. We want zip-lining, wildlife, and beaches. Budget-friendly."
                                    </div>
                                    <div class="bg-white p-3 rounded border-l-4 border-purple-400">
                                        "Family trip to Paris for 7 days with two teenagers. Include museums, shopping, and kid-friendly activities. Luxury budget."
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Quick Action Button -->
                            <div class="mb-3">
                                <button id="suggest-destination-btn" class="w-full py-2.5 px-4 bg-gradient-to-r from-purple-50 to-blue-50 border-2 border-purple-300 text-gray-700 rounded-lg hover:border-purple-400 hover:from-purple-100 hover:to-blue-100 transition-all duration-300 flex items-center justify-center gap-2">
                                    <i data-lucide="sparkles" class="w-4 h-4"></i>
                                    <span class="text-sm font-medium">Not sure where to go? Get AI suggestions</span>
                                    <span class="ml-2 px-2 py-0.5 bg-gradient-to-r from-yellow-400 to-orange-400 text-white text-xs font-bold rounded-full">PRO</span>
                                </button>
                            </div>
                            
                            <!-- Input Field -->
                            <div class="flex items-center bg-white rounded-lg border shadow-sm">
                                <input type="text" id="chat-input" placeholder="Describe your perfect trip or ask me anything..." class="w-full p-4 border-none focus:ring-0 rounded-lg" autocomplete="off">
                                <button id="send-button" class="p-4 text-[#0D5C63] hover:text-[#0A4C53]"><i data-lucide="send" class="w-6 h-6"></i></button>
                            </div>
                        </div> <!-- End prompt helper -->
                    </div> <!-- End chat-container -->

                    <!-- Map Section (shows on right on desktop, below on mobile) -->
                    <div id="map-section-wrapper" class="hidden w-full lg:w-2/5 lg:flex flex-col h-fit">
                        <!-- Map will be dynamically inserted here -->
                    </div>
                </div> <!-- End flex container -->
            </div> <!-- End container mx-auto -->
        </section>
    </main>

    <!-- Footer -->
    <footer class="bg-[#0A2E36] text-white">
        <div class="container mx-auto px-6 py-12">
            <div class="grid md:grid-cols-3 gap-8">
                <div><h4 class="text-lg font-bold mb-4">KimatAI</h4><p class="text-gray-400">Intelligent Itineraries, crafted with AI.</p></div>
                <div><h4 class="text-lg font-bold mb-4">Quick Links</h4><ul><li><a href="#features" class="text-gray-400 hover:text-white">How It Works</a></li><li><a href="#itineraries" class="text-gray-400 hover:text-white">Samples</a></li><li><a href="#pricing" class="text-gray-400 hover:text-white">Pricing</a></li><li><button id="about-link-footer" class="text-gray-400 hover:text-white text-left">About</button></li></ul></div>
                <div><h4 class="text-lg font-bold mb-4">Contact Us</h4><a href="mailto:contact@kimatai.com" class="text-gray-400 hover:text-white flex items-center"><i data-lucide="mail" class="w-5 h-5 mr-2"></i>contact@kimatai.com</a></div>
            </div>
            <div class="mt-8 border-t border-gray-700 pt-6 text-center text-gray-500"><p>&copy; 2025 KimatAI. All rights reserved.</p></div>
        </div>
    </footer>

    <!-- Auth Modal -->
    <div id="auth-modal" class="modal-backdrop" style="display: none;" aria-hidden="true">
        <div class="bg-white rounded-lg shadow-xl p-8 max-w-sm w-full relative">
            <button class="absolute top-4 right-4 text-gray-400 hover:text-gray-600" data-action="hide-auth-modal"><i data-lucide="x"></i></button>
            <h3 id="auth-title" class="text-2xl font-bold mb-4 text-center">Create Account</h3>
            <p id="auth-error" class="text-red-500 text-sm mb-4 text-center hidden"></p>
            <form id="auth-form" class="space-y-4">
                <div>
                    <label for="email" class="block text-sm font-medium text-gray-700">Email Address</label>
                    <input type="email" id="email" required autocomplete="email" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-[#0D5C63] focus:border-[#0D5C63]">
                </div>
                <div>
                    <label for="password" class="block text-sm font-medium text-gray-700">Password <span class="text-xs text-gray-500">(min. 6 characters)</span></label>
                    <input type="password" id="password" required minlength="6" autocomplete="current-password" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-[#0D5C63] focus:border-[#0D5C63]">
                </div>
                <button type="submit" id="auth-submit-button" class="w-full primary-btn font-semibold py-2 rounded-lg hover:bg-[#0A4C53]">Create Account</button>
            </form>
            <p class="text-center text-sm text-gray-600 mt-4">
                <span id="auth-toggle-text">Already have an account?</span>
                <button id="auth-toggle-button" class="font-semibold text-[#0D5C63] hover:underline">Log In</button>
            </p>
        </div>
    </div>
    
    <!-- About Modal -->
    <div id="about-modal" class="modal-backdrop">
        <div class="bg-white rounded-xl shadow-2xl max-w-2xl w-full relative overflow-hidden">
            <!-- Header with gradient -->
            <div class="bg-gradient-to-r from-[#0D5C63] to-[#0A4C53] px-8 py-6 text-white">
                <button class="absolute top-4 right-4 text-white hover:text-gray-200" data-action="hide-about-modal">
                    <i data-lucide="x" class="w-6 h-6"></i>
                </button>
                <h3 class="text-3xl font-bold mb-2">About KimatAI</h3>
                <p class="text-gray-100 text-sm">Where technology meets wanderlust</p>
            </div>
            
            <!-- Content -->
            <div class="p-8 max-h-[70vh] overflow-y-auto">
                <!-- Personal Story -->
                <div class="mb-8">
                    <div class="flex items-center gap-3 mb-4">
                        <div class="w-10 h-10 bg-[#0D5C63] bg-opacity-10 rounded-full flex items-center justify-center">
                            <i data-lucide="heart" class="w-5 h-5 text-[#0D5C63]"></i>
                        </div>
                        <h4 class="text-xl font-bold text-gray-900">Our Story</h4>
                    </div>
                    <p class="text-gray-700 leading-relaxed mb-4">
                        KimatAI was born from a simple frustration: planning trips took longer than the trips themselves. 
                        Hours spent researching destinations, reading reviews, mapping routes—only to wonder if you missed something amazing.
                    </p>
                    <p class="text-gray-700 leading-relaxed">
                        We built KimatAI to change that. By combining the power of AI with real travel insights, we help you create 
                        personalized itineraries in seconds, so you can spend less time planning and more time dreaming about your next adventure.
                    </p>
                </div>
                
                <!-- What We Do -->
                <div class="mb-8 bg-gray-50 rounded-lg p-6">
                    <div class="flex items-center gap-3 mb-4">
                        <div class="w-10 h-10 bg-blue-100 rounded-full flex items-center justify-center">
                            <i data-lucide="sparkles" class="w-5 h-5 text-blue-600"></i>
                        </div>
                        <h4 class="text-xl font-bold text-gray-900">What We Do</h4>
                    </div>
                    <p class="text-gray-700 leading-relaxed">
                        We use advanced AI to understand your travel style, preferences, and budget. Then we craft detailed, 
                        day-by-day itineraries that feel like they were made by a friend who knows exactly what you'll love—because in a way, they were.
                    </p>
                </div>
                
                <!-- Values -->
                <div class="mb-6">
                    <div class="flex items-center gap-3 mb-4">
                        <div class="w-10 h-10 bg-green-100 rounded-full flex items-center justify-center">
                            <i data-lucide="compass" class="w-5 h-5 text-green-600"></i>
                        </div>
                        <h4 class="text-xl font-bold text-gray-900">Our Values</h4>
                    </div>
                    <div class="grid gap-3">
                        <div class="flex items-start gap-3">
                            <i data-lucide="check-circle" class="w-5 h-5 text-[#0D5C63] mt-0.5 flex-shrink-0"></i>
                            <div>
                                <p class="font-semibold text-gray-900">Personalization First</p>
                                <p class="text-sm text-gray-600">Every traveler is unique, and so should be their journey</p>
                            </div>
                        </div>
                        <div class="flex items-start gap-3">
                            <i data-lucide="check-circle" class="w-5 h-5 text-[#0D5C63] mt-0.5 flex-shrink-0"></i>
                            <div>
                                <p class="font-semibold text-gray-900">Simplicity & Speed</p>
                                <p class="text-sm text-gray-600">Great travel planning shouldn't take forever</p>
                            </div>
                        </div>
                        <div class="flex items-start gap-3">
                            <i data-lucide="check-circle" class="w-5 h-5 text-[#0D5C63] mt-0.5 flex-shrink-0"></i>
                            <div>
                                <p class="font-semibold text-gray-900">Authentic Experiences</p>
                                <p class="text-sm text-gray-600">We help you discover places that matter, not just tourist traps</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- CTA -->
                <div class="mt-8 pt-6 border-t border-gray-200 text-center">
                    <p class="text-gray-700 mb-4">Have questions or feedback? We'd love to hear from you.</p>
                    <a href="mailto:contact@kimatai.com" class="inline-flex items-center gap-2 text-[#0D5C63] font-semibold hover:text-[#0A4C53]">
                        <i data-lucide="mail" class="w-5 h-5"></i>
                        contact@kimatai.com
                    </a>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Itinerary Detail Modal -->
    <div id="itinerary-detail-modal" class="modal-backdrop p-4" aria-hidden="true">
        <div class="bg-white rounded-lg shadow-xl max-w-2xl w-full relative h-4/5 flex flex-col" role="dialog" aria-modal="true" aria-labelledby="itinerary-detail-title" tabindex="-1">
            <div class="p-6 border-b flex justify-between items-center flex-shrink-0">
                <h3 id="itinerary-detail-title" contenteditable="false" class="text-2xl font-bold truncate pr-8">Itinerary Details</h3>
                <div class="flex items-center gap-2">
                    <button id="show-map-btn" class="flex items-center gap-2 bg-green-50 text-green-700 text-sm font-medium px-4 py-2 rounded-lg border border-green-200 hover:bg-green-100 hover:border-green-300 transition-all duration-200">
                        <i data-lucide="map-pin" class="w-4 h-4"></i>
                        <span>Map</span>
                    </button>
                    <button id="share-itinerary-btn" class="flex items-center gap-2 bg-blue-50 text-blue-700 text-sm font-medium px-4 py-2 rounded-lg border border-blue-200 hover:bg-blue-100 hover:border-blue-300 transition-all duration-200">
                        <i data-lucide="share-2" class="w-4 h-4"></i>
                        <span>Share</span>
                    </button>
                    <button id="edit-itinerary-btn" class="flex items-center gap-2 bg-blue-50 text-blue-700 text-sm font-medium px-4 py-2 rounded-lg border border-blue-200 hover:bg-blue-100 hover:border-blue-300 transition-all duration-200">
                        <i data-lucide="edit-3" class="w-4 h-4"></i>
                        <span>Edit</span>
                    </button>
                    <button id="save-changes-btn" class="flex items-center gap-2 bg-green-50 text-green-700 text-sm font-medium px-4 py-2 rounded-lg border border-green-200 hover:bg-green-100 hover:border-green-300 transition-all duration-200 hidden">
                        <i data-lucide="save" class="w-4 h-4"></i>
                        <span>Save</span>
                    </button>
                    <button id="cancel-edit-btn" class="flex items-center gap-2 bg-gray-50 text-gray-700 text-sm font-medium px-4 py-2 rounded-lg border border-gray-200 hover:bg-gray-100 hover:border-gray-300 transition-all duration-200 hidden">
                        <i data-lucide="x" class="w-4 h-4"></i>
                        <span>Cancel</span>
                    </button>
                    <button id="delete-itinerary-btn" class="flex items-center gap-2 bg-red-50 text-red-700 text-sm font-medium px-4 py-2 rounded-lg border border-red-200 hover:bg-red-100 hover:border-red-300 transition-all duration-200">
                        <i data-lucide="trash-2" class="w-4 h-4"></i>
                        <span>Delete</span>
                    </button>
                    <div class="w-px h-6 bg-gray-300 mx-1"></div>
                    <button class="text-gray-400 hover:text-gray-600 p-1 rounded hover:bg-gray-100 transition-colors duration-200" data-action="hide-itinerary-detail-modal" aria-label="Close">
                        <i data-lucide="x" class="w-5 h-5"></i>
                    </button>
                </div>
            </div>
            <div id="itinerary-detail-content" class="p-6 overflow-y-auto flex-grow"></div>
        </div>
    </div>

    <!-- Delete Confirmation Modal -->
    <div id="delete-confirm-modal" class="modal-backdrop" aria-hidden="true">
        <div class="bg-white rounded-lg shadow-xl p-8 max-w-sm w-full text-center" role="dialog" aria-modal="true" aria-labelledby="delete-confirm-title" tabindex="-1">
            <h3 id="delete-confirm-title" class="text-xl font-bold mb-4">Are you sure?</h3>
            <p class="text-gray-600 mb-6">This action cannot be undone. Do you really want to delete this trip?</p>
            <div class="flex justify-center space-x-4">
                <button id="cancel-delete-btn" class="bg-gray-200 text-gray-800 font-semibold px-6 py-2 rounded-lg hover:bg-gray-300">Cancel</button>
                <button id="confirm-delete-btn" class="bg-red-600 text-white font-semibold px-6 py-2 rounded-lg hover:bg-red-700">Delete</button>
            </div>
        </div>
    </div>
    
    <!-- Upgrade Modal -->
    <div id="upgrade-modal" class="modal-backdrop" aria-hidden="true">
        <div class="bg-white rounded-lg shadow-xl p-8 max-w-sm w-full text-center relative" role="dialog" aria-modal="true" aria-labelledby="upgrade-modal-title" tabindex="-1">
            <button class="absolute top-4 right-4 text-gray-400 hover:text-gray-600" data-action="hide-upgrade-modal" aria-label="Close">
                <i data-lucide="x"></i>
            </button>
            <div class="bg-[#E0E7E9] text-[#0D5C63] rounded-full p-4 inline-block mb-4">
                <i data-lucide="zap" class="w-10 h-10"></i>
            </div>
            <h3 id="upgrade-modal-title" class="text-2xl font-bold mb-2">Upgrade to Pro</h3>
            <p class="text-gray-600 mb-6">This is a premium feature. Upgrade to Globetrotter Pro to unlock it and more!</p>
            <a href="#pricing" id="upgrade-modal-link" class="w-full block primary-btn font-semibold py-3 rounded-lg hover:bg-[#0A4C53]">
                View Pricing Plans
            </a>
        </div>
    </div>
    
    <!-- Limit Reached Modal -->
    <div id="limit-reached-modal" class="modal-backdrop" aria-hidden="true">
        <div class="bg-white rounded-lg shadow-xl p-8 max-w-sm w-full text-center relative" role="dialog" aria-modal="true" aria-labelledby="limit-reached-modal-title" tabindex="-1">
            <button class="absolute top-4 right-4 text-gray-400 hover:text-gray-600" data-action="hide-limit-reached-modal" aria-label="Close">
                <i data-lucide="x"></i>
            </button>
            <div class="bg-[#E0E7E9] text-[#0D5C63] rounded-full p-4 inline-block mb-4">
                <i data-lucide="award" class="w-10 h-10"></i>
            </div>
            <h3 id="limit-reached-modal-title" class="text-2xl font-bold mb-2">Free Limit Reached</h3>
            <p class="text-gray-600 mb-6">You've planned your 3 free itineraries for the month. Upgrade to Globetrotter Pro for unlimited planning!</p>
            <a href="#pricing" id="limit-reached-modal-link" class="w-full block primary-btn font-semibold py-3 rounded-lg hover:bg-[#0A4C53]">
                Upgrade to Pro
            </a>
        </div>
    </div>
    
    <!-- Destination Suggestion Modal -->
    <div id="destination-suggest-modal" class="modal-backdrop" aria-hidden="true">
        <div class="bg-white rounded-lg shadow-xl p-8 max-w-2xl w-full relative" style="max-height: calc(100vh - 80px); overflow-y: auto;" role="dialog" aria-modal="true" aria-labelledby="destination-suggest-title" tabindex="-1">
            <button class="absolute top-4 right-4 text-gray-400 hover:text-gray-600" data-action="hide-destination-suggest-modal" aria-label="Close">
                <i data-lucide="x" class="w-6 h-6"></i>
            </button>
            <div class="text-center mb-6">
                <div class="bg-gradient-to-r from-[#0D5C63] to-[#0A4C53] text-white rounded-full p-4 inline-block mb-4">
                    <i data-lucide="sparkles" class="w-10 h-10"></i>
                </div>
                <h3 id="destination-suggest-title" class="text-3xl font-bold mb-2">Where Should You Go?</h3>
                <p class="text-gray-600">Tell us your preferences and we'll suggest perfect destinations</p>
            </div>
            
            <!-- Loading Indicator -->
            <div id="destination-loading" class="hidden text-center py-16">
                <div class="inline-flex flex-col items-center gap-6">
                    <!-- Simple Spinner -->
                    <div class="relative w-16 h-16">
                        <div class="absolute inset-0 border-4 border-gray-200 rounded-full"></div>
                        <div class="absolute inset-0 border-4 border-[#0D5C63] rounded-full animate-spin" style="border-right-color: transparent; border-bottom-color: transparent;"></div>
                    </div>
                    
                    <div class="space-y-2">
                        <p class="text-lg font-semibold text-[#0D5C63]">Finding Your Perfect Destination</p>
                        <p class="text-sm text-gray-500">This will only take a moment...</p>
                    </div>
                </div>
            </div>
            
            <form id="destination-suggest-form" class="space-y-8">
                <!-- Required Fields Section -->
                <div class="bg-red-50 border border-red-200 rounded-lg p-5">
                    <h4 class="text-base font-bold text-gray-900 mb-4 flex items-center gap-2">
                        <span>Required Information</span>
                        <span class="text-red-500">*</span>
                    </h4>
                    <div class="grid md:grid-cols-3 gap-6">
                        <div>
                            <label class="block text-sm font-semibold text-gray-700 mb-3">Travel Style</label>
                            <select id="travel-style" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-[#0D5C63] focus:border-transparent">
                                <option value="">Select style...</option>
                                <option value="adventure">Adventure & Outdoor</option>
                                <option value="relaxation">Relaxation & Beach</option>
                                <option value="culture">Culture & History</option>
                                <option value="food">Food & Culinary</option>
                                <option value="nature">Nature & Wildlife</option>
                                <option value="urban">Urban & Nightlife</option>
                                <option value="romantic">Romantic Getaway</option>
                                <option value="family">Family-Friendly</option>
                            </select>
                        </div>
                        <div>
                            <label class="block text-sm font-semibold text-gray-700 mb-3">Budget Level</label>
                            <select id="budget-level" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-[#0D5C63] focus:border-transparent">
                                <option value="">Select budget...</option>
                                <option value="budget">Budget ($-$$)</option>
                                <option value="moderate">Moderate ($$-$$$)</option>
                                <option value="luxury">Luxury ($$$$)</option>
                            </select>
                        </div>
                        <div>
                            <label class="block text-sm font-semibold text-gray-700 mb-3">Trip Duration</label>
                            <select id="trip-duration" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-[#0D5C63] focus:border-transparent">
                                <option value="">Select duration...</option>
                                <option value="weekend">Weekend (2-3 days)</option>
                                <option value="short">Short Trip (4-7 days)</option>
                                <option value="medium">Medium Trip (8-14 days)</option>
                                <option value="long">Extended Trip (15+ days)</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <!-- Optional Fields Section -->
                <div class="bg-blue-50 border border-blue-200 rounded-lg p-5">
                    <h4 class="text-base font-bold text-gray-700 mb-4">Optional Details</h4>
                    <div class="space-y-5">
                        <div class="grid md:grid-cols-2 gap-6">
                            <div>
                                <label class="block text-sm font-semibold text-gray-700 mb-3">Climate Preference</label>
                                <select id="climate-pref" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-[#0D5C63] focus:border-transparent">
                                    <option value="">Any climate...</option>
                                    <option value="tropical">Tropical & Warm</option>
                                    <option value="temperate">Mild & Temperate</option>
                                    <option value="cold">Cool & Snowy</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-sm font-semibold text-gray-700 mb-3">Origin</label>
                                <input type="text" id="origin-location" placeholder="E.g., New York, London..." class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-[#0D5C63] focus:border-transparent">
                            </div>
                        </div>
                        
                        <div class="grid md:grid-cols-2 gap-6">
                            <div>
                                <label class="block text-sm font-semibold text-gray-700 mb-3">When Traveling</label>
                                <input type="text" id="travel-dates" placeholder="E.g., December 2025, Summer 2026..." class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-[#0D5C63] focus:border-transparent">
                            </div>
                            <div>
                                <label class="block text-sm font-semibold text-gray-700 mb-3">Exclude Countries</label>
                                <input type="text" id="exclude-countries" placeholder="E.g., France, Germany..." class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-[#0D5C63] focus:border-transparent">
                            </div>
                        </div>
                        
                        <div>
                            <label class="block text-sm font-semibold text-gray-700 mb-3">Additional Interests</label>
                            <textarea id="additional-interests" rows="3" placeholder="E.g., photography, hiking, wine tasting, shopping, museums..." class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-[#0D5C63] focus:border-transparent resize-none"></textarea>
                        </div>
                    </div>
                </div>
                
                <button type="submit" class="w-full py-4 bg-gradient-to-r from-[#0D5C63] to-[#0A4C53] text-white font-bold text-lg rounded-lg hover:shadow-xl hover:scale-105 transition-all duration-300 mt-2" style="display: flex !important; opacity: 1 !important; visibility: visible !important; background: linear-gradient(135deg, #0D5C63 0%, #0a4a4f 100%) !important;">
                    <span class="flex items-center justify-center gap-2" style="width: 100%;">
                        <i data-lucide="compass" class="w-6 h-6"></i>
                        Get Destination Suggestions
                    </span>
                </button>
            </form>
            
            <!-- Results Section -->
            <div id="destination-results" class="mt-6 hidden">
                <div class="border-t pt-6">
                    <h4 class="text-xl font-bold mb-4 flex items-center gap-2">
                        <i data-lucide="map-pin" class="w-5 h-5 text-[#0D5C63]"></i>
                        Recommended Destinations
                    </h4>
                    <div id="destination-list" class="space-y-4 max-h-96 overflow-y-auto pr-2">
                        <!-- Results will be inserted here -->
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Guest Custom Plan Modal -->
    <div id="guest-custom-plan-modal" class="modal-backdrop" aria-hidden="true">
        <div class="bg-white rounded-lg shadow-xl p-8 max-w-sm w-full text-center relative" role="dialog" aria-modal="true" aria-labelledby="guest-custom-plan-modal-title" tabindex="-1">
            <button class="absolute top-4 right-4 text-gray-400 hover:text-gray-600" data-action="hide-guest-custom-plan-modal" aria-label="Close">
                <i data-lucide="x"></i>
            </button>
            <div class="bg-[#E0E7E9] text-[#0D5C63] rounded-full p-4 inline-block mb-4">
                <i data-lucide="user-plus" class="w-10 h-10"></i>
            </div>
            <h3 id="guest-custom-plan-modal-title" class="text-2xl font-bold mb-2">Create a Free Account</h3>
            <p class="text-gray-600 mb-6">Create a free account to start planning your custom trips and save your itineraries!</p>
            <button id="guest-signup-btn" class="w-full block primary-btn font-semibold py-3 rounded-lg hover:bg-[#0A4C53]">
                Sign Up for Free
            </button>
        </div>
    </div>
    
    <!-- Share Modal -->
    <div id="share-modal" class="modal-backdrop" aria-hidden="true">
        <div class="bg-white rounded-lg shadow-xl p-8 max-w-md w-full relative" role="dialog" aria-modal="true" aria-labelledby="share-modal-title" tabindex="-1">
            <button class="absolute top-4 right-4 text-gray-400 hover:text-gray-600" data-action="hide-share-modal" aria-label="Close">
                <i data-lucide="x"></i>
            </button>
            <h3 id="share-modal-title" class="text-2xl font-bold mb-4">Share Your Trip</h3>
            <p class="text-gray-600 mb-4">Copy the link below and send it to your friends. When they open it, they'll be added as collaborators.</p>
            <div class="flex items-center space-x-2 bg-gray-100 p-2 rounded-lg">
                <input id="share-link-input" type="text" readonly class="w-full bg-gray-100 border-none focus:ring-0">
                <button id="copy-share-link-btn" class="primary-btn p-2 rounded-lg hover:bg-[#0A4C53]">
                    <i data-lucide="copy"></i>
                </button>
            </div>
            <p id="copy-success-msg" class="text-green-600 text-sm mt-2 text-center hidden">Link copied to clipboard!</p>
        </div>
    </div>


    <!-- Firebase SDKs -->
    <script type="module">
    // Version: 9.7.41 - Updated Oct 20, 2025 - CRITICAL FIX: Auto-create users/ document for Pro users too
    // Backend API Configuration - Smart tunnel detection
    const BACKEND_URL = (() => {
        const hostname = window.location.hostname;
        
        // Local development (Live Server or localhost)
        if (hostname === 'localhost' || hostname === '127.0.0.1') {
            return 'http://localhost:3001';
        }
        
        // Cloudflare tunnel (trycloudflare.com) or other tunnels
        // When testing via tunnel, use production backend
        if (hostname.includes('trycloudflare.com') || hostname.includes('ngrok') || hostname.includes('localtunnel')) {
            console.log('🌐 Tunnel detected - using production backend');
            return 'https://kimatai-backend.onrender.com';
        }
        
        // Production (Firebase hosting)
        return 'https://kimatai-backend.onrender.com';
    })();
    
    console.log('📦 Version: 9.7.48 - Smart tunnel detection for tablet testing');
    console.log('🔗 Backend URL:', BACKEND_URL);

        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { 
            getAuth, 
            createUserWithEmailAndPassword, 
            signInWithEmailAndPassword, 
            onAuthStateChanged,
            signOut
        } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { 
            getFirestore, 
            collection, 
            addDoc,
            query,
            where,
            getDocs,
            doc,
            deleteDoc,
            setDoc,
            getDoc,
            updateDoc,
            increment,
            onSnapshot,
            serverTimestamp,
            arrayUnion
        } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
        
        // --- Firebase & App Config ---
        const firebaseConfig = {
            apiKey: "AIzaSyBi9X-cCHx12QeGbSf-BLot7X3L3dTDGDo",
            authDomain: "kimatai-app.firebaseapp.com",
            projectId: "kimatai-app",
            storageBucket: "kimatai-app.firebasestorage.app",
            messagingSenderId: "567122872293",
            appId: "1:567122872293:web:67687ede60b1d2d415510c"
        };
        
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        

        // --- Global State ---
        let lastItineraryJson = null;
        let isLoginMode = false;
        let currentUserSubscription = 'free';
        let currentEditingItinerary = null;
        let currentItineraryId = null;
        let currentItineraryData = null;
        let isEditMode = false;

        // --- Fast Local Coordinate Database ---
        const COORDINATE_DATABASE = {
            // Major Cities & Countries
            'paris': { lat: 48.8566, lng: 2.3522, country: 'France' },
            'london': { lat: 51.5074, lng: -0.1278, country: 'UK' },
            'new york': { lat: 40.7128, lng: -74.0060, country: 'USA' },
            'tokyo': { lat: 35.6762, lng: 139.6503, country: 'Japan' },
            'rome': { lat: 41.9028, lng: 12.4964, country: 'Italy' },
            'barcelona': { lat: 41.3851, lng: 2.1734, country: 'Spain' },
            'amsterdam': { lat: 52.3676, lng: 4.9041, country: 'Netherlands' },
            'berlin': { lat: 52.5200, lng: 13.4050, country: 'Germany' },
            'prague': { lat: 50.0755, lng: 14.4378, country: 'Czech Republic' },
            'vienna': { lat: 48.2082, lng: 16.3738, country: 'Austria' },
            'budapest': { lat: 47.4979, lng: 19.0402, country: 'Hungary' },
            'istanbul': { lat: 41.0082, lng: 28.9784, country: 'Turkey' },
            'dubai': { lat: 25.2048, lng: 55.2708, country: 'UAE' },
            'singapore': { lat: 1.3521, lng: 103.8198, country: 'Singapore' },
            'hong kong': { lat: 22.3193, lng: 114.1694, country: 'Hong Kong' },
            'sydney': { lat: -33.8688, lng: 151.2093, country: 'Australia' },
            'melbourne': { lat: -37.8136, lng: 144.9631, country: 'Australia' },
            'bangkok': { lat: 13.7563, lng: 100.5018, country: 'Thailand' },
            'mumbai': { lat: 19.0760, lng: 72.8777, country: 'India' },
            'delhi': { lat: 28.7041, lng: 77.1025, country: 'India' },
            'beijing': { lat: 39.9042, lng: 116.4074, country: 'China' },
            'shanghai': { lat: 31.2304, lng: 121.4737, country: 'China' },
            'seoul': { lat: 37.5665, lng: 126.9780, country: 'South Korea' },
            'moscow': { lat: 55.7558, lng: 37.6173, country: 'Russia' },
            'cairo': { lat: 30.0444, lng: 31.2357, country: 'Egypt' },
            'marrakech': { lat: 31.6295, lng: -7.9811, country: 'Morocco' },
            'casablanca': { lat: 33.5731, lng: -7.5898, country: 'Morocco' },
            'cape town': { lat: -33.9249, lng: 18.4241, country: 'South Africa' },
            'rio de janeiro': { lat: -22.9068, lng: -43.1729, country: 'Brazil' },
            'buenos aires': { lat: -34.6118, lng: -58.3960, country: 'Argentina' },
            'lima': { lat: -12.0464, lng: -77.0428, country: 'Peru' },
            'mexico city': { lat: 19.4326, lng: -99.1332, country: 'Mexico' },
            'toronto': { lat: 43.6532, lng: -79.3832, country: 'Canada' },
            'vancouver': { lat: 49.2827, lng: -123.1207, country: 'Canada' },
            'los angeles': { lat: 34.0522, lng: -118.2437, country: 'USA' },
            'san francisco': { lat: 37.7749, lng: -122.4194, country: 'USA' },
            'chicago': { lat: 41.8781, lng: -87.6298, country: 'USA' },
            'miami': { lat: 25.7617, lng: -80.1918, country: 'USA' },
            'las vegas': { lat: 36.1699, lng: -115.1398, country: 'USA' },
            
            // Famous Landmarks & Attractions
            'eiffel tower': { lat: 48.8584, lng: 2.2945, country: 'France' },
            'louvre museum': { lat: 48.8606, lng: 2.3376, country: 'France' },
            'notre dame': { lat: 48.8530, lng: 2.3499, country: 'France' },
            'arc de triomphe': { lat: 48.8738, lng: 2.2950, country: 'France' },
            'sacré-cœur': { lat: 48.8867, lng: 2.3431, country: 'France' },
            'big ben': { lat: 51.4994, lng: -0.1245, country: 'UK' },
            'tower bridge': { lat: 51.5055, lng: -0.0754, country: 'UK' },
            'british museum': { lat: 51.5194, lng: -0.1270, country: 'UK' },
            'buckingham palace': { lat: 51.5014, lng: -0.1419, country: 'UK' },
            'westminster abbey': { lat: 51.4994, lng: -0.1273, country: 'UK' },
            'statue of liberty': { lat: 40.6892, lng: -74.0445, country: 'USA' },
            'empire state building': { lat: 40.7484, lng: -73.9857, country: 'USA' },
            'central park': { lat: 40.7829, lng: -73.9654, country: 'USA' },
            'times square': { lat: 40.7580, lng: -73.9855, country: 'USA' },
            'brooklyn bridge': { lat: 40.7061, lng: -73.9969, country: 'USA' },
            'colosseum': { lat: 41.8902, lng: 12.4922, country: 'Italy' },
            'vatican': { lat: 41.9029, lng: 12.4534, country: 'Vatican' },
            'trevi fountain': { lat: 41.9009, lng: 12.4833, country: 'Italy' },
            'pantheon': { lat: 41.8986, lng: 12.4769, country: 'Italy' },
            'spanish steps': { lat: 41.9058, lng: 12.4823, country: 'Italy' },
            'sagrada família': { lat: 41.4036, lng: 2.1744, country: 'Spain' },
            'park güell': { lat: 41.4145, lng: 2.1527, country: 'Spain' },
            'la rambla': { lat: 41.3818, lng: 2.1675, country: 'Spain' },
            'casa batlló': { lat: 41.3916, lng: 2.1649, country: 'Spain' },
            'picasso museum': { lat: 41.3851, lng: 2.1801, country: 'Spain' },
            'anne frank house': { lat: 52.3752, lng: 4.8840, country: 'Netherlands' },
            'van gogh museum': { lat: 52.3584, lng: 4.8811, country: 'Netherlands' },
            'rijksmuseum': { lat: 52.3600, lng: 4.8852, country: 'Netherlands' },
            'vondelpark': { lat: 52.3580, lng: 4.8686, country: 'Netherlands' },
            'red light district': { lat: 52.3731, lng: 4.8922, country: 'Netherlands' },
            'brandenburg gate': { lat: 52.5163, lng: 13.3777, country: 'Germany' },
            'berlin wall': { lat: 52.5080, lng: 13.3909, country: 'Germany' },
            'checkpoint charlie': { lat: 52.5075, lng: 13.3904, country: 'Germany' },
            'neuschwanstein castle': { lat: 47.5576, lng: 10.7498, country: 'Germany' },
            'charles bridge': { lat: 50.0865, lng: 14.4114, country: 'Czech Republic' },
            'prague castle': { lat: 50.0910, lng: 14.4016, country: 'Czech Republic' },
            'old town square': { lat: 50.0875, lng: 14.4213, country: 'Czech Republic' },
            'schönbrunn palace': { lat: 48.1845, lng: 16.3122, country: 'Austria' },
            'salzburg': { lat: 47.8095, lng: 13.0550, country: 'Austria' },
            'parliament building': { lat: 47.5063, lng: 19.0456, country: 'Hungary' },
            'széchenyi thermal baths': { lat: 47.5186, lng: 19.0815, country: 'Hungary' },
            'hagia sophia': { lat: 41.0086, lng: 28.9802, country: 'Turkey' },
            'blue mosque': { lat: 41.0054, lng: 28.9768, country: 'Turkey' },
            'grand bazaar': { lat: 41.0106, lng: 28.9681, country: 'Turkey' },
            'topkapi palace': { lat: 41.0115, lng: 28.9833, country: 'Turkey' },
            'burj khalifa': { lat: 25.1972, lng: 55.2744, country: 'UAE' },
            'palm jumeirah': { lat: 25.1124, lng: 55.1390, country: 'UAE' },
            'dubai mall': { lat: 25.1975, lng: 55.2797, country: 'UAE' },
            'marina bay sands': { lat: 1.2834, lng: 103.8607, country: 'Singapore' },
            'gardens by the bay': { lat: 1.2816, lng: 103.8636, country: 'Singapore' },
            'sentosa island': { lat: 1.2494, lng: 103.8303, country: 'Singapore' },
            'victoria peak': { lat: 22.2783, lng: 114.1747, country: 'Hong Kong' },
            'sydney opera house': { lat: -33.8568, lng: 151.2153, country: 'Australia' },
            'harbour bridge': { lat: -33.8523, lng: 151.2108, country: 'Australia' },
            'bondi beach': { lat: -33.8915, lng: 151.2767, country: 'Australia' },
            'great wall of china': { lat: 40.4319, lng: 116.5704, country: 'China' },
            'forbidden city': { lat: 39.9163, lng: 116.3972, country: 'China' },
            'temple of heaven': { lat: 39.8823, lng: 116.4066, country: 'China' },
            'mount fuji': { lat: 35.3606, lng: 138.7274, country: 'Japan' },
            'sensoji temple': { lat: 35.7148, lng: 139.7967, country: 'Japan' },
            'shibuya crossing': { lat: 35.6598, lng: 139.7006, country: 'Japan' },
            'fushimi inari shrine': { lat: 34.9671, lng: 135.7727, country: 'Japan' },
            'golden gate bridge': { lat: 37.8199, lng: -122.4783, country: 'USA' },
            'alcatraz island': { lat: 37.8267, lng: -122.4230, country: 'USA' },
            'hollywood sign': { lat: 34.1341, lng: -118.3215, country: 'USA' },
            'venice beach': { lat: 33.9850, lng: -118.4695, country: 'USA' },
            'machu picchu': { lat: -13.1631, lng: -72.5450, country: 'Peru' },
            'christ the redeemer': { lat: -22.9519, lng: -43.2105, country: 'Brazil' }
        };

        // Enhanced coordinate extraction with local database
        function getCoordinatesInstantly(locationName) {
            const searchKey = locationName.toLowerCase()
                .replace(/[^\w\s]/g, ' ')  // Replace special chars with spaces
                .replace(/\s+/g, ' ')      // Normalize spaces
                .trim();
            
            // Direct match
            if (COORDINATE_DATABASE[searchKey]) {
                return COORDINATE_DATABASE[searchKey];
            }
            
            // Fuzzy matching - check if any key contains the search term or vice versa
            for (const [key, coords] of Object.entries(COORDINATE_DATABASE)) {
                if (key.includes(searchKey) || searchKey.includes(key)) {
                    return coords;
                }
            }
            
            // Word-based matching for compound locations
            const searchWords = searchKey.split(' ');
            for (const [key, coords] of Object.entries(COORDINATE_DATABASE)) {
                const keyWords = key.split(' ');
                const matchingWords = searchWords.filter(word => 
                    keyWords.some(keyWord => keyWord.includes(word) || word.includes(keyWord))
                );
                if (matchingWords.length >= Math.min(searchWords.length, keyWords.length) / 2) {
                    return coords;
                }
            }
            
            return null;
        }

        // --- DOM Elements ---
        const $ = (selector) => document.querySelector(selector);
        const $$ = (selector) => document.querySelectorAll(selector);

        // --- Utility Functions ---
        const getOrdinalNumber = (num) => {
            const suffix = ['th', 'st', 'nd', 'rd'];
            const v = num % 100;
            return num + (suffix[(v - 20) % 10] || suffix[v] || suffix[0]);
        };
        const showModal = (id) => {
            const modal = $(`#${id}`);
            // Remove aria-hidden FIRST, before making visible
            modal.removeAttribute('aria-hidden');
            modal.setAttribute('aria-modal', 'true');
            modal.setAttribute('role', 'dialog');
            modal.style.display = 'flex';
            
            // Set focus to first focusable element for better accessibility
            setTimeout(() => {
                const focusableElements = modal.querySelectorAll(
                    'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
                );
                if (focusableElements.length > 0) {
                    focusableElements[0].focus();
                }
            }, 100);
        };
        const hideModal = (id) => {
            const modal = $(`#${id}`);
            
            // Blur any focused element inside modal BEFORE hiding
            const activeElement = document.activeElement;
            if (modal.contains(activeElement)) {
                activeElement.blur();
            }
            
            // Hide visually first
            modal.style.display = 'none';
            // Then set aria-hidden (no focused elements inside anymore)
            modal.setAttribute('aria-hidden', 'true');
            modal.removeAttribute('aria-modal');
            modal.removeAttribute('role');
            
            // Clean up map when itinerary detail modal is closed
            if (id === 'itinerary-detail-modal') {
                hideItineraryMap();
            }
        };

        // --- Core Application Logic ---

        function getFriendlyAuthError(error) {
            console.log('🔍 Processing error code:', error.code);
            switch (error.code) {
                case 'auth/wrong-password':
                case 'auth/invalid-credential': 
                    return "Incorrect email or password.";
                case 'auth/user-not-found': 
                    return "No account found with this email.";
                case 'auth/email-already-in-use': 
                    return "An account already exists with this email. Try logging in instead.";
                case 'auth/weak-password': 
                    return "Password should be at least 6 characters.";
                case 'auth/invalid-email': 
                    return "Please enter a valid email address.";
                case 'auth/operation-not-allowed':
                    return "Email/password sign-up is currently disabled. Please contact support.";
                case 'auth/too-many-requests':
                    return "Too many failed attempts. Please try again later.";
                case 'auth/network-request-failed':
                    return "Network error. Please check your connection and try again.";
                default: 
                    console.warn('Unhandled auth error:', error.code, error.message);
                    return `Error: ${error.message || 'An unexpected error occurred. Please try again.'}`;
            }
        }

        function updateAuthUI(user) {
            const authContainer = $('#auth-container');
            const mobileAuthContainer = $('#mobile-auth-container');
            
            const loggedOutHTML = `
                <button data-action="show-login-modal" class="text-gray-600 font-semibold hover:text-[#0D5C63]">Login</button>
                <button data-action="show-signup-modal" class="primary-btn font-semibold px-5 py-2 rounded-lg hover:bg-[#0A4C53] transition shadow">Sign Up</button>
            `;
            const mobileLoggedOutHTML = `
                <button data-action="show-login-modal" class="w-full text-left py-2 text-gray-600 font-semibold">Login</button>
                <button data-action="show-signup-modal" class="w-full mt-2 primary-btn font-semibold text-center px-5 py-2 rounded-lg hover:bg-[#0A4C53]">Sign Up</button>
            `;
            const loggedInHTML = `
                <button id="my-trips-btn" class="text-gray-600 font-semibold hover:text-[#0D5C63]">My Trips</button>
                <button id="logout-button" class="bg-gray-200 text-gray-800 font-semibold px-5 py-2 rounded-lg hover:bg-gray-300 transition">Logout</button>
            `;
            const mobileLoggedInHTML = `
                <button id="mobile-my-trips-btn" class="w-full text-left py-2 text-gray-600 font-semibold">My Trips</button>
                <button id="mobile-logout-button" class="w-full text-left py-2 text-gray-600 font-semibold">Logout</button>
            `;

            if (user) {
                authContainer.innerHTML = loggedInHTML;
                mobileAuthContainer.innerHTML = mobileLoggedInHTML;
            } else {
                authContainer.innerHTML = loggedOutHTML;
                mobileAuthContainer.innerHTML = mobileLoggedOutHTML;
            }
            lucide.createIcons();
            updatePricingSection(user);
        }

        async function checkUserSubscriptionStatus(userId) {
            const subscriptionsRef = collection(db, "customers", userId, "subscriptions");
            const q = query(subscriptionsRef, where("status", "in", ["trialing", "active"]));
            try {
                const querySnapshot = await getDocs(q);
                currentUserSubscription = querySnapshot.empty ? 'free' : 'pro';
                
                // After checking subscription, check usage limits
                await checkAndUpdateUsageLimits(userId);
            } catch (error) {
                console.error("Error checking subscription status:", error);
                currentUserSubscription = 'free';
            }
        }

        // Check usage limits and update UI accordingly
        async function checkAndUpdateUsageLimits(userId) {
            // ALWAYS check if user document exists (even for Pro users)
            try {
                const userDocRef = doc(db, "users", userId);
                const docSnap = await getDoc(userDocRef);
                
                // If user document doesn't exist, create it (for legacy users)
                if (!docSnap.exists()) {
                    console.log('📝 User document not found, creating initial document...');
                    await setDoc(userDocRef, {
                        email: auth.currentUser?.email || '',
                        createdAt: serverTimestamp(),
                        itineraryCount: 0,
                        subscriptionStatus: currentUserSubscription // 'free' or 'pro'
                    });
                    console.log('✅ User document created with status:', currentUserSubscription);
                }
                
                // Pro users have unlimited access
                if (currentUserSubscription === 'pro') {
                    console.log('✅ Pro user - unlimited itineraries');
                    enableGenerateButtons();
                    return;
                }
                
                // Free users: check itinerary count
                const userData = docSnap.exists() ? docSnap.data() : { itineraryCount: 0 };
                const itineraryCount = userData.itineraryCount || 0;
                
                console.log(`📊 Usage: ${itineraryCount}/3 itineraries generated`);
                
                if (itineraryCount >= 3) {
                    console.log('⚠️ Free user limit reached');
                    disableGenerateButtons('You\'ve reached your free limit of 3 itineraries. Upgrade to continue!');
                } else {
                    console.log(`✅ Free user has ${3 - itineraryCount} itineraries remaining`);
                    enableGenerateButtons();
                    updateRemainingCount(3 - itineraryCount);
                }
            } catch (error) {
                console.error("Error checking usage limits:", error);
                enableGenerateButtons(); // Fail open
            }
        }

        // Track if user has reached limit (global flag)
        let hasReachedLimit = false;

        // Disable generate buttons and show upgrade message
        function disableGenerateButtons(message) {
            hasReachedLimit = true;
            
            const generateBtn = $('#generate-prompt-btn');
            const sendBtn = $('#send-button');
            const chatInput = $('#chat-input');
            
            if (generateBtn) {
                // Keep enabled but mark as limited
                generateBtn.setAttribute('data-limit-reached', 'true');
                generateBtn.classList.add('opacity-75', 'hover:opacity-100');
                generateBtn.title = message;
                // Change button content to indicate upgrade needed
                generateBtn.innerHTML = `
                    <span class="btn-text flex items-center justify-center space-x-2">
                        <i data-lucide="lock" class="w-4 h-4"></i>
                        <span>Upgrade to Generate</span>
                    </span>
                `;
                lucide.createIcons();
            }
            
            if (sendBtn) {
                sendBtn.setAttribute('data-limit-reached', 'true');
                sendBtn.title = message;
            }
            
            if (chatInput) {
                chatInput.placeholder = 'Upgrade to continue generating itineraries';
                chatInput.setAttribute('data-limit-reached', 'true');
            }
            
            // Show upgrade banner in planner section
            showUpgradeBanner();
        }

        // Enable generate buttons
        function enableGenerateButtons() {
            hasReachedLimit = false;
            
            const generateBtn = $('#generate-prompt-btn');
            const sendBtn = $('#send-button');
            const chatInput = $('#chat-input');
            
            if (generateBtn) {
                generateBtn.removeAttribute('data-limit-reached');
                generateBtn.classList.remove('opacity-75', 'hover:opacity-100');
                generateBtn.title = '';
                // Restore original button content
                generateBtn.innerHTML = `
                    <span class="btn-text flex items-center justify-center space-x-2">
                        <i data-lucide="sparkles" class="w-4 h-4"></i>
                        <span>Generate & Plan</span>
                    </span>
                `;
                lucide.createIcons();
            }
            
            if (sendBtn) {
                sendBtn.removeAttribute('data-limit-reached');
                sendBtn.title = '';
            }
            
            if (chatInput) {
                chatInput.placeholder = 'Ask follow-up questions or request changes...';
                chatInput.removeAttribute('data-limit-reached');
            }
            
            // Hide upgrade banner
            hideUpgradeBanner();
        }

        // Update remaining count display
        function updateRemainingCount(remaining) {
            // Add a subtle indicator in the planner section
            let countIndicator = $('#usage-count-indicator');
            if (!countIndicator) {
                countIndicator = document.createElement('div');
                countIndicator.id = 'usage-count-indicator';
                countIndicator.className = 'text-sm text-gray-600 text-center py-2';
                const plannerSection = $('#planner');
                if (plannerSection) {
                    plannerSection.insertBefore(countIndicator, plannerSection.firstChild);
                }
            }
            
            if (remaining > 0 && currentUserSubscription === 'free') {
                countIndicator.innerHTML = `
                    <div class="bg-blue-50 border border-blue-200 rounded-lg px-4 py-2 inline-flex items-center gap-2">
                        <i data-lucide="sparkles" class="w-4 h-4 text-blue-600"></i>
                        <span class="text-blue-700 font-medium">${remaining} free itinerar${remaining === 1 ? 'y' : 'ies'} remaining</span>
                    </div>
                `;
                lucide.createIcons();
            } else if (remaining === 0 && currentUserSubscription === 'free') {
                countIndicator.innerHTML = '';
            } else {
                countIndicator.innerHTML = '';
            }
        }

        // Show upgrade banner
        function showUpgradeBanner() {
            let banner = $('#upgrade-banner');
            if (!banner) {
                banner = document.createElement('div');
                banner.id = 'upgrade-banner';
                banner.className = 'bg-gradient-to-r from-[#0D5C63] to-[#78CDD7] text-white p-6 rounded-lg shadow-xl mb-6';
                banner.innerHTML = `
                    <div class="flex items-center justify-between">
                        <div class="flex-1">
                            <h3 class="text-xl font-bold mb-2">🎉 Ready for More Adventures?</h3>
                            <p class="text-blue-50 mb-3">You've used all 3 free itineraries. Upgrade to Globetrotter for unlimited trip planning!</p>
                            <ul class="text-sm text-blue-50 space-y-1 mb-4">
                                <li>✓ Unlimited itinerary generation</li>
                                <li>✓ Save unlimited trips</li>
                                <li>✓ Priority support</li>
                            </ul>
                            <button onclick="document.getElementById('upgrade-button').click()" 
                                    class="bg-white text-[#0D5C63] px-6 py-2 rounded-lg font-semibold hover:bg-blue-50 transition-colors">
                                Upgrade Now
                            </button>
                        </div>
                        <div class="ml-6 hidden md:block">
                            <i data-lucide="rocket" class="w-24 h-24 text-white opacity-20"></i>
                        </div>
                    </div>
                `;
                
                const plannerSection = $('#planner');
                if (plannerSection && plannerSection.firstChild) {
                    plannerSection.insertBefore(banner, plannerSection.firstChild);
                }
                lucide.createIcons();
            }
        }

        // Hide upgrade banner
        function hideUpgradeBanner() {
            const banner = $('#upgrade-banner');
            if (banner) {
                banner.remove();
            }
        }

        function updatePricingSection(user) {
            const explorerButton = document.getElementById('explorer-plan-button');
            const globetrotterButton = document.getElementById('upgrade-button');
            if (!explorerButton || !globetrotterButton) {
                // If elements aren't ready, retry in a moment
                setTimeout(() => updatePricingSection(user), 100);
                return;
            }

            if (!user) {
                // When not logged in, both buttons should allow sign up
                explorerButton.textContent = 'Sign Up for Free';
                explorerButton.disabled = false;
                explorerButton.setAttribute('data-action', 'show-signup-modal');
                explorerButton.classList.remove('bg-gray-200', 'text-gray-800', 'cursor-default');
                explorerButton.classList.add('bg-blue-600', 'text-white', 'hover:bg-blue-700', 'transition-colors', 'cursor-pointer', 'shadow-lg');
                
                // Force visibility with inline styles to override any CSS conflicts
                explorerButton.style.cssText = `
                    background-color: #2563eb !important;
                    color: #ffffff !important;
                    border: 3px solid #1d4ed8 !important;
                    font-weight: bold !important;
                    display: block !important;
                    visibility: visible !important;
                    opacity: 1 !important;
                    width: 100% !important;
                    margin-top: auto !important;
                    padding: 12px 16px !important;
                    border-radius: 8px !important;
                    cursor: pointer !important;
                    box-shadow: 0 4px 12px rgba(37, 99, 235, 0.4) !important;
                    transform: scale(1) !important;
                    z-index: 10 !important;
                    position: relative !important;
                `;
                
                globetrotterButton.textContent = 'Sign Up';
                globetrotterButton.disabled = false;
            } else {
                // Remove data-action when logged in
                explorerButton.removeAttribute('data-action');
                
                if (currentUserSubscription === 'pro') {
                    explorerButton.textContent = 'Explorer';
                    explorerButton.disabled = true;
                    explorerButton.classList.remove('bg-blue-600', 'text-white', 'hover:bg-blue-700', 'cursor-pointer');
                    explorerButton.classList.add('bg-gray-200', 'text-gray-800', 'cursor-default');
                    
                    globetrotterButton.textContent = 'Current Plan';
                    globetrotterButton.disabled = true;
                } else {
                    explorerButton.textContent = 'Current Plan';
                    explorerButton.disabled = true;
                    explorerButton.classList.remove('bg-blue-600', 'text-white', 'hover:bg-blue-700', 'cursor-pointer');
                    explorerButton.classList.add('bg-gray-200', 'text-gray-800', 'cursor-default');
                    
                    globetrotterButton.textContent = 'Upgrade Now';
                    globetrotterButton.disabled = false;
                }
            }
        }

        function showPlanner() {
            $$('main > section:not(#my-trips-section)').forEach(s => s.classList.remove('hidden'));
            $('#my-trips-section').classList.add('hidden');
            
            // Check what we have in sessionStorage
            const mapVisibleState = sessionStorage.getItem('mapVisible');
            
            // Get elements
            const mapSectionWrapper = $('#map-section-wrapper');
            const actionButtons = $('#action-buttons');
            const chatContainer = $('#chat-container');
            
            // Only proceed if a map was created at some point (check sessionStorage, not DOM)
            if (!mapVisibleState || mapVisibleState === 'null') {
                return;
            }
            
            // Ensure action buttons are visible if they exist
            if (actionButtons && actionButtons.classList.contains('hidden')) {
                actionButtons.classList.remove('hidden');
                actionButtons.style.cssText = 'display: flex !important;';
            }
            
            if (mapVisibleState === 'true') {
                // Map was visible - restore it
                
                // Check if map DOM was cleared during navigation
                const mapDOMExists = mapSectionWrapper && mapSectionWrapper.children.length > 0 && mapSectionWrapper.innerHTML.trim();
                
                if (!mapDOMExists) {
                    console.warn('⚠️ Map DOM was cleared during navigation. Hiding map wrapper.');
                    // Map DOM is gone - hide the wrapper and change state to false
                    if (mapSectionWrapper) {
                        mapSectionWrapper.classList.add('hidden');
                        mapSectionWrapper.style.display = 'none';
                    }
                    
                    // Expand chat to full width
                    if (chatContainer && window.innerWidth >= 1024) {
                        chatContainer.style.width = '100%';
                    }
                    
                    // Update sessionStorage to reflect reality
                    sessionStorage.setItem('mapVisible', 'false');
                    
                    // Add Show Map button so user can regenerate it
                    if (actionButtons && !$('#show-map-button')) {
                        actionButtons.classList.remove('justify-end');
                        actionButtons.classList.add('justify-between');
                        
                        const showMapBtn = document.createElement('button');
                        showMapBtn.id = 'show-map-button';
                        showMapBtn.className = 'inline-flex items-center gap-2 bg-green-600 text-white px-3 py-2 rounded-lg hover:bg-green-700 transition-colors';
                        showMapBtn.innerHTML = '<i data-lucide="map" class="w-4 h-4"></i><span class="text-white font-medium">Show Map</span>';
                        showMapBtn.addEventListener('click', async () => {
                            // Re-initialize the map when clicked
                            if (lastItineraryJson) {
                                initializeProgressiveMap();
                                // Wait for map to initialize, then restore cities from cache
                                setTimeout(async () => {
                                    const cities = await extractCitiesFromAI(JSON.stringify(lastItineraryJson));
                                    if (cities && cities.length > 0) {
                                        await createMapFromCities(cities, JSON.stringify(lastItineraryJson));
                                    }
                                }, 200);
                            }
                        });
                        actionButtons.insertBefore(showMapBtn, actionButtons.firstChild);
                        if (typeof lucide !== 'undefined') {
                            setTimeout(() => lucide.createIcons(), 50);
                        }
                    }
                } else {
                    // Map DOM exists - restore visibility
                    if (mapSectionWrapper) {
                        mapSectionWrapper.classList.remove('hidden');
                        mapSectionWrapper.style.display = 'flex';
                    }
                    
                    // Restore chat to 60% width
                    if (chatContainer && window.innerWidth >= 1024) {
                        chatContainer.style.width = '';
                    }
                    
                    // Ensure parent is in row layout
                    if (mapSectionWrapper) {
                        const flexContainer = mapSectionWrapper.parentElement;
                        if (flexContainer && window.innerWidth >= 1024) {
                            flexContainer.style.flexDirection = 'row';
                        }
                    }
                    
                    // Refresh map if Leaflet object exists
                    if (window.progressiveMap) {
                        setTimeout(() => {
                            window.progressiveMap.invalidateSize();
                        }, 100);
                    }
                    
                    // Remove Show Map button if it exists
                    const showMapBtn = $('#show-map-button');
                    if (showMapBtn) {
                        showMapBtn.remove();
                    }
                    if (actionButtons) {
                        actionButtons.classList.remove('justify-between');
                        actionButtons.classList.add('justify-end');
                    }
                }
            } else if (mapVisibleState === 'false') {
                // Map was hidden - restore Show Map button
                
                // Hide map
                if (mapSectionWrapper) {
                    mapSectionWrapper.classList.add('hidden');
                    mapSectionWrapper.style.display = 'none';
                }
                
                // Expand chat to full width
                if (chatContainer && window.innerWidth >= 1024) {
                    chatContainer.style.width = '100%';
                }
                
                // Add Show Map button if it doesn't exist
                if (actionButtons && !$('#show-map-button')) {
                    actionButtons.classList.remove('justify-end');
                    actionButtons.classList.add('justify-between');
                    
                    const showMapBtn = document.createElement('button');
                    showMapBtn.id = 'show-map-button';
                    showMapBtn.className = 'inline-flex items-center gap-2 bg-green-600 text-white px-3 py-2 rounded-lg hover:bg-green-700 transition-colors';
                    showMapBtn.innerHTML = '<i data-lucide="map" class="w-4 h-4"></i><span class="text-white font-medium">Show Map</span>';
                    showMapBtn.addEventListener('click', showProgressiveMap);
                    actionButtons.insertBefore(showMapBtn, actionButtons.firstChild);
                    if (typeof lucide !== 'undefined') {
                        setTimeout(() => lucide.createIcons(), 50);
                    }
                } else if (!actionButtons) {
                    console.error('❌ Action buttons not found!');
                } else {
                }
            }
        }

        function showMyTrips() {
            $$('main > section:not(#my-trips-section)').forEach(s => s.classList.add('hidden'));
            $('#my-trips-section').classList.remove('hidden');
            loadSavedItineraries();
        }

        function addMessage(sender, content) {
            const chatWindow = $('#chat-window');
            const messageDiv = document.createElement('div');
            const bubbleClass = sender === 'user' ? 'chat-bubble-user' : 'chat-bubble-ai';
            const icon = sender === 'user' 
                ? `<div class="bg-gray-300 p-2 rounded-full"><i data-lucide="user" class="w-6 h-6 text-gray-700"></i></div>`
                : `<div class="bg-[#E0E7E9] p-2 rounded-full"><i data-lucide="bot" class="w-6 h-6 text-[#0D5C63]"></i></div>`;
            
            messageDiv.className = `flex items-start gap-3 ${sender === 'user' ? 'justify-end' : ''}`;
            
            // Create bubble element
            const bubble = document.createElement('div');
            bubble.className = `${bubbleClass} p-4 rounded-lg ${sender === 'user' ? 'rounded-br-none' : 'rounded-tl-none'} max-w-[85%]`;
            
            if (sender === 'ai') {
                const nameLabel = document.createElement('p');
                nameLabel.className = 'font-semibold mb-1';
                nameLabel.textContent = 'KimatAI';
                bubble.appendChild(nameLabel);
            }
            
            // Create content div and set innerHTML to allow HTML content
            const contentDiv = document.createElement('div');
            contentDiv.innerHTML = content;
            bubble.appendChild(contentDiv);
            
            // Create icon element
            const iconDiv = document.createElement('div');
            iconDiv.innerHTML = icon;
            
            // Append in correct order
            if (sender === 'user') {
                messageDiv.appendChild(bubble);
                messageDiv.appendChild(iconDiv);
            } else {
                messageDiv.appendChild(iconDiv);
                messageDiv.appendChild(bubble);
            }
            
            chatWindow.appendChild(messageDiv);
            lucide.createIcons();
            chatWindow.scrollTop = chatWindow.scrollHeight;
        }

        function showTypingIndicator(isRefinement = false) {
            if ($('#typing-indicator')) return;
            
            // Dynamic message based on context
            const messages = isRefinement ? [
                'Refining your itinerary...',
                'Updating your travel plan...',
                'Making adjustments...',
                'Tailoring your experience...'
            ] : [
                'Crafting your personalized itinerary...',
                'Planning your perfect trip...',
                'Designing your adventure...',
                'Creating your journey...'
            ];
            
            const randomMessage = messages[Math.floor(Math.random() * messages.length)];
            
            const indicatorHTML = `
                <div id="typing-indicator" class="flex items-start gap-3">
                    <div class="bg-[#E0E7E9] p-2 rounded-full"><i data-lucide="bot" class="w-6 h-6 text-[#0D5C63]"></i></div>
                    <div class="chat-bubble-ai p-4 rounded-lg rounded-tl-none">
                        <div class="flex items-center gap-3 text-gray-600">
                            <div class="typing-indicator"><span></span><span></span><span></span></div>
                            <span class="text-sm">${randomMessage}</span>
                        </div>
                        <div class="mt-2 w-full bg-gray-200 rounded-full h-1">
                            <div class="bg-[#0D5C63] h-1 rounded-full animate-pulse" style="width: 60%"></div>
                        </div>
                    </div>
                </div>`;
            $('#chat-window').insertAdjacentHTML('beforeend', indicatorHTML);
            lucide.createIcons();
            $('#chat-window').scrollTop = $('#chat-window').scrollHeight;
        }

        const removeTypingIndicator = () => $('#typing-indicator')?.remove();

        function parseJSONSafe(input) {
            if (typeof input === 'object' && input !== null) return input; // Already parsed object
            if (typeof input !== 'string') return null;
            let str = input.trim();
            
            // Handle markdown code blocks (multiple patterns)
            let jsonMatch = str.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
            if (jsonMatch && jsonMatch[1]) {
                str = jsonMatch[1].trim();
            } else if (str.startsWith('```json')) {
                str = str.replace(/^```json\s*/, '').replace(/\s*```$/, '').trim();
            } else if (str.startsWith('```')) {
                str = str.replace(/^```\s*/, '').replace(/\s*```$/, '').trim();
            } else {
                // Look for JSON pattern more aggressively
                const patterns = [
                    // Standard JSON object
                    /(\{[\s\S]*\})/,
                    // JSON with possible text before/after
                    /.*?(\{[\s\S]*?\}).*?/,
                    // Multiple potential JSON objects - take the largest
                    /(\{(?:[^{}]|{[^{}]*})*\})/g
                ];
                
                for (const pattern of patterns) {
                    const matches = str.match(pattern);
                    if (matches) {
                        if (Array.isArray(matches) && matches.length > 1) {
                            // Multiple matches, find the longest one
                            str = matches.reduce((longest, current) => 
                                current.length > longest.length ? current : longest
                            );
                        } else if (matches[1]) {
                            str = matches[1];
                        } else if (matches[0]) {
                            str = matches[0];
                        }
                        break;
                    }
                }
                
                // If still no valid JSON structure found, try braces method
                if (!str.includes('{') || !str.includes('}')) {
                    const firstBrace = input.indexOf('{');
                    const lastBrace = input.lastIndexOf('}');
                    if (firstBrace !== -1 && lastBrace > firstBrace) {
                        str = input.substring(firstBrace, lastBrace + 1);
                    }
                }
            }
            
            try {
                // Clean up common issues
                const cleaned = str
                    .replace(/,\s*([}\]])/g, '$1') // Remove trailing commas
                    .replace(/([{,]\s*)(\w+):/g, '$1"$2":') // Quote unquoted keys
                    .replace(/:\s*([^"\d\[\{][^,}\]]*)/g, (match, value) => { // Quote unquoted string values
                        const trimmed = value.trim();
                        if (trimmed === 'true' || trimmed === 'false' || trimmed === 'null' || !isNaN(trimmed)) {
                            return match; // Don't quote boolean/null/number values
                        }
                        return `: "${trimmed}"`;
                    });
                
                return JSON.parse(cleaned);
            } catch (e) {
                console.debug('Advanced JSON parse failed:', e);
                console.debug('Cleaned string:', str.substring(0, 500) + '...');
                
                // Last resort: try original string
                try {
                    return JSON.parse(str);
                } catch (e2) {
                    console.debug('Original string parse also failed:', e2);
                    return null;
                }
            }
        }

        function normalizeItinerary(obj) {
            if (!obj || typeof obj !== 'object') return null;
            
            // Helper function to ensure all activities have times
            function ensureActivityTimes(days) {
                const standardTimes = ['9:00 AM', '11:00 AM', '1:00 PM', '3:00 PM', '5:00 PM', '7:00 PM', '9:00 PM'];
                
                days.forEach(day => {
                    if (day.activities && Array.isArray(day.activities)) {
                        let timeIndex = 0;
                        day.activities.forEach((activity, index) => {
                            // If activity has no time or empty time, assign a default time
                            if (!activity.time || activity.time.trim() === '') {
                                // Use last known time + 2 hours, or default schedule
                                if (index > 0 && day.activities[index - 1].time) {
                                    // Try to increment from previous time
                                    activity.time = calculateNextTime(day.activities[index - 1].time);
                                } else {
                                    // Use standard time slots
                                    activity.time = standardTimes[Math.min(index, standardTimes.length - 1)];
                                }
                                console.warn(`⚠️ Missing time for activity "${activity.description?.substring(0, 50)}...", assigned: ${activity.time}`);
                            }
                        });
                    }
                });
                return days;
            }
            
            // Helper to calculate next time (adds ~2 hours)
            function calculateNextTime(timeStr) {
                const match = timeStr.match(/(\d+):(\d+)\s*(AM|PM)/i);
                if (!match) return '2:00 PM';
                
                let hours = parseInt(match[1]);
                const minutes = match[2];
                const meridiem = match[3].toUpperCase();
                
                // Add 2 hours
                hours += 2;
                
                // Handle overflow
                let newMeridiem = meridiem;
                if (hours > 12) {
                    hours -= 12;
                    newMeridiem = meridiem === 'AM' ? 'PM' : 'AM';
                }
                if (hours === 12) {
                    newMeridiem = meridiem === 'AM' ? 'PM' : 'AM';
                }
                
                return `${hours}:${minutes} ${newMeridiem}`;
            }
            
            // Process different itinerary formats
            if (Array.isArray(obj.days)) {
                obj.days = ensureActivityTimes(obj.days);
                return { title: obj.title || '', days: obj.days, bookingSuggestions: obj.bookingSuggestions || '' };
            }
            
            for (const key of ['itinerary','plan','schedule']) {
                if (obj[key] && Array.isArray(obj[key].days)) {
                    const inner = obj[key];
                    inner.days = ensureActivityTimes(inner.days);
                    return { title: inner.title || obj.title || '', days: inner.days, bookingSuggestions: inner.bookingSuggestions || obj.bookingSuggestions || '' };
                }
            }
            
            if (obj.Days && Array.isArray(obj.Days)) {
                obj.Days = ensureActivityTimes(obj.Days);
                return { title: obj.title || '', days: obj.Days, bookingSuggestions: obj.bookingSuggestions || '' };
            }
            
            const dayKeyRegex = /^day\s*\d+/i;
            const dayKeys = Object.keys(obj).filter(k => dayKeyRegex.test(k));
            if (dayKeys.length) {
                const days = dayKeys
                    .sort((a,b) => parseInt(a.match(/\d+/)?.[0]||'0') - parseInt(b.match(/\d+/)?.[0]||'0'))
                    .map(k => {
                        const v = obj[k];
                        const activities = Array.isArray(v) ? v.map(item => (typeof item === 'string') ? { time: '', description: item } : { time: item.time || '', description: item.description || item.activity || '' }) : [];
                        return { title: k.replace(/^./, c => c.toUpperCase()), activities };
                    });
                const normalizedDays = ensureActivityTimes(days);
                return { title: obj.title || '', days: normalizedDays, bookingSuggestions: obj.bookingSuggestions || '' };
            }
            return null;
        }

        // Global venue tag processing function (used by both itinerary rendering and chat messages)
        const venueTagCache = new Map();
        function processVenueTags(text) {
            if (!text || typeof text !== 'string') return '';
            
            // Check cache first
            if (venueTagCache.has(text)) {
                return venueTagCache.get(text);
            }
            
            // Debug logging
            const hasVenueTags = text.includes('[VENUE]');
            if (hasVenueTags) {
            }
            
            // Early return if no processing needed
            if (!text.includes('[VENUE]') && !text.includes('[LINK]') && !text.includes('**') && !/[\u{1F300}-\u{1F9FF}]/u.test(text)) {
                const trimmed = text.trim();
                venueTagCache.set(text, trimmed);
                return trimmed;
            }
            
            let processed = text;
            
            // Process booking link tags [LINK]text|url[/LINK]
            processed = processed.replace(
                /\[LINK\](.*?)\|(.*?)\[\/LINK\]/g, 
                '<a href="$2" target="_blank" class="booking-link inline-flex items-center gap-1 text-blue-600 hover:text-blue-800 font-medium underline decoration-2 underline-offset-2 hover:decoration-blue-800 transition-all duration-200">$1 <i data-lucide="external-link" class="w-4 h-4"></i></a>'
            );
            
            // Process venue tags with links (with or without bold markers)
            // First try with bold markers: [VENUE]**text**|url[/VENUE]
            processed = processed.replace(
                /\[VENUE\]\*\*(.*?)\*\*\|(.*?)\[\/VENUE\]/g, 
                '<a href="$2" target="_blank" class="venue-link font-semibold text-blue-700 hover:text-blue-900 underline decoration-dotted underline-offset-2 hover:decoration-solid transition-all duration-200" title="Open in Google Maps">$1</a>'
            );
            
            // Then handle without bold markers: [VENUE]text|url[/VENUE]
            processed = processed.replace(
                /\[VENUE\](.*?)\|(.*?)\[\/VENUE\]/g, 
                '<a href="$2" target="_blank" class="venue-link font-semibold text-blue-700 hover:text-blue-900 underline decoration-dotted underline-offset-2 hover:decoration-solid transition-all duration-200" title="Open in Google Maps">$1</a>'
            );
            
            // Handle remaining venue tags without links (fallback)
            processed = processed.replace(
                /\[VENUE\](.*?)\[\/VENUE\]/g, 
                '<span class="venue-fallback font-semibold text-blue-700 underline decoration-dotted">$1</span>'
            );
            
            // Handle bold text
            processed = processed.replace(/\*\*(.*?)\*\*/g, '<strong class="font-semibold text-gray-800">$1</strong>');
            
            // Handle emoji spacing
            processed = processed.replace(/([\u{1F300}-\u{1F9FF}])\s*/gu, '$1 ');
            
            // Clean up extra spaces
            processed = processed.replace(/\s+/g, ' ').trim();
            
            if (hasVenueTags) {
            }
            
            // Cache the result
            venueTagCache.set(text, processed);
            return processed;
        }

        function renderItineraryHTML(itinerary) {
            if (!itinerary || !itinerary.days) return '<p>Could not render itinerary.</p>';
            
            // Pre-process all text content using the global processVenueTags function
            const processedDays = itinerary.days.map(day => {
                const processedActivities = day.activities.map(activity => ({
                    ...activity,
                    processedDescription: processVenueTags(activity.description)
                }));
                
                return {
                    ...day,
                    activities: processedActivities,
                    processedTip: day.insiderTip ? processVenueTags(day.insiderTip) : (day.dailyTip ? processVenueTags(day.dailyTip) : null)
                };
            });
            
            // Build HTML using the pre-processed data
            const daysHtml = processedDays.map(day => `
                <div class="day-block mb-8 bg-white rounded-2xl shadow-lg border border-gray-100 overflow-hidden">
                    <div class="day-header bg-gradient-to-r from-blue-50 to-indigo-50 px-6 py-4 border-b border-gray-100">
                        <h5 class="day-title text-xl font-bold text-gray-800 mb-0">${DOMPurify.sanitize(day.title)}</h5>
                    </div>
                    <div class="day-content p-6">
                        <div class="time-list space-y-4">
                            ${day.activities.map(activity => `
                                <div class="activity-item group">
                                    <div class="flex items-start gap-4">
                                        <div class="time-badge-container flex-shrink-0">
                                            <span class="badge-time inline-block bg-blue-600 text-white px-4 py-2 rounded-full text-sm font-semibold shadow-sm">${DOMPurify.sanitize(activity.time || 'TBD')}</span>
                                        </div>
                                        <div class="activity-content flex-grow min-w-0">
                                            <div class="activity-description text-gray-700 text-base leading-7 font-normal">
                                                <p class="mb-0 text-justify hyphens-auto break-words">${activity.processedDescription}</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        ${day.processedTip ? `<div class="insider-tip mt-6 p-5 bg-gradient-to-r from-purple-50 to-indigo-50 border-l-4 border-purple-500 rounded-r-xl shadow-sm">
                            <div class="flex items-start gap-3">
                                <i data-lucide="zap" class="w-5 h-5 text-purple-600 mt-1 flex-shrink-0"></i>
                                <div class="tip-content flex-grow">
                                    <h6 class="text-purple-900 font-bold text-sm mb-2">💡 Local Insider Tip</h6>
                                    <div class="text-purple-800 text-sm leading-6 text-justify hyphens-auto">${day.processedTip}</div>
                                </div>
                            </div>
                        </div>` : ''}
                    </div>
                </div>
            `).join('');
            
            let result = `<div class="itinerary">${daysHtml}</div>`;
            
            // Add booking suggestions if available
            if (itinerary.bookingSuggestions) {
                let processedBookings = processVenueTags(itinerary.bookingSuggestions)
                    .replace(/### (.*?)\\n/g, '<h4 class="font-bold text-lg text-gray-800 mt-6 mb-3 first:mt-0 flex items-center gap-2"><i data-lucide="$1" class="w-5 h-5 text-blue-600"></i>$1</h4>')
                    .replace(/\\n\\n/g, '</div><div class="mb-4">')
                    .replace(/\\n/g, '<br>');
                
                // Replace icon names with actual icons
                processedBookings = processedBookings
                    .replace(/data-lucide="Flights"/g, 'data-lucide="plane"')
                    .replace(/data-lucide="Hotels"/g, 'data-lucide="hotel"')
                    .replace(/data-lucide="Activities"/g, 'data-lucide="map-pin"');
                
                result += `<div class="booking-suggestions mt-8 p-6 bg-gradient-to-br from-blue-50 to-indigo-50 rounded-xl border border-blue-200 shadow-sm">
                    <div class="flex items-center gap-2 mb-4">
                        <i data-lucide="bookmark" class="w-5 h-5 text-blue-600"></i>
                        <h3 class="text-xl font-bold text-gray-800">Quick Booking Links</h3>
                    </div>
                    <div class="space-y-2">
                        ${processedBookings}
                    </div>
                </div>`;
            }
            
            return result;
        }

        async function getAIResponse(prompt) {
            try {
                const response = await fetch(`${BACKEND_URL}/api/gemini`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ userInput: prompt })
                });
                
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('❌ Regular response error:', errorText);
                    throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
                }
                const data = await response.json();
                // The backend returns { response: "JSON string", metadata: {...} }
                // Parse the JSON string from the response field
                if (data.response) {
                    try {
                        // First try to parse directly
                        return JSON.parse(data.response);
                    } catch (parseError) {
                        console.error("Direct JSON parse failed, trying advanced parsing:", parseError);
                        
                        // Try advanced JSON parsing
                        const parsed = parseJSONSafe(data.response);
                        if (parsed) {
                            return parsed;
                        } else {
                            console.error("All parsing attempts failed");
                            return null;
                        }
                    }
                }
                console.error("No response field in data:", data);
                return null; 
            } catch (error) {
                console.error("Error fetching AI response:", error);
                return null;
            }
        }

        async function getAIResponseWithProgressive(prompt) {
            
            try {
                const response = await fetch(`${BACKEND_URL}/api/gemini`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ userInput: prompt, stream: true })
                });
                
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
                }

                // Check if response is actually streaming
                const contentType = response.headers.get('content-type');
                
                if (contentType && contentType.includes('text/plain') && response.body && response.body.getReader) {
                    // Handle streaming response
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let accumulatedText = '';
                    
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        
                        const chunk = decoder.decode(value, { stream: true });
                        accumulatedText += chunk;
                        
                        // No real-time processing - keep streaming fast and simple
                    }
                    
                    // Parse the final accumulated response
                    try {
                        return JSON.parse(accumulatedText);
                    } catch (parseError) {
                        const parsed = parseJSONSafe(accumulatedText);
                        if (parsed) {
                            return parsed;
                        }
                        throw new Error('Failed to parse streaming response');
                    }
                } else {
                    // Handle regular JSON response as fallback
                    const data = await response.json();
                    
                    
                    if (data.response) {
                        // Process the entire response for locations with simulated streaming
                        await simulateProgressiveMapFromFullText(data.response);
                        
                        try {
                            const parsed = JSON.parse(data.response);
                            return parsed;
                        } catch (parseError) {
                            const parsed = parseJSONSafe(data.response);
                            if (parsed) {
                                return parsed;
                            }
                            console.error('❌ All parsing attempts failed');
                            return null;
                        }
                    }
                    console.error('❌ No response field in data');
                    return null;
                }
            } catch (error) {
                console.error("Error fetching AI response with progressive:", error);
                // Instead of returning null, throw the error so it can be caught by the fallback
                throw new Error(`Progressive AI request failed: ${error.message}`);
            }
        }

        function buildGuidedPrompt() {
            const isMultiCity = $('#multi-city-toggle')?.checked;
            let prompt;

            if (isMultiCity) {
                // Double-check subscription status for multi-city trips
                if (currentUserSubscription === 'free') {
                    showModal('upgrade-modal');
                    showTemporaryMessage('Multi-city trips require a premium subscription', 'info');
                    return null;
                }
                
                const cityItems = $$('#multi-destination-container .multi-city-item');
                const cityData = Array.from(cityItems).map(item => ({
                    city: item.querySelector('.city-input')?.value.trim(),
                    days: item.querySelector('.days-input')?.value.trim()
                })).filter(item => item.city && item.days);

                if (cityData.length === 0) {
                    showTemporaryMessage("Please specify at least one city and its duration for your multi-city trip.", 'error');
                    return null;
                }
                prompt = `Plan a multi-city trip: ${cityData.map(c => `${c.city} for ${c.days} days`).join(', then ')}`;
            } else {
                const destination = $('#destination')?.value.trim();
                const duration = $('#duration')?.value.trim();
                if (!destination || !duration) {
                    showTemporaryMessage("Please specify a destination and duration.", 'error');
                    return null;
                }
                prompt = `Plan a trip to ${destination} for ${duration}`;
            }

            const travelers = isMultiCity ? $('#multi-travelers')?.value : $('#travelers')?.value;
            const pace = isMultiCity ? $('#multi-pace')?.value : $('#pace')?.value;
            const budget = $('#budget')?.value;
            const transport = $('#transport')?.value;
            const selectedInterests = Array.from($$('.interest-btn[data-selected="true"]')).map(btn => btn.textContent.trim());

            if (travelers) prompt += ` for a ${travelers.toLowerCase()}`;
            if (budget) prompt += ` on a ${budget.toLowerCase()} budget`;
            if (pace) prompt += ` with a ${pace.toLowerCase()} pace`;
            if (transport) prompt += `, primarily using ${transport.toLowerCase()}`;
            if (selectedInterests.length > 0) prompt += `. Key interests include: ${selectedInterests.join(', ')}.`;
            
            return prompt;
        }

        // Extract major cities from AI for cleaner mapping
        async function extractCitiesFromAI(itineraryText) {
            try {
                
                const cityExtractionPrompt = `EXTRACT ALL CITIES FROM THIS ITINERARY.

RULES:
1. Extract EVERY city/town mentioned (max 12)
2. Each city needs a 1-sentence description (max 100 chars)
3. Return VALID JSON only - no extra text

FORMAT:
[
  {"city": "Athens", "description": "Ancient capital with iconic Acropolis."},
  {"city": "Rome", "description": "Eternal city with Colosseum and Vatican."}
]

ITINERARY:
${itineraryText.substring(0, 8000)}`;

                const backendUrl = `${BACKEND_URL}/api/gemini`;
                console.log('🌐 Backend URL:', backendUrl);

                const response = await fetch(backendUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ userInput: cityExtractionPrompt })
                });
                
                
                if (response.ok) {
                    const data = await response.json();
                    const cityResponse = data.response;
                    
                    // Try to parse the JSON array
                    try {
                        const citiesData = JSON.parse(cityResponse);
                        if (Array.isArray(citiesData) && citiesData.length > 0) {
                            // Check if we have objects with city and description
                            if (citiesData[0] && typeof citiesData[0] === 'object' && citiesData[0].city) {
                                return citiesData.slice(0, 12); // Limit to 12 cities for multi-country trips
                            } else if (typeof citiesData[0] === 'string') {
                                // Fallback: old format with just city names
                                return citiesData.slice(0, 12).map(city => ({ city: city, description: null }));
                            }
                        } else {
                            console.warn('⚠️ AI response is not a valid array:', citiesData);
                        }
                    } catch (parseError) {
                        console.warn('⚠️ Could not parse AI city response as JSON:', cityResponse);
                        console.warn('⚠️ Parse error:', parseError);
                        
                        // Try to extract cities from non-JSON response
                        const cityMatches = cityResponse.match(/["']([^"']+)["']/g);
                        if (cityMatches) {
                            const extractedCities = cityMatches.map(match => match.replace(/['"]/g, ''));
                            return extractedCities.slice(0, 12).map(city => ({ city: city, description: null }));
                        }
                        
                        return [];
                    }
                } else {
                    console.error('❌ Backend request failed:', response.status, response.statusText);
                    return extractCitiesManually(itineraryText);
                }
            } catch (error) {
                console.error('❌ Error extracting cities from AI:', error);
                return extractCitiesManually(itineraryText);
            }
        }
        
        // Fallback: Extract cities manually from itinerary JSON
        function extractCitiesManually(itineraryText) {
            try {
                const itinerary = JSON.parse(itineraryText);
                const cities = new Set();
                const knownCities = [
                    'athens', 'rome', 'florence', 'venice', 'milan', 'naples', 'santorini', 
                    'mykonos', 'crete', 'rhodes', 'paris', 'london', 'barcelona', 'madrid',
                    'delphi', 'meteora', 'kalabaka', 'thessaloniki', 'corfu', 'zakynthos',
                    'siena', 'pisa', 'bologna', 'verona', 'positano', 'amalfi', 'sorrento',
                    'matera', 'alberobello', 'pompeii', 'capri', 'turin', 'genoa', 'palermo'
                ];
                
                // Search through all days and activities
                if (itinerary.days) {
                    for (const day of itinerary.days) {
                        // Check day title
                        const dayTitleLower = (day.title || '').toLowerCase();
                        for (const city of knownCities) {
                            if (dayTitleLower.includes(city)) {
                                // Capitalize city name
                                cities.add(city.charAt(0).toUpperCase() + city.slice(1));
                            }
                        }
                        
                        // Check activities
                        if (day.activities) {
                            for (const activity of day.activities) {
                                const descLower = (activity.description || '').toLowerCase();
                                for (const city of knownCities) {
                                    if (descLower.includes(city)) {
                                        cities.add(city.charAt(0).toUpperCase() + city.slice(1));
                                    }
                                }
                            }
                        }
                    }
                }
                
                const extractedCities = Array.from(cities).slice(0, 12);
                return extractedCities.map(city => ({ city, description: null }));
            } catch (error) {
                console.error('❌ Failed to manually extract cities:', error);
                return [];
            }
        }

        // Destination Suggestion Function
        async function handleDestinationSuggestion() {
            try {
                // Get form values
                const form = $('#destination-suggest-form');
                const travelStyle = form.querySelector('#travel-style').value;
                const budgetLevel = form.querySelector('#budget-level').value;
                const climatePref = form.querySelector('#climate-pref').value;
                const tripDuration = form.querySelector('#trip-duration').value;
                const originLocation = form.querySelector('#origin-location').value.trim();
                const travelDates = form.querySelector('#travel-dates').value.trim();
                const excludeCountries = form.querySelector('#exclude-countries').value.trim();
                const additionalInterests = form.querySelector('#additional-interests').value.trim();
                
                // Show loading, hide form
                $('#destination-suggest-form').classList.add('hidden');
                $('#destination-loading').classList.remove('hidden');
                $('#destination-results').classList.add('hidden');
                
                // Build preferences string
                const preferences = [];
                if (travelStyle) preferences.push(`travel style: ${travelStyle}`);
                if (budgetLevel) preferences.push(`budget: ${budgetLevel}`);
                if (climatePref) preferences.push(`climate: ${climatePref}`);
                if (tripDuration) preferences.push(`duration: ${tripDuration}`);
                if (originLocation) preferences.push(`traveling from: ${originLocation}`);
                if (travelDates) preferences.push(`travel dates: ${travelDates}`);
                if (additionalInterests) preferences.push(`interests: ${additionalInterests}`);
                
                const preferencesText = preferences.join(', ');
                
                // Add exclusion note
                let exclusionNote = '';
                if (excludeCountries) {
                    exclusionNote = ` Do NOT suggest the following countries: ${excludeCountries}.`;
                }
                
                // Show loading state
                const submitBtn = form.querySelector('button[type="submit"]');
                const originalBtnText = submitBtn.innerHTML;
                submitBtn.innerHTML = '<div class="flex items-center justify-center gap-2"><div class="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin"></div>Finding destinations...</div>';
                submitBtn.disabled = true;
                
                // Clear previous results
                const resultsList = $('#destination-list');
                resultsList.innerHTML = '';
                $('#destination-results').classList.add('hidden');
                
                // Build context about origin and duration
                let durationContext = '';
                if (originLocation && tripDuration) {
                    const durationDays = tripDuration === 'weekend' ? '2-3 days' : 
                                        tripDuration === 'short' ? '4-7 days' :
                                        tripDuration === 'medium' ? '8-14 days' : '15+ days';
                    durationContext = `\n\nIMPORTANT: The traveler is departing from ${originLocation} with a trip duration of ${durationDays}. Consider realistic travel times and distances. For shorter trips (weekend/short), prioritize destinations with shorter flight times (ideally under 6-8 hours). For medium/long trips, more distant destinations are acceptable. DO NOT suggest destinations that would waste the entire trip on travel time.`;
                } else if (originLocation) {
                    durationContext = `\n\nNote: The traveler is departing from ${originLocation}. Consider flight times and accessibility from this location.`;
                } else if (tripDuration) {
                    const durationDays = tripDuration === 'weekend' ? '2-3 days' : 
                                        tripDuration === 'short' ? '4-7 days' :
                                        tripDuration === 'medium' ? '8-14 days' : '15+ days';
                    durationContext = `\n\nNote: Trip duration is ${durationDays}. For shorter trips, prioritize destinations that don't require excessive travel time.`;
                }
                
                // Create AI prompt
                const prompt = `Based on these travel preferences: ${preferencesText}${exclusionNote}${durationContext}

Please suggest 4-5 ideal COUNTRIES (not cities) that match these criteria${travelDates ? ` considering the travel dates (${travelDates}) for seasonal appropriateness` : ''}. For each country, provide:
1. The country name ONLY (e.g., "Japan", "Costa Rica", "Greece")
2. A brief explanation (2-3 sentences) of why this country matches the preferences${originLocation ? ', considering travel time from ' + originLocation : ''}${travelDates ? ' and why it\'s good to visit during those dates' : ''}
3. Best time to visit (1 sentence)

Format your response as a JSON array with this structure:
[
  {
    "destination": "Country Name",
    "why": "Explanation of why it fits the preferences",
    "bestTime": "Best time to visit"
  }
]

IMPORTANT: Only return the JSON array, no additional text. The "destination" field should contain ONLY the country name, no cities.`;

                // Call AI
                const response = await fetch(`${BACKEND_URL}/api/gemini`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ userInput: prompt })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to get AI suggestions');
                }
                
                const aiResponse = await response.json();
                
                // Parse destinations - handle multiple response formats
                let destinations = [];
                let responseText = '';
                
                // Try different response structures
                if (aiResponse && typeof aiResponse === 'object') {
                    responseText = aiResponse.text || aiResponse.response || aiResponse.content || JSON.stringify(aiResponse);
                } else if (typeof aiResponse === 'string') {
                    responseText = aiResponse;
                }
                
                
                if (responseText) {
                    try {
                        // Try to extract JSON from the response
                        const jsonMatch = responseText.match(/\[[\s\S]*\]/);
                        if (jsonMatch) {
                            destinations = JSON.parse(jsonMatch[0]);
                        } else {
                            console.warn('No JSON array found in response');
                        }
                    } catch (parseError) {
                        console.error('Error parsing destinations:', parseError);
                        console.error('Failed text:', responseText);
                    }
                }
                
                // Hide loading, show form and results
                $('#destination-loading').classList.add('hidden');
                $('#destination-suggest-form').classList.remove('hidden');
                
                // Refresh icons
                lucide.createIcons();
                
                // Restore button
                submitBtn.innerHTML = originalBtnText;
                submitBtn.disabled = false;
                
                // Display results
                if (destinations && destinations.length > 0) {
                    $('#destination-results').classList.remove('hidden');
                    
                    // Scroll to results after a short delay
                    setTimeout(() => {
                        const resultsSection = $('#destination-results');
                        if (resultsSection) {
                            resultsSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                        }
                    }, 100);
                    
                    destinations.forEach(dest => {
                        
                        // Safety checks for properties
                        const destination = dest.destination || dest.name || 'Unknown Destination';
                        const why = dest.why || dest.reason || dest.description || 'A great destination for you';
                        const bestTime = dest.bestTime || dest.best_time || 'Year-round';
                        
                        const card = document.createElement('div');
                        card.className = 'bg-white border border-gray-200 rounded-lg p-4 hover:shadow-lg hover:border-[#0D5C63] transition-all cursor-pointer';
                        card.innerHTML = `
                            <h4 class="text-lg font-bold text-[#0D5C63] mb-2">${destination}</h4>
                            <p class="text-gray-700 text-sm mb-2">${why}</p>
                            <p class="text-gray-500 text-xs mb-3"><strong>Best time:</strong> ${bestTime}</p>
                            <button type="button" class="select-country-btn w-full py-2 px-4 bg-gradient-to-r from-[#0D5C63] to-[#0A4C53] text-white font-semibold rounded-lg hover:shadow-lg transition-all pointer-events-none">
                                Select ${destination}
                            </button>
                        `;
                        
                        // Create selection handler function
                        const selectCountry = (e) => {
                            
                            // Fill destination field in guided mode
                            const destInput = $('#destination');
                            if (destInput) {
                                destInput.value = destination;
                            } else {
                                console.warn('Destination input not found');
                            }
                            
                            // Also fill chat input for manual mode
                            const duration = tripDuration === 'weekend' ? '3 days' : 
                                           tripDuration === 'short' ? '5 days' :
                                           tripDuration === 'medium' ? '7 days' : '10 days';
                            const chatInput = $('#chat-input');
                            if (chatInput) {
                                chatInput.value = `Plan a ${duration} ${travelStyle || 'vacation'} trip to ${destination} with a ${budgetLevel || 'moderate'} budget`;
                            }
                            
                            // Close modal
                            hideModal('destination-suggest-modal');
                            
                            // Scroll to planner section
                            setTimeout(() => {
                                const plannerSection = document.querySelector('#planner');
                                if (plannerSection) {
                                    plannerSection.scrollIntoView({ behavior: 'smooth' });
                                }
                            }, 300);
                        };
                        
                        // Add click handler to the entire card
                        card.addEventListener('click', selectCountry);
                        
                        resultsList.appendChild(card);
                    });
                    
                    lucide.createIcons();
                } else {
                    // Show error message with debug info
                    resultsList.innerHTML = `
                        <div class="text-center py-4">
                            <p class="text-gray-500 mb-2">No destinations found. Please try different preferences.</p>
                            <details class="text-xs text-gray-400 mt-2">
                                <summary class="cursor-pointer hover:text-gray-600">Show Debug Info</summary>
                                <pre class="mt-2 p-2 bg-gray-100 rounded text-left overflow-auto max-h-60">${JSON.stringify({responseText, aiResponse}, null, 2)}</pre>
                            </details>
                        </div>
                    `;
                    $('#destination-results').classList.remove('hidden');
                }
                
            } catch (error) {
                console.error('Error getting destination suggestions:', error);
                
                // Hide loading, show form
                $('#destination-loading').classList.add('hidden');
                $('#destination-suggest-form').classList.remove('hidden');
                
                // Show error in UI
                const resultsList = $('#destination-list');
                resultsList.innerHTML = `
                    <div class="text-center py-4">
                        <p class="text-red-500 mb-2">⚠️ Failed to get destination suggestions</p>
                        <p class="text-sm text-gray-600 mb-4">${error.message}</p>
                        <button onclick="location.reload()" class="px-4 py-2 bg-gray-200 rounded hover:bg-gray-300 text-sm">Reload Page</button>
                    </div>
                `;
                $('#destination-results').classList.remove('hidden');
                
                // Restore button
                const submitBtn = $('#destination-suggest-form').querySelector('button[type="submit"]');
                if (submitBtn) {
                    submitBtn.innerHTML = '<span class="flex items-center justify-center gap-2" style="width: 100%;"><i data-lucide="compass" class="w-6 h-6"></i>Get Destination Suggestions</span>';
                    submitBtn.disabled = false;
                    lucide.createIcons();
                }
            }
        }
        // ============================================================
        // NEW CONVERSATIONAL CHAT SYSTEM - Integrated Oct 19, 2025
        // ============================================================
        
        // Global conversation history for context-aware chat
        let conversationHistory = [];

        // Main chat handler - supports general chat, itinerary generation, and refinements
        async function handleSendV2(prompt) {
            const userInput = prompt || $('#chat-input').value.trim();
            if (!userInput) return;

            if (!auth.currentUser) {
                showModal('guest-custom-plan-modal');
                return;
            }
            
            // Check if limit reached - show modal immediately
            if (hasReachedLimit) {
                showModal('limit-reached-modal');
                return;
            }
            
            // Check if this might be an itinerary request
            const itineraryKeywords = ['plan', 'itinerary', 'trip to', 'days in', 'travel to', 'visit'];
            const isLikelyItineraryRequest = itineraryKeywords.some(keyword => 
                userInput.toLowerCase().includes(keyword)
            );
            
            // Check usage limits BEFORE processing if this looks like a new itinerary request
            if (isLikelyItineraryRequest && !lastItineraryJson && currentUserSubscription === 'free') {
                const userDocRef = doc(db, "users", auth.currentUser.uid);
                const docSnap = await getDoc(userDocRef);
                const userData = docSnap.data() || {};
                const itineraryCount = userData.itineraryCount || 0;
                
                if (itineraryCount >= 3) {
                    console.log('⚠️ User attempted to generate itinerary but limit reached');
                    showModal('limit-reached-modal');
                    return;
                }
            }
            
            // Scroll to planner section immediately when sending
            const plannerSection = document.getElementById('planner');
            if (plannerSection) {
                plannerSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
            } else {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }
            
            // Add user message to UI
            addMessage('user', userInput);
            if(!prompt) $('#chat-input').value = '';
            
            // Add to conversation history
            conversationHistory.push({
                role: 'user',
                content: userInput
            });
            
            // Check if this is a refinement (user already has an itinerary)
            const isRefinement = lastItineraryJson !== null;
            showTypingIndicator(isRefinement);
            
            try {
                // Call the new smart chat endpoint with extended timeout for Render free tier
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 90000); // 90 second timeout for cold starts
                
                const response = await fetch(`${BACKEND_URL}/api/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        messages: conversationHistory,
                        conversationHistory: conversationHistory.slice(-10) // Last 10 messages for context
                    }),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error('Chat service unavailable');
                }
                
                const data = await response.json();
                let aiResponse = data.response || data.text || '';
                
                // Parse the AI's response (it returns JSON with type field)
                let responseData;
                try {
                    // Remove markdown code blocks if present
                    const cleanResponse = aiResponse.replace(/```json\s*/g, '').replace(/```\s*$/g, '').trim();
                    responseData = JSON.parse(cleanResponse);
                } catch (e) {
                    // If not JSON, treat as plain text chat
                    responseData = { type: 'chat', message: aiResponse };
                }
                
                
                // Handle based on response type
                switch(responseData.type) {
                    case 'itinerary':
                        // Full itinerary requested
                        await handleItineraryResponseV2(responseData);
                        break;
                        
                    case 'refinement':
                        // Refining existing itinerary
                        handleRefinementResponseV2(responseData.message);
                        break;
                        
                    case 'chat':
                    default:
                        // General conversation
                        handleChatResponseV2(responseData.message);
                        break;
                }
                
                // Add AI response to history
                conversationHistory.push({
                    role: 'assistant',
                    content: JSON.stringify(responseData)
                });
                
            } catch (error) {
                console.error('Chat error:', error);
                if (error.name === 'AbortError') {
                    addMessage('ai', '⏱️ Request timed out. The server may be waking up (free tier). Please try again in 30 seconds.');
                } else if (error.message.includes('Failed to fetch')) {
                    addMessage('ai', '🔌 Unable to reach the server. It may be starting up (this can take 30-60 seconds on first request). Please try again shortly.');
                } else {
                    addMessage('ai', '❌ Sorry, I encountered an error. Please try again.');
                }
            } finally {
                removeTypingIndicator();
            }
        }

        // Handle full itinerary generation
        async function handleItineraryResponseV2(itineraryData) {
            
            // Normalize the itinerary
            const normalized = normalizeItinerary(itineraryData);
            if (!normalized) {
                addMessage('ai', '❌ Could not create itinerary. Please try again with more details.');
                return;
            }
            
            // Increment usage count for free users BEFORE rendering
            if (currentUserSubscription === 'free' && auth.currentUser) {
                try {
                    const userDocRef = doc(db, "users", auth.currentUser.uid);
                    await setDoc(userDocRef, { itineraryCount: increment(1) }, { merge: true });
                    console.log('✅ Incremented itinerary count for free user');
                    
                    // Refresh the usage display
                    const docSnap = await getDoc(userDocRef);
                    const userData = docSnap.data() || {};
                    const newCount = userData.itineraryCount || 0;
                    const remaining = 3 - newCount;
                    console.log(`📊 New usage: ${newCount}/3 itineraries generated, ${remaining} remaining`);
                    
                    // Update UI with new remaining count
                    if (remaining > 0) {
                        updateRemainingCount(remaining);
                    } else {
                        // User just hit the limit
                        disableGenerateButtons('You\'ve reached your free limit of 3 itineraries. Upgrade to continue!');
                    }
                } catch (error) {
                    console.error('❌ Error incrementing itinerary count:', error);
                }
            }
            
            // Clear cache for new itinerary
            cachedMappedCities = null;
            
            // Save for refinements
            lastItineraryJson = normalized;
            
            // Render the itinerary
            const html = renderItineraryHTML(normalized);
            addMessage('ai', html);
            
            // Scroll to top of chat window AND main window to see the itinerary from the beginning
            setTimeout(() => {
                const chatWindow = $('#chat-window');
                if (chatWindow) {
                    
                    // Try both methods for compatibility
                    chatWindow.scrollTop = 0; // Instant scroll to top
                    
                    // Also try smooth scroll
                    try {
                        chatWindow.scrollTo({ top: 0, behavior: 'smooth' });
                    } catch (e) {
                        console.warn('ScrollTo with smooth behavior not supported:', e);
                    }
                    
                }
                
                // Also scroll the main window to the planner section
                const plannerSection = document.getElementById('planner');
                if (plannerSection) {
                    plannerSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                } else {
                    // Fallback: scroll main window to top
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                }
            }, 200); // Increased timeout to ensure content is rendered
            
            // Show action buttons
            const actionButtons = $('#action-buttons');
            if (actionButtons) {
                actionButtons.classList.remove('hidden');
                actionButtons.style.cssText = 'display: flex !important;';
                
                // Debug: Log all buttons inside
                const buttons = actionButtons.querySelectorAll('button');
                buttons.forEach((btn, i) => {
                    console.log(`Button ${i + 1}:`, {
                        id: btn.id,
                        text: btn.textContent,
                        visible: window.getComputedStyle(btn).display,
                        bgColor: window.getComputedStyle(btn).backgroundColor,
                        color: window.getComputedStyle(btn).color
                    });
                });
                
                // Initialize Lucide icons for the buttons
                setTimeout(() => {
                    lucide.createIcons();
                }, 100);
            } else {
                console.error('❌ Action buttons element not found!');
            }
            
            // Add suggestion chips
            setTimeout(() => {
                addMessage('ai', `
                    <div class="p-4 bg-gradient-to-r from-blue-50 to-indigo-50 rounded-lg border border-blue-200">
                        <div class="flex items-center gap-2 mb-3">
                            <div class="bg-blue-100 p-2 rounded-full">
                                <i data-lucide="sparkles" class="w-5 h-5 text-blue-600"></i>
                            </div>
                            <p class="font-semibold text-gray-800">Want to refine this itinerary?</p>
                        </div>
                        <p class="text-sm text-gray-600 mb-3">Click a suggestion or type your own request below:</p>
                        <div class="flex flex-wrap gap-2 mb-4">
                            <button class="inline-chat-chip text-xs bg-white border border-blue-300 text-gray-700 px-3 py-2 rounded-lg hover:bg-blue-100 hover:border-blue-400 transition-all shadow-sm" data-prompt="Add more restaurant recommendations">
                                <i data-lucide="utensils" class="w-3 h-3 inline mr-1"></i>More food spots
                            </button>
                            <button class="inline-chat-chip text-xs bg-white border border-blue-300 text-gray-700 px-3 py-2 rounded-lg hover:bg-blue-100 hover:border-blue-400 transition-all shadow-sm" data-prompt="Make the schedule more relaxed">
                                <i data-lucide="coffee" class="w-3 h-3 inline mr-1"></i>More relaxed
                            </button>
                            <button class="inline-chat-chip text-xs bg-white border border-blue-300 text-gray-700 px-3 py-2 rounded-lg hover:bg-blue-100 hover:border-blue-400 transition-all shadow-sm" data-prompt="Add budget estimates">
                                <i data-lucide="wallet" class="w-3 h-3 inline mr-1"></i>Budget details
                            </button>
                            <button class="inline-chat-chip text-xs bg-white border border-blue-300 text-gray-700 px-3 py-2 rounded-lg hover:bg-blue-100 hover:border-blue-400 transition-all shadow-sm" data-prompt="Show me hidden gems">
                                <i data-lucide="compass" class="w-3 h-3 inline mr-1"></i>Hidden gems
                            </button>
                        </div>
                    </div>
                `);
                lucide.createIcons();
                
                // Show persistent chat bar after itinerary generation
                const persistentBar = $('#persistent-chat-bar');
                if (persistentBar) {
                    persistentBar.classList.remove('hidden');
                    persistentBar.style.cssText = 'display: block !important;'; // Force display
                    lucide.createIcons(); // Initialize icons in persistent bar
                }
            }, 500);
            
            // Generate map
            if (normalized.days && normalized.days.length > 0) {
                initializeProgressiveMap();
                const cities = await extractCitiesFromAI(JSON.stringify(normalized));
                if (cities && cities.length > 0) {
                    await createMapFromCities(cities, JSON.stringify(normalized));
                }
            }
            
            // Update input placeholder
            $('#chat-input').placeholder = 'Continue chatting to refine your itinerary...';
            
            // Scroll to bottom
            setTimeout(() => {
                const chatWindow = $('#chat-window');
                chatWindow.scrollTop = chatWindow.scrollHeight;
            }, 100);
        }

        // Handle refinement suggestions
        function handleRefinementResponseV2(message) {
            // DON'T process venue tags first - it strips newlines!
            // Parse markdown structure FIRST, then process venue tags in each piece
            
            let formatted = '';
            const lines = message.split('\n'); // Use original message, not processed
            let inList = false;
            
            for (let i = 0; i < lines.length; i++) {
                let line = lines[i].trim();
                
                // Skip empty lines but close lists if needed
                if (!line) {
                    if (inList) {
                        formatted += '</ul>';
                        inList = false;
                    }
                    formatted += '<div class="h-3"></div>'; // Spacing
                    continue;
                }
                
                // Check for section headers: ** Text: **
                if (line.match(/^\*\*\s*(.+?):\s*\*\*$/)) {
                    if (inList) {
                        formatted += '</ul>';
                        inList = false;
                    }
                    const headerText = line.replace(/^\*\*\s*(.+?):\s*\*\*$/, '$1');
                    const processedHeader = processVenueTags(headerText); // Process venue tags in header
                    formatted += `
                        <div class="mt-6 mb-3 pb-2 border-b-2 border-[#0D5C63]">
                            <h4 class="text-lg font-bold text-[#0D5C63]">✨ ${processedHeader}</h4>
                        </div>
                    `;
                    continue;
                }
                
                // Check for bullet points: * Text or *   Text (with multiple spaces)
                if (line.match(/^\*\s+(.+)$/)) {
                    const bulletText = line.replace(/^\*\s+/, '');
                    // Process bold and venue tags in bullet text
                    let processedBullet = bulletText.replace(/\*\*(.+?)\*\*/g, '<strong class="font-semibold text-gray-900">$1</strong>');
                    processedBullet = processVenueTags(processedBullet);
                    
                    if (!inList) {
                        formatted += '<ul class="ml-4 mb-4 space-y-2">';
                        inList = true;
                    }
                    formatted += `
                        <li class="flex items-start">
                            <span class="text-[#0D5C63] font-bold mr-2 mt-1">•</span>
                            <span class="text-gray-700 leading-relaxed">${processedBullet}</span>
                        </li>
                    `;
                    continue;
                }
                
                // Regular paragraph text
                if (inList) {
                    formatted += '</ul>';
                    inList = false;
                }
                
                // Process bold text and venue tags in the paragraph
                let processedLine = line.replace(/\*\*(.+?)\*\*/g, '<strong class="font-semibold text-gray-900">$1</strong>');
                processedLine = processVenueTags(processedLine);
                formatted += `<p class="text-gray-700 leading-relaxed mb-4">${processedLine}</p>`;
            }
            
            // Close any open list
            if (inList) {
                formatted += '</ul>';
            }
            
            // Wrap in container
            const finalMessage = `
                <div class="refinement-response space-y-1 text-base">
                    ${formatted}
                </div>
            `;
            
            // Display as chat message
            addMessage('ai', finalMessage);
            
            // Scroll to bottom
            setTimeout(() => {
                const chatWindow = $('#chat-window');
                chatWindow.scrollTop = chatWindow.scrollHeight;
                lucide.createIcons();
            }, 100);
        }

        // Handle general chat
        function handleChatResponseV2(message) {
            
            // Use the same robust markdown parser as refinement responses
            // DON'T call processVenueTags first - it strips newlines!
            
            let formatted = '';
            const lines = message.split('\n');
            let inList = false;
            
            for (let i = 0; i < lines.length; i++) {
                let line = lines[i].trim();
                
                // Skip empty lines but close lists if needed
                if (!line) {
                    if (inList) {
                        formatted += '</ul>';
                        inList = false;
                    }
                    formatted += '<div class="h-3"></div>'; // Spacing
                    continue;
                }
                
                // Check for section headers: ** Text: **
                if (line.match(/^\*\*\s*(.+?):\s*\*\*$/)) {
                    if (inList) {
                        formatted += '</ul>';
                        inList = false;
                    }
                    const headerText = line.replace(/^\*\*\s*(.+?):\s*\*\*$/, '$1');
                    const processedHeader = processVenueTags(headerText);
                    formatted += `
                        <div class="mt-6 mb-3 pb-2 border-b-2 border-[#0D5C63]">
                            <h4 class="text-lg font-bold text-[#0D5C63]">✨ ${processedHeader}</h4>
                        </div>
                    `;
                    continue;
                }
                
                // Check for bullet points: * Text or *   Text (with multiple spaces)
                if (line.match(/^\*\s+(.+)$/)) {
                    const bulletText = line.replace(/^\*\s+/, '');
                    // Process bold and venue tags in bullet text
                    let processedBullet = bulletText.replace(/\*\*(.+?)\*\*/g, '<strong class="font-semibold text-gray-900">$1</strong>');
                    processedBullet = processVenueTags(processedBullet);
                    
                    if (!inList) {
                        formatted += '<ul class="ml-4 mb-4 space-y-2">';
                        inList = true;
                    }
                    formatted += `
                        <li class="flex items-start">
                            <span class="text-[#0D5C63] font-bold mr-2 mt-1">•</span>
                            <span class="text-gray-700 leading-relaxed">${processedBullet}</span>
                        </li>
                    `;
                    continue;
                }
                
                // Regular paragraph text
                if (inList) {
                    formatted += '</ul>';
                    inList = false;
                }
                
                // Process bold text and venue tags in the paragraph
                let processedLine = line.replace(/\*\*(.+?)\*\*/g, '<strong class="font-semibold text-gray-900">$1</strong>');
                processedLine = processVenueTags(processedLine);
                formatted += `<p class="text-gray-700 leading-relaxed mb-4">${processedLine}</p>`;
            }
            
            // Close any open list
            if (inList) {
                formatted += '</ul>';
            }
            
            // Wrap in a styled container
            const styledMessage = `
                <div class="chat-response-content text-gray-700 text-base">
                    ${formatted}
                </div>
            `;
            
            // Display as chat message
            addMessage('ai', styledMessage);
            
            // Scroll to bottom
            setTimeout(() => {
                const chatWindow = $('#chat-window');
                chatWindow.scrollTop = chatWindow.scrollHeight;
                lucide.createIcons();
            }, 100);
        }

        // ============================================================
        // OLD CHAT SYSTEM - Kept for reference, commented out
        // ============================================================
        /*
        async function handleSend(prompt) {
            const userInput = prompt || $('#chat-input').value.trim();
            if (!userInput) return;

            if (!auth.currentUser) {
                showModal('guest-custom-plan-modal');
                return;
            }
            
            // Determine the type of request
            const isRefinement = lastItineraryJson !== null;
            const isItineraryRequest = !isRefinement && (
                /\b(plan|itinerary|trip|travel|visit|vacation|holiday|tour|journey)\b/i.test(userInput) ||
                /\b(days?|weeks?|months?)\b/i.test(userInput) ||
                /\bto\b.*\b(country|city|place|destination)/i.test(userInput)
            );
            
            // Only count towards itinerary limit if it's an actual itinerary request
            if (isItineraryRequest && currentUserSubscription === 'free') {
                const userDocRef = doc(db, "users", auth.currentUser.uid);
                const docSnap = await getDoc(userDocRef);
                const userData = docSnap.data() || {};
                if ((userData.itineraryCount || 0) >= 3) {
                    showModal('limit-reached-modal');
                    return;
                }
                await setDoc(userDocRef, { itineraryCount: increment(1) }, { merge: true });
            }
            
            addMessage('user', userInput);
            if(!prompt) $('#chat-input').value = '';
            showTypingIndicator();
            
            // Show immediate feedback for pin generation
            
            // Initialize progressive map (only for new itineraries, not refinements)
            if (!isRefinement) {
                initializeProgressiveMap();
            }
            
            try {
                let aiResponseObject;
                
                // OPTION 1: Refining existing itinerary
                if (isRefinement) {
                    addMessage('ai', '💭 Analyzing your request and updating the itinerary...');
                    
                    // Create a concise summary for refinement
                    const itinerarySummary = {
                        title: lastItineraryJson.title,
                        destination: lastItineraryJson.title?.split('to ')[1] || 'the destination',
                        totalDays: lastItineraryJson.days?.length || 0,
                        days: lastItineraryJson.days?.map((day, idx) => ({
                            dayNumber: idx + 1,
                            title: day.title,
                            activityCount: day.activities?.length || 0
                        })) || []
                    };
                    
                    const refinementPrompt = `I have a ${itinerarySummary.totalDays}-day trip to ${itinerarySummary.destination}.

Current days: ${itinerarySummary.days.map(d => `Day ${d.dayNumber}: ${d.title} (${d.activityCount} activities)`).join(', ')}

User's refinement request: "${userInput}"

Please provide ONLY the specific changes or additions as a conversational response. Be concise and specific. 

If the user asks for food recommendations:
- List 3-5 specific restaurants/cafes with names
- Include brief descriptions (cuisine type, specialties)
- Format: **Restaurant Name** - Description
- NO venue tags, NO maps links, just clean readable text

If they ask to make it more relaxed: suggest which activities to remove or adjust
If they ask for budget: provide estimated costs
If they ask for museums/attractions: list 3-5 with brief descriptions

Format your response in clean, readable Markdown with proper headings and bullet points.

DO NOT use [VENUE] tags or complex formatting. Just provide helpful, conversational information.`;

                    const response = await fetch(`${BACKEND_URL}/api/gemini`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ userInput: refinementPrompt })
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to get AI response');
                    }
                    
                    const data = await response.json();
                    let refinementResponse = data.response || data.text || data;
                    
                    // Process venue tags in the refinement response
                    if (typeof refinementResponse === 'string') {
                        refinementResponse = processVenueTags(refinementResponse);
                    }
                    
                    // Display the refinement as a regular AI message
                    addMessage('ai', refinementResponse);
                    
                    // Scroll to bottom
                    setTimeout(() => {
                        const chatWindow = $('#chat-window');
                        chatWindow.scrollTop = chatWindow.scrollHeight;
                        lucide.createIcons();
                    }, 100);
                    
                    removeTypingIndicator();
                    return; // Exit early for refinements
                }
                
                // OPTION 2: General chat (not travel-related or just conversational)
                if (!isItineraryRequest) {
                    
                    const generalChatPrompt = `You are KimatAI, a helpful and friendly AI travel assistant. The user is asking: "${userInput}"

This doesn't appear to be a trip planning request. Please respond naturally and helpfully to their question or comment.

- If they're asking about travel in general, provide helpful information
- If they're asking non-travel questions, politely answer but remind them you're a travel assistant
- Keep responses concise and friendly
- Use Markdown formatting for readability

Be conversational and helpful!`;

                    const response = await fetch(`${BACKEND_URL}/api/gemini`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ userInput: generalChatPrompt })
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to get AI response');
                    }
                    
                    const data = await response.json();
                    let chatResponse = data.response || data.text || data;
                    
                    // Process any tags in the response
                    if (typeof chatResponse === 'string') {
                        chatResponse = processVenueTags(chatResponse);
                    }
                    
                    addMessage('ai', chatResponse);
                    
                    // Scroll to bottom
                    setTimeout(() => {
                        const chatWindow = $('#chat-window');
                        chatWindow.scrollTop = chatWindow.scrollHeight;
                        lucide.createIcons();
                    }, 100);
                    
                    removeTypingIndicator();
                    return; // Exit early for general chat
                }
                
                // OPTION 3: Creating a new itinerary
                aiResponseObject = await getAIResponse(userInput);
                
                // Process the response for the progressive map AFTER completion (much more reliable)
                if (aiResponseObject && typeof aiResponseObject === 'object') {
                    const responseText = JSON.stringify(aiResponseObject);
                    
                    // Start city extraction and mapping in background after response is complete
                    setTimeout(async () => {
                        try {
                            // First extract cities from AI
                            const cities = await extractCitiesFromAI(responseText);
                            
                            if (cities && cities.length > 0) {
                                await createMapFromCities(cities, responseText);
                                return; // Don't fall back if successful
                            } else {
                            }
                        } catch (error) {
                            console.error('❌ Error in AI city extraction:', error);
                        }
                        
                        // Only fall back if AI method completely failed
                        await createAnimatedMapFromResponse(responseText);
                    }, 100);
                } else {
                    console.warn('⚠️ No valid response received, aiResponseObject:', aiResponseObject);
                }
                
                removeTypingIndicator();
                
                // Finalize the progressive map
                finalizeProgressiveMap();
                
                if (aiResponseObject) {
                    // Try to parse and normalize the response
                    let parsedResponse = parseJSONSafe(aiResponseObject);
                    if (!parsedResponse) {
                        parsedResponse = aiResponseObject; // Maybe it's already an object
                    }
                    
                    lastItineraryJson = normalizeItinerary(parsedResponse); 
                    if (lastItineraryJson) {
                        const formattedHtml = renderItineraryHTML(lastItineraryJson);
                        addMessage('ai', formattedHtml);
                        
                        // Add a helpful message about refinements with inline chips AND input
                        setTimeout(() => {
                            addMessage('ai', `
                                <div class="p-4 bg-gradient-to-r from-blue-50 to-indigo-50 rounded-lg border border-blue-200">
                                    <div class="flex items-center gap-2 mb-3">
                                        <div class="bg-blue-100 p-2 rounded-full">
                                            <i data-lucide="sparkles" class="w-5 h-5 text-blue-600"></i>
                                        </div>
                                        <p class="font-semibold text-gray-800">Want to refine this itinerary?</p>
                                    </div>
                                    <p class="text-sm text-gray-600 mb-3">Click a suggestion or type your own request below:</p>
                                    <div class="flex flex-wrap gap-2 mb-4">
                                        <button class="inline-chat-chip text-xs bg-white border border-blue-300 text-gray-700 px-3 py-2 rounded-lg hover:bg-blue-100 hover:border-blue-400 transition-all shadow-sm" data-prompt="Add more restaurant recommendations">
                                            <i data-lucide="utensils" class="w-3 h-3 inline mr-1"></i>More food spots
                                        </button>
                                        <button class="inline-chat-chip text-xs bg-white border border-blue-300 text-gray-700 px-3 py-2 rounded-lg hover:bg-blue-100 hover:border-blue-400 transition-all shadow-sm" data-prompt="Make day 2 more relaxed">
                                            <i data-lucide="coffee" class="w-3 h-3 inline mr-1"></i>More relaxed
                                        </button>
                                        <button class="inline-chat-chip text-xs bg-white border border-blue-300 text-gray-700 px-3 py-2 rounded-lg hover:bg-blue-100 hover:border-blue-400 transition-all shadow-sm" data-prompt="Add budget estimates for each day">
                                            <i data-lucide="wallet" class="w-3 h-3 inline mr-1"></i>Budget details
                                        </button>
                                        <button class="inline-chat-chip text-xs bg-white border border-blue-300 text-gray-700 px-3 py-2 rounded-lg hover:bg-blue-100 hover:border-blue-400 transition-all shadow-sm" data-prompt="Include more hidden gems">
                                            <i data-lucide="compass" class="w-3 h-3 inline mr-1"></i>Hidden gems
                                        </button>
                                        <button class="inline-chat-chip text-xs bg-white border border-blue-300 text-gray-700 px-3 py-2 rounded-lg hover:bg-blue-100 hover:border-blue-400 transition-all shadow-sm" data-prompt="Add more museums and cultural sites">
                                            <i data-lucide="landmark" class="w-3 h-3 inline mr-1"></i>More culture
                                        </button>
                                    </div>
                                    <div class="flex items-center bg-white rounded-lg border-2 border-blue-300 shadow-sm">
                                        <input type="text" id="inline-chat-input" placeholder="Or type your custom request here..." class="w-full p-3 text-sm border-none focus:ring-0 rounded-lg" autocomplete="off">
                                        <button id="inline-send-button" class="p-3 text-blue-600 hover:text-blue-700 transition-colors">
                                            <i data-lucide="send" class="w-5 h-5"></i>
                                        </button>
                                    </div>
                                </div>
                            `);
                            lucide.createIcons();
                            
                            // Scroll chat window to bottom to show the message
                            const chatWindow = $('#chat-window');
                            if (chatWindow) {
                                chatWindow.scrollTop = chatWindow.scrollHeight;
                            }
                        }, 500);
                        
                        const actionButtons = $('#action-buttons');
                        actionButtons.classList.remove('hidden');
                        actionButtons.style.display = 'flex';
                        $('#chat-input').placeholder = 'Continue chatting to refine your itinerary...';
                    } else {
                        console.error("Failed to normalize itinerary:", parsedResponse);
                        throw new Error("Could not format the itinerary properly. The AI response might be incomplete.");
                    }
                } else {
                    throw new Error("No response received from the AI service. Please try again.");
                }
            } catch (error) {
                console.error("Error in handleSend:", error);
                removeTypingIndicator();
                
                // Clean up the progressive map on error
                if (isProgressiveMode) {
                    const statusElement = document.querySelector('.progressive-status');
                    if (statusElement) {
                        statusElement.textContent = 'Error occurred';
                        statusElement.classList.remove('text-blue-600');
                        statusElement.classList.add('text-red-600');
                    }
                }
                
                let errorMessage = "Sorry, I had trouble creating that itinerary. ";
                
                if (error.message.includes('Failed to fetch')) {
                    errorMessage += "Please make sure the backend server is running and try again.";
                } else if (error.message.includes('HTTP error')) {
                    errorMessage += "There was a server error. Please try again in a moment.";
                } else {
                    errorMessage += "Please try rephrasing your request.";
                }
                
                addMessage('ai', errorMessage);
            }
        }
        */ // End of old handleSend function
        
        // ============================================================
        // END OF OLD CHAT SYSTEM
        // ============================================================

        async function loadSavedItineraries() {
            if (!auth.currentUser) return;
            
            const container = $('#saved-itineraries-container');
            container.innerHTML = '';
            
            try {
                // Try to load from Firebase first
                const itinerariesRef = collection(db, "itineraries");
                const q = query(itinerariesRef, where("collaborators", "array-contains", auth.currentUser.uid));
                const querySnapshot = await getDocs(q);
                
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    const card = document.createElement('div');
                    card.className = 'bg-white rounded-lg shadow-md p-4 cursor-pointer hover:-translate-y-1 transition-transform';
                    const daysText = (data.days && data.days.length) ? `${data.days.length} days` : 'Duration not set';
                    card.innerHTML = `<h4 class="text-lg font-semibold">${data.title || 'Untitled'}</h4><p class="text-sm text-gray-500">${daysText} • Firebase</p>`;
                    card.onclick = () => openItineraryDetail(doc.id);
                    container.appendChild(card);
                });
                
                // Also load from localStorage as fallback
                const localItineraries = JSON.parse(localStorage.getItem('savedItineraries') || '[]');
                
                const userLocalItineraries = localItineraries.filter(item => {
                    // Only include items that explicitly belong to this user
                    return item.userId === auth.currentUser.uid;
                });
                
                
                userLocalItineraries.forEach((data) => {
                    const card = document.createElement('div');
                    card.className = 'bg-white rounded-lg shadow-md p-4 cursor-pointer hover:-translate-y-1 transition-transform border-l-4 border-blue-400';
                    const daysText = (data.days && data.days.length) ? `${data.days.length} days` : 'Duration not set';
                    card.innerHTML = `<h4 class="text-lg font-semibold">${data.title || 'Untitled'}</h4><p class="text-sm text-gray-500">${daysText} • Local ${data.id ? `(${data.id})` : '(no ID)'}</p>`;
                    card.onclick = () => openLocalItinerary(data);
                    container.appendChild(card);
                });
                
                if (querySnapshot.empty && userLocalItineraries.length === 0) {
                    container.innerHTML = '<p class="text-gray-500 col-span-full text-center">No saved trips yet!</p>';
                }
                
            } catch (error) {
                console.error('Error loading itineraries:', error);
                
                // Fallback to localStorage only
                const localItineraries = JSON.parse(localStorage.getItem('savedItineraries') || '[]');
                const userLocalItineraries = localItineraries.filter(item => item.userId === auth.currentUser.uid);
                
                userLocalItineraries.forEach((data) => {
                    const card = document.createElement('div');
                    card.className = 'bg-white rounded-lg shadow-md p-4 cursor-pointer hover:-translate-y-1 transition-transform border-l-4 border-blue-400';
                    const daysText = (data.days && data.days.length) ? `${data.days.length} days` : 'Duration not set';
                    card.innerHTML = `<h4 class="text-lg font-semibold">${data.title || 'Untitled'}</h4><p class="text-sm text-gray-500">${daysText} • Local</p>`;
                    card.onclick = () => openLocalItinerary(data);
                    container.appendChild(card);
                });
                
                if (userLocalItineraries.length === 0) {
                    container.innerHTML = '<p class="text-gray-500 col-span-full text-center">No saved trips found. Database connection issue.</p>';
                }
            }
        }
        
        function openLocalItinerary(itineraryData) {
            try {
                const itinerary = normalizeItinerary(itineraryData);
                
                if (!itinerary) {
                    console.error('Failed to normalize local itinerary data');
                    alert("This local itinerary has an invalid format and cannot be displayed.");
                    return;
                }
                
                // Store current itinerary for editing (use the id from itineraryData)
                currentEditingItinerary = itinerary;
                currentItineraryId = itineraryData.id || 'local-' + Date.now();
                currentItineraryData = itinerary;
                isEditMode = false;
                
                $('#itinerary-detail-title').textContent = itinerary.title || 'Local Itinerary';
                $('#itinerary-detail-content').innerHTML = renderItineraryHTML(itinerary);
                
                // Reset edit UI
                $('#edit-itinerary-btn').classList.remove('hidden');
                $('#save-changes-btn').classList.add('hidden');
                $('#cancel-edit-btn').classList.add('hidden');
                $('#itinerary-detail-title').contentEditable = false;
                
                // Set up permissions (local itineraries default to owner permissions)
                const localItinerary = { 
                    ...itinerary, 
                    ownerId: auth.currentUser?.uid, 
                    collaborators: auth.currentUser ? [auth.currentUser.uid] : [] 
                };
                setupSharedItineraryPermissions(localItinerary);
                
                showModal('itinerary-detail-modal');
            } catch (error) {
                console.error('Error opening local itinerary:', error);
                alert("Failed to load local itinerary. Please try again.");
            }
        }

        // Function to set up permissions for shared itineraries
        function setupSharedItineraryPermissions(itinerary) {
            currentItineraryData = itinerary;
            
            const shareBtn = $('#share-itinerary-btn');
            const editBtn = $('#edit-itinerary-btn');
            const deleteBtn = $('#delete-itinerary-btn');
            
            // Check if buttons exist
            if (!shareBtn || !editBtn || !deleteBtn) {
                console.warn('Some permission buttons not found:', {
                    shareBtn: !!shareBtn,
                    editBtn: !!editBtn, 
                    deleteBtn: !!deleteBtn
                });
            }
            
            // Remove any existing permission indicators
            const existingIndicator = document.querySelector('#permission-indicator');
            if (existingIndicator) {
                existingIndicator.remove();
            }
            
            if (!auth.currentUser) {
                // Not logged in - hide all action buttons except viewing
                shareBtn.style.display = 'none';
                editBtn.style.display = 'none';
                deleteBtn.style.display = 'none';
                
                // Add view-only indicator
                addPermissionIndicator('👁️ View Only', 'text-gray-600');
                return;
            }
            
            // Check if user is owner (support both ownerId and userId fields for backward compatibility)
            const isOwner = auth.currentUser.uid === itinerary.ownerId || 
                            auth.currentUser.uid === itinerary.userId ||
                            (!itinerary.ownerId && !itinerary.collaborators); // If no owner field, assume current user owns it
            
            const isCollaborator = itinerary.collaborators && itinerary.collaborators.includes(auth.currentUser.uid);
            
            if (isOwner) {
                // Owner can do everything
                if (shareBtn) shareBtn.style.display = 'flex';
                if (editBtn) editBtn.style.display = 'flex';
                if (deleteBtn) deleteBtn.style.display = 'flex';
                addPermissionIndicator('👑 Owner', 'text-blue-600');
            } else if (isCollaborator) {
                // Collaborators can share and edit, but not delete
                if (shareBtn) shareBtn.style.display = 'flex';
                if (editBtn) editBtn.style.display = 'flex';
                if (deleteBtn) deleteBtn.style.display = 'none';
                addPermissionIndicator('🤝 Collaborator', 'text-green-600');
            } else {
                // Not a collaborator - can only view
                if (shareBtn) shareBtn.style.display = 'none';
                if (editBtn) editBtn.style.display = 'none';
                if (deleteBtn) deleteBtn.style.display = 'none';
                addPermissionIndicator('👁️ View Only', 'text-gray-600');
            }
        }

        function addPermissionIndicator(text, className) {
            const titleElement = $('#itinerary-detail-title');
            const indicator = document.createElement('span');
            indicator.id = 'permission-indicator';
            indicator.className = `text-sm font-normal ml-2 ${className}`;
            indicator.textContent = text;
            titleElement.appendChild(indicator);
        }

        async function openItineraryDetail(itineraryId) {
            try {
                const docRef = doc(db, "itineraries", itineraryId);
                const docSnap = await getDoc(docRef);

                if (docSnap.exists()) {
                    const data = docSnap.data();
                    
                    const itinerary = normalizeItinerary(data);
                    
                    if (!itinerary) {
                        console.error('Failed to normalize itinerary data');
                        alert("This itinerary has an invalid format and cannot be displayed.");
                        return;
                    }
                    
                    // Store current itinerary for editing
                    currentEditingItinerary = itinerary;
                    currentItineraryId = itineraryId;
                    currentItineraryData = itinerary;
                    isEditMode = false;
                    
                    $('#itinerary-detail-title').textContent = itinerary.title || 'Itinerary Details';
                    $('#itinerary-detail-content').innerHTML = renderItineraryHTML(itinerary);
                    
                    // Reset edit UI
                    $('#edit-itinerary-btn').classList.remove('hidden');
                    $('#save-changes-btn').classList.add('hidden');
                    $('#cancel-edit-btn').classList.add('hidden');
                    $('#itinerary-detail-title').contentEditable = false;
                    
                    // Set up permissions (owner has full access to their own itineraries)
                    setupSharedItineraryPermissions(itinerary);
                    
                    showModal('itinerary-detail-modal');
                } else {
                    console.error('Itinerary document not found:', itineraryId);
                    alert("Could not find the itinerary.");
                }
            } catch (error) {
                console.error('Error opening itinerary:', error);
                alert("Failed to load itinerary. Please try again.");
            }
        }

        async function generatePDF(itinerary) {
            
            // Check if libraries are loaded with multiple checks
            let jsPDFAvailable = false;
            
            // Check multiple possible locations for jsPDF
            if (window.jsPDF) {
                // If it's an object with jsPDF constructor inside, extract it
                if (typeof window.jsPDF === 'object' && window.jsPDF.jsPDF && typeof window.jsPDF.jsPDF === 'function') {
                    window.jsPDF = window.jsPDF.jsPDF;
                    jsPDFAvailable = true;
                } else if (typeof window.jsPDF === 'function') {
                    jsPDFAvailable = true;
                }
            } else if (window.jspdf && window.jspdf.jsPDF) {
                window.jsPDF = window.jspdf.jsPDF;
                jsPDFAvailable = true;
            } else if (typeof jsPDF !== 'undefined') {
                window.jsPDF = jsPDF;
                jsPDFAvailable = true;
            }
            
            if (!jsPDFAvailable) {
                
                // Try to dynamically load jsPDF with multiple attempts
                for (let attempt = 0; attempt < 2; attempt++) {
                    try {
                        const script = document.createElement('script');
                        script.src = attempt === 0 
                            ? 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js'
                            : 'https://unpkg.com/jspdf@latest/dist/jspdf.umd.min.js';
                        script.crossOrigin = 'anonymous';
                        document.head.appendChild(script);
                        
                        // Wait for script to load
                        await new Promise((resolve, reject) => {
                            script.onload = resolve;
                            script.onerror = reject;
                            setTimeout(reject, 8000); // 8 second timeout per attempt
                        });
                        
                        // Wait for library to initialize and check again
                        await new Promise(resolve => setTimeout(resolve, 1000));
                        
                        // Check multiple possible locations and fix the reference
                        if (window.jsPDF) {
                            // If it's an object with jsPDF property, extract it
                            if (typeof window.jsPDF === 'object' && window.jsPDF.jsPDF && typeof window.jsPDF.jsPDF === 'function') {
                                window.jsPDF = window.jsPDF.jsPDF;
                            }
                            jsPDFAvailable = true;
                            break;
                        } else if (window.jspdf && window.jspdf.jsPDF) {
                            window.jsPDF = window.jspdf.jsPDF;
                            jsPDFAvailable = true;
                            break;
                        }
                        
                    } catch (error) {
                        console.error(`jsPDF load attempt ${attempt + 1} failed:`, error);
                        if (attempt === 1) {
                            generateTextItinerary(itinerary);
                            return;
                        }
                    }
                }
            }
            
            if (!jsPDFAvailable || !window.jsPDF) {
                console.error('jsPDF library still not available after all attempts');
                generateTextItinerary(itinerary);
                return;
            }
            
            // Debug: Log what's available in window.jsPDF
            if (window.jsPDF && typeof window.jsPDF === 'object') {
            }
            
            try {
                // Get jsPDF constructor properly
                let jsPDFConstructor;
                if (typeof window.jsPDF === 'function') {
                    jsPDFConstructor = window.jsPDF;
                } else if (window.jsPDF && typeof window.jsPDF.jsPDF === 'function') {
                    jsPDFConstructor = window.jsPDF.jsPDF;
                } else if (window.jspdf && typeof window.jspdf.jsPDF === 'function') {
                    jsPDFConstructor = window.jspdf.jsPDF;
                } else {
                    throw new Error('jsPDF constructor not found');
                }
                
                
                // Create PDF with A4 format
                const doc = new jsPDFConstructor({
                    orientation: 'portrait',
                    unit: 'mm',
                    format: 'a4'
                });
                
                // Comprehensive text cleaning function
                function cleanText(text) {
                    if (!text) return '';
                    
                    let cleaned = text
                        // Remove HTML tags first
                        .replace(/<[^>]*>/g, '')
                        // Extract venue names from venue tags
                        .replace(/\[VENUE\]\*\*(.*?)\*\*\|.*?\[\/VENUE\]/g, '$1')
                        // Remove markdown formatting
                        .replace(/\*\*(.*?)\*\*/g, '$1')
                        .replace(/\*(.*?)\*/g, '$1')
                        // Remove all emoji ranges (comprehensive)
                        .replace(/[\u{1F600}-\u{1F64F}]/gu, '') // Emoticons
                        .replace(/[\u{1F300}-\u{1F5FF}]/gu, '') // Misc Symbols
                        .replace(/[\u{1F680}-\u{1F6FF}]/gu, '') // Transport
                        .replace(/[\u{1F1E0}-\u{1F1FF}]/gu, '') // Flags
                        .replace(/[\u{2600}-\u{26FF}]/gu, '')   // Misc symbols
                        .replace(/[\u{2700}-\u{27BF}]/gu, '')   // Dingbats
                        .replace(/[\u{FE00}-\u{FE0F}]/gu, '')   // Variation Selectors
                        .replace(/[\u{1F900}-\u{1F9FF}]/gu, '') // Supplemental Symbols
                        // Clean up HTML entities
                        .replace(/&amp;/g, '&')
                        .replace(/&lt;/g, '<')
                        .replace(/&gt;/g, '>')
                        .replace(/&quot;/g, '"')
                        .replace(/&#39;/g, "'")
                        .replace(/&nbsp;/g, ' ')
                        // Remove problematic characters that cause PDF issues
                        .replace(/[^\x20-\x7E\u00A0-\u00FF\u0100-\u017F\u0180-\u024F]/g, '')
                        // Normalize whitespace
                        .replace(/\s+/g, ' ')
                        .trim();
                    
                    return cleaned;
                }
                
                // Improved text addition function with better spacing control
                function addText(doc, text, x, y, maxWidth, options = {}) {
                    const { 
                        fontSize = 10, 
                        fontStyle = 'normal', 
                        lineHeight = null,
                        marginBottom = 0
                    } = options;
                    
                    // Set font properties
                    doc.setFontSize(fontSize);
                    doc.setFont('helvetica', fontStyle);
                    
                    if (!text || text.trim() === '') {
                        return y + (lineHeight || fontSize * 1.2) + marginBottom;
                    }
                    
                    // Clean text thoroughly
                    const cleanedText = cleanText(text);
                    if (!cleanedText) {
                        return y + (lineHeight || fontSize * 1.2) + marginBottom;
                    }
                    
                    const actualLineHeight = lineHeight || (fontSize * 1.2);
                    let currentY = y;
                    
                    // Manual word wrapping with better control
                    const words = cleanedText.split(' ');
                    let currentLine = '';
                    const availableWidth = maxWidth - 5; // Small buffer
                    
                    for (let i = 0; i < words.length; i++) {
                        const word = words[i];
                        const testLine = currentLine + (currentLine ? ' ' : '') + word;
                        const testWidth = doc.getStringUnitWidth(testLine) * fontSize / doc.internal.scaleFactor;
                        
                        if (testWidth > availableWidth && currentLine !== '') {
                            // Line is too long, output current line and start new one
                            if (currentY > pageHeight - 40) {
                                doc.addPage();
                                currentY = 30;
                            }
                            
                            doc.text(currentLine, x, currentY);
                            currentY += actualLineHeight;
                            currentLine = word;
                        } else {
                            currentLine = testLine;
                        }
                    }
                    
                    // Output the last line
                    if (currentLine) {
                        if (currentY > pageHeight - 40) {
                            doc.addPage();
                            currentY = 30;
                        }
                        doc.text(currentLine, x, currentY);
                        currentY += actualLineHeight;
                    }
                    
                    return currentY + marginBottom;
                }
                
                const pageHeight = doc.internal.pageSize.height;
                const pageWidth = doc.internal.pageSize.width;
                const margins = { left: 20, right: 20, top: 25, bottom: 20 };
                const maxWidth = pageWidth - margins.left - margins.right;
                
                // Professional document header with enhanced styling
                const title = cleanText(itinerary.title || 'Travel Itinerary');
                
                // Add subtle header background
                doc.setFillColor(248, 250, 252);
                doc.rect(margins.left - 5, margins.top - 10, maxWidth + 10, 35, 'F');
                
                // Main title with enhanced typography
                doc.setFontSize(20);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(30, 41, 59);
                let yPosition = margins.top + 5;
                doc.text(title, margins.left, yPosition);
                yPosition += 25;
                
                // Generation date with refined styling
                doc.setFontSize(9);
                doc.setFont('helvetica', 'normal');
                doc.setTextColor(100, 116, 139);
                doc.text(`Generated on ${new Date().toLocaleDateString('en-GB')}`, margins.left, yPosition);
                yPosition += 15;
                
                // Elegant separator with gradient effect
                doc.setLineWidth(1.5);
                doc.setDrawColor(59, 130, 246);
                doc.line(margins.left, yPosition, pageWidth - margins.right, yPosition);
                doc.setLineWidth(0.5);
                doc.setDrawColor(147, 197, 253);
                doc.line(margins.left, yPosition + 1, pageWidth - margins.right, yPosition + 1);
                
                // Add table of contents for multi-day itineraries
                if (itinerary.days && itinerary.days.length > 2) {
                    // Table of contents header
                    doc.setFontSize(12);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(30, 41, 59);
                    doc.text('Itinerary Overview', margins.left, yPosition);
                    yPosition += 15;
                    
                    // List each day
                    itinerary.days.forEach((day, index) => {
                        const dayTitle = cleanText(day.title || day.day || `Day ${index + 1}`);
                        const shortTitle = dayTitle.length > 60 ? dayTitle.substring(0, 57) + '...' : dayTitle;
                        
                        doc.setFontSize(10);
                        doc.setFont('helvetica', 'normal');
                        doc.setTextColor(71, 85, 105);
                        
                        // Day number dot
                        doc.setFillColor(59, 130, 246);
                        doc.circle(margins.left + 5, yPosition + 2, 2, 'F');
                        
                        doc.text(shortTitle, margins.left + 15, yPosition + 4);
                        yPosition += 12;
                    });
                    
                    yPosition += 15;
                }
                
                // Reset text color for body
                doc.setTextColor(0, 0, 0);
                
                // Process each day with clean, simple formatting
                itinerary.days.forEach((day, dayIndex) => {
                    // Check if we need a new page for day title
                    if (yPosition > pageHeight - 80) {
                        doc.addPage();
                        yPosition = margins.top;
                    }
                    
                    // Enhanced day header with professional styling
                    const dayTitle = cleanText(day.title || day.day || `Day ${dayIndex + 1}`);
                    
                    // Clean day header layout
                    doc.setFontSize(14);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(30, 41, 59);
                    doc.text(`Day ${dayIndex + 1}: ${dayTitle}`, margins.left, yPosition);
                    
                    // Reset text color
                    doc.setTextColor(0, 0, 0);
                    yPosition += 18;
                    
                    // Process activities
                    if (day.activities && day.activities.length > 0) {
                        day.activities.forEach((activity, actIndex) => {
                            // Check for page break
                            if (yPosition > pageHeight - 60) {
                                doc.addPage();
                                yPosition = margins.top;
                            }
                            
                            let activityText = '';
                            
                            // Parse activity
                            if (typeof activity === 'string') {
                                activityText = cleanText(activity);
                            } else if (activity && typeof activity === 'object') {
                                const time = cleanText(activity.time || '');
                                const desc = cleanText(activity.description || activity.activity || '');
                                activityText = time ? `${time} ${desc}` : desc;
                            }
                            
                            if (activityText) {
                                // Simple, clean activity formatting
                                const timeMatch = activityText.match(/^(\d{1,2}:\d{2}\s*(?:AM|PM)?)\s*[-:]?\s*/i);
                                
                                if (timeMatch) {
                                    const timeText = timeMatch[1];
                                    const descText = activityText.replace(timeMatch[0], '').trim();
                                    
                                    // Format as: Time - Description
                                    doc.setFontSize(10);
                                    doc.setFont('helvetica', 'normal');
                                    doc.setTextColor(0, 0, 0);
                                    
                                    const fullText = descText ? `${timeText} - ${descText}` : timeText;
                                    yPosition = addText(doc, `• ${fullText}`, margins.left + 10, yPosition, maxWidth - 15, {
                                        fontSize: 10,
                                        fontStyle: 'normal',
                                        lineHeight: 12,
                                        marginBottom: 4
                                    });
                                } else {
                                    // No time found, format as bullet point
                                    doc.setFontSize(10);
                                    doc.setFont('helvetica', 'normal');
                                    doc.setTextColor(0, 0, 0);
                                    yPosition = addText(doc, `• ${activityText}`, margins.left + 10, yPosition, maxWidth - 15, {
                                        fontSize: 10,
                                        fontStyle: 'normal',
                                        lineHeight: 12,
                                        marginBottom: 4
                                    });
                                }
                            }
                        });
                    }
                    
                    // Add daily tip with clean formatting
                    if (day.dailyTip) {
                        if (yPosition > pageHeight - 40) {
                            doc.addPage();
                            yPosition = margins.top;
                        }
                        
                        yPosition += 8;
                        
                        // Add tip content with simple formatting
                        const tipText = cleanText(day.dailyTip);
                        doc.setFontSize(10);
                        doc.setFont('helvetica', 'italic');
                        doc.setTextColor(0, 0, 0);
                        yPosition = addText(doc, `Tip: ${tipText}`, margins.left + 10, yPosition, maxWidth - 20, {
                            fontSize: 10,
                            fontStyle: 'italic',
                            lineHeight: 12,
                            marginBottom: 10
                        });
                    }
                    
                    yPosition += 20; // Space between days
                });
                
                // Add simple footer to all pages
                const totalPages = doc.internal.getNumberOfPages();
                for (let i = 1; i <= totalPages; i++) {
                    doc.setPage(i);
                    
                    // Simple footer line
                    doc.setLineWidth(0.5);
                    doc.setDrawColor(150, 150, 150);
                    doc.line(margins.left, pageHeight - 20, pageWidth - margins.right, pageHeight - 20);
                    
                    // Page number only
                    doc.setFontSize(8);
                    doc.setFont('helvetica', 'normal');
                    doc.setTextColor(100, 100, 100);
                    doc.text(`Page ${i} of ${totalPages}`, pageWidth / 2 - 15, pageHeight - 10);
                }
                
                // Save the PDF
                const filename = `${title.replace(/[^a-z0-9\s]/gi, '').replace(/\s+/g, '_').toLowerCase()}.pdf`;
                doc.save(filename);
                
            } catch (error) {
                console.error('PDF generation error:', error);
                throw new Error(`PDF generation failed: ${error.message}`);
            }
        }

        // Fallback text-based itinerary generator
        function generateTextItinerary(itinerary) {
            
            // Show user notification about fallback
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed; top: 20px; right: 20px; z-index: 9999;
                background: #fbbf24; color: #92400e; padding: 12px 16px;
                border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                max-width: 300px; font-size: 14px; line-height: 1.4;
            `;
            notification.innerHTML = `
                <strong>PDF Not Available</strong><br>
                Downloading text version instead. For PDF, try refreshing the page.
            `;
            document.body.appendChild(notification);
            setTimeout(() => notification.remove(), 5000);
            
            function cleanText(text) {
                if (!text) return '';
                return text
                    .replace(/<[^>]*>/g, '')
                    .replace(/\[VENUE\]\*\*(.*?)\*\*\|.*?\[\/VENUE\]/g, '$1')
                    .replace(/\*\*(.*?)\*\*/g, '$1')
                    .replace(/[\u{1F300}-\u{1F9FF}]/gu, '')
                    .replace(/\s+/g, ' ')
                    .trim();
            }
            
            let content = '';
            content += `${cleanText(itinerary.title || 'Travel Itinerary')}\n`;
            content += `Generated on: ${new Date().toLocaleDateString()}\n`;
            content += '='.repeat(50) + '\n\n';
            
            itinerary.days.forEach((day, index) => {
                content += `${cleanText(day.title)}\n`;
                content += '-'.repeat(30) + '\n';
                
                day.activities.forEach(activity => {
                    content += `${activity.time || 'TBD'}: ${cleanText(activity.description)}\n\n`;
                });
                
                if (day.dailyTip) {
                    content += `Tip: ${cleanText(day.dailyTip)}\n\n`;
                }
                
                content += '\n';
            });
            
            // Create and download text file
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${cleanText(itinerary.title || 'itinerary').replace(/[^a-z0-9\s]/gi, '').replace(/\s+/g, '_').toLowerCase()}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
        }

        async function redirectToCheckout() {
            if (!auth.currentUser) {
                showModal('auth-modal');
                return;
            }
            
            try {
                // Add timeout to the fetch request
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout
                
                // Request checkout URL from backend for better security
                const response = await fetch(`${BACKEND_URL}/api/create-checkout`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${await auth.currentUser.getIdToken()}`
                    },
                    body: JSON.stringify({
                        userId: auth.currentUser.uid,
                        userEmail: auth.currentUser.email,
                        plan: 'pro'
                    }),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (data.checkoutUrl) {
                    // Redirect to Stripe checkout
                    window.open(data.checkoutUrl, '_blank');
                } else {
                    throw new Error('No checkout URL received from server');
                }
                
            } catch (error) {
                console.error('Checkout error:', error);
                
                // Fallback: Direct Payment Link (for when backend is unavailable)
                const FALLBACK_PAYMENT_LINK = 'https://buy.stripe.com/cNi28s7BH7iC7kockd6sw00';
                
                
                // Show user-friendly message
                const fallbackMessage = error.name === 'AbortError' 
                    ? 'Server is taking too long to respond. Redirecting to secure payment...'
                    : 'Server temporarily unavailable. Redirecting to secure payment...';
                    
                // Optional: Show a brief notification
                console.log(fallbackMessage);
                
                // Redirect to fallback payment link
                window.open(FALLBACK_PAYMENT_LINK, '_blank');
            }
        }

        // --- Edit Functionality Functions ---
        function enterEditMode() {
            
            isEditMode = true;
            
            // Show/hide buttons
            $('#edit-itinerary-btn').classList.add('hidden');
            $('#save-changes-btn').classList.remove('hidden');
            $('#cancel-edit-btn').classList.remove('hidden');
            
            // Make title editable
            $('#itinerary-detail-title').contentEditable = true;
            $('#itinerary-detail-title').classList.add('border-b-2', 'border-blue-300', 'focus:outline-none', 'focus:border-blue-500', 'px-2', 'py-1', 'rounded');
            
            // Make content editable with enhanced controls
            const dayBlocks = document.querySelectorAll('#itinerary-detail-modal .day-block');
            dayBlocks.forEach((dayBlock, dayIndex) => {
                // Add day-level drag functionality
                setupDayReorderButtons(dayBlock);
                
                // Make day title editable
                const titleElement = dayBlock.querySelector('.day-title');
                if (titleElement) {
                    titleElement.contentEditable = true;
                    titleElement.classList.add('border-b', 'border-gray-300', 'focus:outline-none', 'focus:border-blue-500', 'px-2', 'py-1', 'rounded');
                }
                
                // Make daily tip editable if it exists
                const dailyTipContent = dayBlock.querySelector('.tip-content .text-amber-800:not(.font-semibold)');
                if (dailyTipContent) {
                    dailyTipContent.contentEditable = true;
                    dailyTipContent.classList.add('focus:outline-none', 'focus:ring-2', 'focus:ring-blue-500', 'focus:ring-opacity-50', 'rounded', 'p-1');
                }
                
                // Find the activities container (time-list)
                const activitiesContainer = dayBlock.querySelector('.time-list');
                if (activitiesContainer) {
                    // Make existing activities editable and sortable
                    const activityItems = activitiesContainer.querySelectorAll('.activity-item');
                    
                    activityItems.forEach((activityItem, index) => {
                        // Skip if already wrapped for editing
                        if (activityItem.classList.contains('edit-wrapped')) {
                            return;
                        }
                        
                        wrapActivityForEditing(activityItem, index);
                    });
                    
                    // Add "Add Activity" button to each day
                    const addActivityBtn = document.createElement('button');
                    addActivityBtn.innerHTML = `
                        <i data-lucide="plus" class="w-4 h-4 mr-1"></i>
                        Add Activity
                    `;
                    addActivityBtn.className = 'flex items-center gap-1 text-blue-600 hover:text-blue-800 text-sm font-medium mt-3 px-3 py-2 border border-blue-200 rounded-lg hover:bg-blue-50 transition-colors duration-200';
                    addActivityBtn.onclick = () => addNewActivity(activitiesContainer);
                    activitiesContainer.appendChild(addActivityBtn);
                    
                    // Make activities container sortable
                    makeSortable(activitiesContainer);
                }
            });
            
            // Add edit indicators
            $('#itinerary-detail-content').classList.add('border-2', 'border-blue-200', 'rounded-lg', 'edit-mode');
            
            // Set up modal-level drag listeners for auto-scroll and day dragging
            setupModalDragListeners();
            
            // Add global edit instructions
            const editInstructions = document.createElement('div');
            editInstructions.id = 'edit-instructions';
            editInstructions.className = 'bg-blue-50 border border-blue-200 rounded-lg p-3 mb-4 text-sm text-blue-800';
            editInstructions.innerHTML = `
                <div class="flex items-start gap-3">
                    <i data-lucide="info" class="w-5 h-5 mt-0.5 text-blue-600"></i>
                    <div class="space-y-1">
                        <div><strong class="text-blue-900">Edit Mode Active:</strong></div>
                        <ul class="text-blue-700 space-y-1 text-sm">
                            <li>• <strong>Edit text:</strong> Click on any text to modify</li>
                            <li>• <strong>Reorder days:</strong> Use the blue up/down arrow buttons at the top of each day</li>
                            <li>• <strong>Reorder activities:</strong> Use the green up/down arrow buttons next to each activity</li>
                            <li>• <strong>Add activities:</strong> Click the + button in any day</li>
                            <li>• <strong>Remove activities:</strong> Click the <i data-lucide="trash-2" class="w-3 h-3 inline mx-1"></i> icon</li>
                        </ul>
                    </div>
                </div>
            `;
            $('#itinerary-detail-content').prepend(editInstructions);
            
            // Initialize Lucide icons for new elements
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }

        function autoSaveChanges() {
            
            if (!isEditMode || !currentEditingItinerary || !currentItineraryId) {
                console.error('Cannot auto-save - missing required data');
                return;
            }
            
            try {
                // Update the itinerary object directly with current data
                const updatedItinerary = {
                    ...currentEditingItinerary,
                    lastModified: new Date().toISOString()
                };
                
                
                // Save to storage without exiting edit mode
                saveEditedItinerary(currentItineraryId, updatedItinerary, false); // false = don't exit edit mode
                
            } catch (error) {
                console.error('Error auto-saving itinerary:', error);
                showTemporaryMessage('Error auto-saving changes. Please try again.', 'error');
            }
        }

        function saveItineraryChanges() {
            
            if (!isEditMode || !currentEditingItinerary || !currentItineraryId) {
                console.error('Cannot save - missing required data');
                return;
            }
            
            try {
                // Extract updated data
                const updatedTitle = $('#itinerary-detail-title').textContent.trim();
                const dayBlocks = document.querySelectorAll('#itinerary-detail-modal .day-block');
                
                const updatedDays = [];
                dayBlocks.forEach((dayBlock, index) => {
                    const titleElement = dayBlock.querySelector('.day-title');
                    const activitiesContainer = dayBlock.querySelector('.time-list');
                    const tipElement = dayBlock.querySelector('.tip-content .text-amber-800:not(.font-semibold)');
                    
                    if (titleElement && activitiesContainer) {
                        const dayTitle = titleElement.textContent.trim();
                        
                        // Get activities from activity items
                        const activityItems = activitiesContainer.querySelectorAll('.activity-item');
                        const dayActivities = [];
                        
                        activityItems.forEach(activityItem => {
                            const timeBadge = activityItem.querySelector('.badge-time');
                            const descriptionElement = activityItem.querySelector('.activity-description p');
                            
                            if (timeBadge && descriptionElement) {
                                dayActivities.push({
                                    time: timeBadge.textContent.trim(),
                                    description: descriptionElement.textContent.trim()
                                });
                            }
                        });
                        
                        const dayData = {
                            title: dayTitle,
                            activities: dayActivities
                        };
                        
                        // Add tip if exists
                        if (tipElement) {
                            dayData.dailyTip = tipElement.textContent.trim();
                        }
                        
                        updatedDays.push(dayData);
                    }
                });
                
                // Update the itinerary object
                const updatedItinerary = {
                    ...currentEditingItinerary,
                    title: updatedTitle,
                    days: updatedDays,
                    lastModified: new Date().toISOString()
                };
                
                
                // Save to storage
                saveEditedItinerary(currentItineraryId, updatedItinerary);
                
                // Exit edit mode
                exitEditMode();
                
                // Show success message
                showTemporaryMessage('Changes saved successfully!', 'success');
                
            } catch (error) {
                console.error('Error saving changes:', error);
                alert('Failed to save changes. Please try again.');
            }
        }

        function cancelEditMode() {
            if (!currentEditingItinerary) return;
            
            // Restore original content
            $('#itinerary-detail-title').textContent = currentEditingItinerary.title || 'Itinerary Details';
            $('#itinerary-detail-content').innerHTML = renderItineraryHTML(currentEditingItinerary);
            
            // Exit edit mode
            exitEditMode();
            
            // Re-initialize Lucide icons
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }

        function wrapActivityForEditing(activityItem, index) {
            // Skip if already wrapped for editing or already has reorder buttons
            if (activityItem.classList.contains('edit-wrapped') || activityItem.querySelector('.activity-reorder-buttons')) {
                return;
            }
            
            // Mark as wrapped to avoid double processing
            activityItem.classList.add('edit-wrapped');
            
            // Find the time badge and description elements
            const timeBadge = activityItem.querySelector('.badge-time');
            const activityDescription = activityItem.querySelector('.activity-description p');
            
            // Make time badge editable
            if (timeBadge) {
                timeBadge.contentEditable = true;
                timeBadge.classList.add('focus:outline-none', 'focus:ring-2', 'focus:ring-blue-500', 'focus:ring-opacity-50', 'rounded', 'px-2', 'py-1');
            }
            
            // Make description editable
            if (activityDescription) {
                activityDescription.contentEditable = true;
                activityDescription.classList.add('focus:outline-none', 'focus:ring-2', 'focus:ring-blue-500', 'focus:ring-opacity-50', 'rounded', 'min-h-[2rem]', 'p-2');
            }
            
            // Add activity reorder buttons
            const reorderButtons = document.createElement('div');
            reorderButtons.className = 'activity-reorder-buttons';
            
            const dayContainer = activityItem.closest('.time-list') || activityItem.parentElement;
            if (!dayContainer) {
                console.error('Could not find activities container for activity item');
                return;
            }
            
            const activities = Array.from(dayContainer.children);
            const currentIndex = activities.indexOf(activityItem);
            
            reorderButtons.innerHTML = `
                <button type="button" class="activity-reorder-btn move-up" ${currentIndex === 0 ? 'disabled' : ''} title="Move up">
                    <i data-lucide="chevron-up" class="w-3 h-3"></i>
                </button>
                <button type="button" class="activity-reorder-btn move-down" ${currentIndex === activities.length - 1 ? 'disabled' : ''} title="Move down">
                    <i data-lucide="chevron-down" class="w-3 h-3"></i>
                </button>
            `;
            
            // Insert reorder buttons at the start of the activity item
            const firstChild = activityItem.firstElementChild;
            activityItem.insertBefore(reorderButtons, firstChild);
            activityItem.style.display = 'flex';
            activityItem.style.alignItems = 'flex-start';
            activityItem.style.gap = '8px';

            // Add edit controls
            const controls = document.createElement('div');
            controls.className = 'edit-controls flex items-center justify-between mt-2 opacity-0 group-hover:opacity-100 transition-all duration-200';
            controls.innerHTML = `
                <div class="flex items-center gap-3">
                    <span class="text-sm text-gray-600 font-medium bg-gray-100 px-2 py-1 rounded-full">Activity ${index + 1}</span>
                </div>
                <button type="button" class="remove-activity text-red-400 hover:text-red-600 hover:bg-red-50 p-2 rounded-md transition-all duration-200" title="Remove this activity">
                    <i data-lucide="trash-2" class="w-4 h-4"></i>
                </button>
            `;
            
            // Add controls to the activity item
            activityItem.appendChild(controls);
            
            // Add visual feedback
            activityItem.classList.add('group', 'hover:shadow-md', 'transition-all', 'duration-300', 'border-2', 'border-blue-200', 'hover:border-blue-400', 'rounded-xl', 'relative', 'bg-gradient-to-r', 'from-blue-50', 'to-indigo-50', 'hover:from-blue-100', 'hover:to-indigo-100', 'p-4', 'my-2');
            
            
            // Add event listeners
            const removeBtn = controls.querySelector('.remove-activity');
            removeBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                removeActivity(activityItem);
            });
            
            // Add reorder button event listeners
            const moveUpBtn = reorderButtons.querySelector('.move-up');
            const moveDownBtn = reorderButtons.querySelector('.move-down');
            
            if (moveUpBtn) {
                moveUpBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    moveActivityUp(activityItem);
                });
            }
            
            if (moveDownBtn) {
                moveDownBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    moveActivityDown(activityItem);
                });
            }

        }

        function addNewActivity(container) {
            // Create new activity with the same structure as existing ones
            const newActivity = document.createElement('div');
            newActivity.className = 'activity-item group';
            newActivity.innerHTML = `
                <div class="flex items-start gap-4">
                    <div class="time-badge-container flex-shrink-0">
                        <span class="badge-time inline-block bg-blue-600 text-white px-4 py-2 rounded-full text-sm font-semibold shadow-sm">9:00 AM</span>
                    </div>
                    <div class="activity-content flex-grow min-w-0">
                        <div class="activity-description text-gray-700 text-base leading-7 font-normal">
                            <p class="mb-0 text-justify hyphens-auto break-words">New activity - click to edit description</p>
                        </div>
                    </div>
                </div>
            `;
            
            // Get current activity count (excluding the add button)
            const currentActivities = container.querySelectorAll('.activity-item:not(.edit-wrapped)').length;
            
            // Insert before the "Add Activity" button
            const addButton = container.querySelector('button');
            container.insertBefore(newActivity, addButton);
            
            // Wrap for editing immediately
            wrapActivityForEditing(newActivity, currentActivities);
            
            // Initialize Lucide icons
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
            
            // Focus the new activity description for immediate editing
            setTimeout(() => {
                const descriptionElement = newActivity.querySelector('.activity-description p');
                if (descriptionElement) {
                    descriptionElement.focus();
                    // Select all text for easy replacement
                    if (window.getSelection) {
                        const selection = window.getSelection();
                        const range = document.createRange();
                        range.selectNodeContents(descriptionElement);
                        selection.removeAllRanges();
                        selection.addRange(range);
                    }
                }
            }, 100);
        }

        function removeActivity(activityWrapper) {
            if (confirm('Remove this activity?')) {
                activityWrapper.remove();
                // Renumber remaining activities
                const container = activityWrapper.parentNode;
                if (container) {
                    renumberActivities(container);
                }
            }
        }

        function renumberActivities(container) {
            const activities = container.querySelectorAll('.activity-item');
            activities.forEach((activity, index) => {
                const numberSpan = activity.querySelector('.text-sm.text-gray-600');
                if (numberSpan) {
                    numberSpan.textContent = `Activity ${index + 1}`;
                }
            });
        }



        // Day-level drag and drop functions
        function handleDayDragStart(e) {
            draggedDay = this;
            
            // Add dragging class for visual feedback
            this.classList.add('day-dragging');
            
            // Set drag effect
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.outerHTML);
            
            // Create drop indicators for all potential drop zones
            const container = this.parentNode;
            const allDays = Array.from(container.querySelectorAll('.day-block'));
            
            allDays.forEach((day, index) => {
                if (day !== this) {
                    // Add indicator before each day
                    const indicator = createDayDropIndicator();
                    day.parentNode.insertBefore(indicator, day);
                    dayDropIndicators.push(indicator);
                }
            });
            
            // Add indicator at the end
            const lastIndicator = createDayDropIndicator();
            container.appendChild(lastIndicator);
            dayDropIndicators.push(lastIndicator);
            
        }

        function handleDayDrop(e) {
            e.preventDefault();
            
            if (!draggedDay) return;
            
            const container = draggedDay.parentNode;
            const allDays = Array.from(container.querySelectorAll('.day-block:not(.day-dragging)'));
            
            let targetDay = null;
            let insertBefore = true;
            let closestDistance = Infinity;
            
            const mouseY = e.clientY;
            
            // Find the closest day to where we're dropping
            allDays.forEach(day => {
                const rect = day.getBoundingClientRect();
                const dayCenter = rect.top + rect.height / 2;
                const distance = Math.abs(mouseY - dayCenter);
                
                if (distance < closestDistance) {
                    closestDistance = distance;
                    targetDay = day;
                    insertBefore = mouseY < dayCenter;
                }
            });
            
            // Perform the move
            if (targetDay) {
                if (insertBefore) {
                    container.insertBefore(draggedDay, targetDay);
                } else {
                    // Insert after the target day
                    const nextSibling = targetDay.nextElementSibling;
                    if (nextSibling && nextSibling.classList.contains('day-block')) {
                        container.insertBefore(draggedDay, nextSibling);
                    } else {
                        container.appendChild(draggedDay);
                    }
                }
            } else {
                // No days in container, just add to beginning
                const firstChild = container.firstElementChild;
                container.insertBefore(draggedDay, firstChild);
            }
            
            // Renumber days
            renumberDays(container);
        }

        function renumberDays(container) {
            const days = container.querySelectorAll('.day-block');
            days.forEach((day, index) => {
                const dayTitle = day.querySelector('.day-title');
                if (dayTitle) {
                    const titleText = dayTitle.textContent;
                    // Update day number in title (e.g., "Day 1", "Day 2", etc.)
                    const updatedTitle = titleText.replace(/Day \d+/i, `Day ${index + 1}`);
                    dayTitle.textContent = updatedTitle;
                }
            });
        }

        function setupDayReorderButtons(dayBlock) {
            // Skip if already set up
            if (dayBlock.classList.contains('reorder-setup') || dayBlock.querySelector('.day-reorder-buttons')) return;
            
            dayBlock.classList.add('reorder-setup');
            
            // Create day reorder buttons
            const reorderButtons = document.createElement('div');
            reorderButtons.className = 'day-reorder-buttons';
            
            const modal = dayBlock.closest('#itinerary-detail-modal') || dayBlock.closest('.fixed');
            if (!modal) {
                console.error('Could not find modal container for day block');
                return;
            }
            
            const dayContainer = modal.querySelector('#itinerary-detail-content') || dayBlock.parentElement;
            if (!dayContainer) {
                console.error('Could not find day container');
                return;
            }
            
            const days = Array.from(dayContainer.querySelectorAll('.day-block'));
            const currentIndex = days.indexOf(dayBlock);
            
            reorderButtons.innerHTML = `
                <button type="button" class="day-reorder-btn move-day-up" ${currentIndex === 0 ? 'disabled' : ''} title="Move day up">
                    <i data-lucide="chevron-up" class="w-4 h-4"></i>
                </button>
                <button type="button" class="day-reorder-btn move-day-down" ${currentIndex === days.length - 1 ? 'disabled' : ''} title="Move day down">
                    <i data-lucide="chevron-down" class="w-4 h-4"></i>
                </button>
            `;
            
            // Insert reorder buttons at the top of the day block
            const firstChild = dayBlock.firstElementChild;
            dayBlock.insertBefore(reorderButtons, firstChild);
            
            // Add event handlers for reorder buttons
            const moveUpBtn = reorderButtons.querySelector('.move-day-up');
            const moveDownBtn = reorderButtons.querySelector('.move-day-down');
            
            if (moveUpBtn) {
                moveUpBtn.addEventListener('click', () => moveDayUp(dayBlock));
            }
            
            if (moveDownBtn) {
                moveDownBtn.addEventListener('click', () => moveDayDown(dayBlock));
            }
            
            // Initialize Lucide icons
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
            
        }

        // Enhanced drag and drop functionality
        let draggedElement = null;
        let draggedDay = null;
        let dropIndicators = [];
        let dayDropIndicators = [];
        let autoScrollInterval = null;
        let scrollIndicator = null;

        function createDropIndicator() {
            const indicator = document.createElement('div');
            indicator.className = 'drop-indicator';
            return indicator;
        }

        function createDayDropIndicator() {
            const indicator = document.createElement('div');
            indicator.className = 'day-drop-indicator';
            return indicator;
        }

        function createScrollIndicator() {
            if (scrollIndicator) return scrollIndicator;
            
            scrollIndicator = document.createElement('div');
            scrollIndicator.className = 'scroll-indicator';
            scrollIndicator.innerHTML = '<i data-lucide="arrow-up-down" class="w-4 h-4 inline mr-2"></i>Auto-scrolling...';
            document.body.appendChild(scrollIndicator);
            
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
            
            return scrollIndicator;
        }

        function startAutoScroll(direction, speed = 2, container = null) {
            stopAutoScroll();
            
            if (!container) {
                return;
            }
            
            const indicator = createScrollIndicator();
            indicator.classList.add('show');
            
            if (direction === 'up') {
                indicator.style.top = '20px';
                indicator.innerHTML = '<i data-lucide="arrow-up" class="w-4 h-4 inline mr-2"></i>Fast scrolling up...';
            } else {
                indicator.style.bottom = '20px';
                indicator.innerHTML = '<i data-lucide="arrow-down" class="w-4 h-4 inline mr-2"></i>Fast scrolling down...';
            }
            
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
            
            
            let scrollSpeed = Math.max(speed * 10, 15); // Moderate speed
            
            autoScrollInterval = setInterval(() => {
                const scrollAmount = direction === 'up' ? -scrollSpeed : scrollSpeed;
                const oldScrollTop = container.scrollTop;
                
                container.scrollTop += scrollAmount;
                
                // Check if we've reached the limits
                if (direction === 'up' && container.scrollTop <= 0) {
                    stopAutoScroll();
                    return;
                }
                
                if (direction === 'down' && container.scrollTop >= container.scrollHeight - container.clientHeight) {
                    stopAutoScroll();
                    return;
                }
                
                // Gradual acceleration but more controlled
                scrollSpeed = Math.min(scrollSpeed * 1.01, 30);
                
            }, 20); // Slower but more controlled
        }

        function stopAutoScroll() {
            if (autoScrollInterval) {
                clearInterval(autoScrollInterval);
                autoScrollInterval = null;
            }
            
            if (scrollIndicator) {
                scrollIndicator.classList.remove('show');
                // Add a small delay before hiding completely
                setTimeout(() => {
                    if (scrollIndicator && !scrollIndicator.classList.contains('show')) {
                        scrollIndicator.style.opacity = '0';
                    }
                }, 100);
            }
        }

        function checkAutoScroll(e) {
            // Only check if we're actively dragging something
            if (!draggedElement && !draggedDay) {
                stopAutoScroll();
                return;
            }
            
            // Try multiple possible scroll containers
            const possibleContainers = [
                document.querySelector('#itinerary-detail-modal .max-h-96'),
                document.querySelector('#itinerary-detail-modal .overflow-y-auto'),
                document.querySelector('#itinerary-detail-content'),
                document.querySelector('.modal-content')
            ];
            
            let container = null;
            for (const c of possibleContainers) {
                if (c && c.scrollHeight > c.clientHeight) {
                    container = c;
                    break;
                }
            }
            
            if (!container) {
                stopAutoScroll();
                return;
            }
            
            const containerRect = container.getBoundingClientRect();
            const scrollZone = 80; // Larger trigger zone
            
            const mouseY = e.clientY;
            const containerTop = containerRect.top;
            const containerBottom = containerRect.bottom;
            
            // Check if mouse is within the container bounds
            if (mouseY < containerTop - 20 || mouseY > containerBottom + 20) {
                stopAutoScroll();
                return;
            }
            
            if (mouseY < containerTop + scrollZone && container.scrollTop > 0) {
                // Near top edge - scroll up
                const distance = Math.max(1, containerTop + scrollZone - mouseY);
                const speed = Math.min(Math.max(distance / scrollZone * 5, 1), 5);
                startAutoScroll('up', speed, container);
            } else if (mouseY > containerBottom - scrollZone && 
                      container.scrollTop < container.scrollHeight - container.clientHeight) {
                // Near bottom edge - scroll down
                const distance = Math.max(1, mouseY - (containerBottom - scrollZone));
                const speed = Math.min(Math.max(distance / scrollZone * 5, 1), 5);
                startAutoScroll('down', speed, container);
            } else {
                // In neutral zone - stop scrolling
                stopAutoScroll();
            }
        }

        function clearDropIndicators() {
            dropIndicators.forEach(indicator => {
                if (indicator.parentNode) {
                    indicator.parentNode.removeChild(indicator);
                }
            });
            dropIndicators = [];
        }

        function clearDayDropIndicators() {
            dayDropIndicators.forEach(indicator => {
                if (indicator.parentNode) {
                    indicator.parentNode.removeChild(indicator);
                }
            });
            dayDropIndicators = [];
        }

        function getDayAfterElement(container, y) {
            const draggableDays = Array.from(container.querySelectorAll('.day-block:not(.day-dragging)'));
            
            return draggableDays.reduce((closest, day) => {
                const box = day.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: day };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        function handleDragStart(e) {
            draggedElement = this;
            
            // Add dragging class for visual feedback
            this.classList.add('dragging');
            
            // Set drag effect
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.outerHTML);
            
            // Create drop indicators for all potential drop zones in the same container
            const container = this.parentNode;
            const allItems = Array.from(container.querySelectorAll('.activity-item'));
            
            allItems.forEach((item, index) => {
                if (item !== this) {
                    // Add indicator before each item
                    const indicator = createDropIndicator();
                    item.parentNode.insertBefore(indicator, item);
                    dropIndicators.push(indicator);
                }
            });
            
            // Add indicator at the end
            const lastIndicator = createDropIndicator();
            const addButton = container.querySelector('button');
            if (addButton) {
                container.insertBefore(lastIndicator, addButton);
            } else {
                container.appendChild(lastIndicator);
            }
            dropIndicators.push(lastIndicator);
            
        }

        function handleDragOver(e) {
            if (!draggedElement && !draggedDay) return;
            
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            
            // Check for auto-scroll
            checkAutoScroll(e);
            
            if (draggedElement) {
                // Activity drag over - find the closest activity item
                const container = draggedElement.parentNode;
                const allActivities = Array.from(container.querySelectorAll('.activity-item:not(.dragging)'));
                
                let closestActivity = null;
                let closestDistance = Infinity;
                let insertBefore = true;
                
                const mouseY = e.clientY;
                
                allActivities.forEach(activity => {
                    const rect = activity.getBoundingClientRect();
                    const activityCenter = rect.top + rect.height / 2;
                    const distance = Math.abs(mouseY - activityCenter);
                    
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestActivity = activity;
                        insertBefore = mouseY < activityCenter;
                    }
                });
                
                // Clear all indicators
                dropIndicators.forEach(indicator => indicator.classList.remove('show'));
                
                // Show the appropriate indicator
                if (closestActivity) {
                    const indicatorIndex = insertBefore ? 
                        allActivities.indexOf(closestActivity) : 
                        allActivities.indexOf(closestActivity) + 1;
                    
                    if (dropIndicators[indicatorIndex]) {
                        dropIndicators[indicatorIndex].classList.add('show');
                    }
                } else if (dropIndicators.length > 0) {
                    // If no activities, show the first indicator
                    dropIndicators[0].classList.add('show');
                }
                
            } else if (draggedDay) {
                // Day drag over - find the closest day
                const container = draggedDay.parentNode;
                const allDays = Array.from(container.querySelectorAll('.day-block:not(.day-dragging)'));
                
                let closestDay = null;
                let closestDistance = Infinity;
                let insertBefore = true;
                
                const mouseY = e.clientY;
                
                allDays.forEach(day => {
                    const rect = day.getBoundingClientRect();
                    const dayCenter = rect.top + rect.height / 2;
                    const distance = Math.abs(mouseY - dayCenter);
                    
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestDay = day;
                        insertBefore = mouseY < dayCenter;
                    }
                });
                
                // Clear all day indicators
                dayDropIndicators.forEach(indicator => indicator.classList.remove('show'));
                
                // Show the appropriate indicator
                if (closestDay) {
                    const indicatorIndex = insertBefore ? 
                        allDays.indexOf(closestDay) : 
                        allDays.indexOf(closestDay) + 1;
                    
                    if (dayDropIndicators[indicatorIndex]) {
                        dayDropIndicators[indicatorIndex].classList.add('show');
                    }
                } else if (dayDropIndicators.length > 0) {
                    // If no days, show the first indicator
                    dayDropIndicators[0].classList.add('show');
                }
            }
        }

        function getDragAfterElement(container, y) {
            const draggableElements = Array.from(container.querySelectorAll('.activity-item:not(.dragging)'));
            
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        function handleDrop(e) {
            e.preventDefault();
            
            if (draggedElement) {
                // Activity drop
                const container = draggedElement.parentNode;
                const allActivities = Array.from(container.querySelectorAll('.activity-item:not(.dragging)'));
                
                let targetActivity = null;
                let insertBefore = true;
                let closestDistance = Infinity;
                
                const mouseY = e.clientY;
                
                // Find the closest activity to where we're dropping
                allActivities.forEach(activity => {
                    const rect = activity.getBoundingClientRect();
                    const activityCenter = rect.top + rect.height / 2;
                    const distance = Math.abs(mouseY - activityCenter);
                    
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        targetActivity = activity;
                        insertBefore = mouseY < activityCenter;
                    }
                });
                
                // Perform the move
                if (targetActivity) {
                    if (insertBefore) {
                        container.insertBefore(draggedElement, targetActivity);
                    } else {
                        // Insert after the target activity
                        const nextSibling = targetActivity.nextElementSibling;
                        if (nextSibling && nextSibling.classList.contains('activity-item')) {
                            container.insertBefore(draggedElement, nextSibling);
                        } else {
                            // Insert before add button or at end
                            const addButton = container.querySelector('button');
                            if (addButton) {
                                container.insertBefore(draggedElement, addButton);
                            } else {
                                container.appendChild(draggedElement);
                            }
                        }
                    }
                } else {
                    // No activities in container, just add to beginning
                    const firstChild = container.firstElementChild;
                    container.insertBefore(draggedElement, firstChild);
                }
                
                // Renumber activities
                renumberActivities(container);
                
            } else if (draggedDay) {
                // Day drop
                handleDayDrop(e);
            }
        }

        function handleDragEnd(e) {
            // Force stop auto-scroll immediately
            stopAutoScroll();
            
            if (draggedElement) {
                // Remove dragging class
                draggedElement.classList.remove('dragging');
                
                // Clear all visual indicators
                clearDropIndicators();
                
                // Remove any hover effects
                document.querySelectorAll('.drag-over').forEach(el => {
                    el.classList.remove('drag-over');
                });
                
                draggedElement = null;
            }
            
            if (draggedDay) {
                // Remove day dragging class
                draggedDay.classList.remove('day-dragging');
                
                // Clear all day visual indicators
                clearDayDropIndicators();
                
                // Remove any day hover effects
                document.querySelectorAll('.day-drag-over').forEach(el => {
                    el.classList.remove('day-drag-over');
                });
                
                draggedDay = null;
            }
            
            // Double-check that auto-scroll is definitely stopped
            setTimeout(() => {
                stopAutoScroll();
            }, 50);
        }

        function makeSortable(container) {
            // Enable drop on container
            container.addEventListener('dragover', (e) => {
                e.preventDefault();
                
                // Add visual feedback for the container
                if (draggedElement && container.contains(draggedElement)) {
                    container.classList.add('bg-blue-25', 'border-blue-300');
                }
            });
            
            container.addEventListener('dragleave', (e) => {
                // Remove visual feedback when leaving container
                if (!container.contains(e.relatedTarget)) {
                    container.classList.remove('bg-blue-25', 'border-blue-300');
                }
            });
            
            container.addEventListener('drop', handleDrop);
        }

        function setupModalDragListeners() {
            const modal = document.querySelector('#itinerary-detail-modal');
            if (!modal) return;
            
            // Add global drag event listeners to the modal for auto-scroll
            modal.addEventListener('dragover', handleDragOver);
            modal.addEventListener('drop', (e) => {
                if (draggedDay) {
                    handleDayDrop(e);
                } else if (draggedElement) {
                    handleDrop(e);
                }
            });
            
            // Also add to document for better coverage
            document.addEventListener('dragover', (e) => {
                if (draggedElement || draggedDay) {
                    handleDragOver(e);
                } else {
                    stopAutoScroll();
                }
            });
            
            // Add mousemove listener for drag tracking with throttling
            let mouseMoveTimeout = null;
            document.addEventListener('mousemove', (e) => {
                if (draggedElement || draggedDay) {
                    // Throttle mouse move events for better performance
                    if (mouseMoveTimeout) clearTimeout(mouseMoveTimeout);
                    mouseMoveTimeout = setTimeout(() => {
                        checkAutoScroll(e);
                    }, 8); // Check every 8ms for smooth scrolling
                } else {
                    stopAutoScroll();
                }
            });
            
            // Add mouse leave listener to stop scrolling when leaving the window
            document.addEventListener('mouseleave', () => {
                stopAutoScroll();
            });
            
            // Add drag leave listener
            document.addEventListener('dragleave', (e) => {
                // Only stop if we're leaving the document entirely
                if (!e.relatedTarget || e.relatedTarget.nodeType === Node.DOCUMENT_NODE) {
                    stopAutoScroll();
                }
            });
            
            // Add escape key listener to stop auto-scroll
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    stopAutoScroll();
                }
            });
            
        }

        // New reorder functions using buttons instead of drag and drop
        function moveDayUp(dayBlock) {
            const modal = dayBlock.closest('#itinerary-detail-modal') || dayBlock.closest('.fixed');
            if (!modal) return;
            
            const dayContainer = modal.querySelector('#itinerary-detail-content') || dayBlock.parentElement;
            if (!dayContainer) return;
            
            const days = Array.from(dayContainer.querySelectorAll('.day-block'));
            const currentIndex = days.indexOf(dayBlock);
            
            if (currentIndex > 0) {
                // Update data first
                if (currentEditingItinerary && currentEditingItinerary.days) {
                    const dayData = currentEditingItinerary.days.splice(currentIndex, 1)[0];
                    currentEditingItinerary.days.splice(currentIndex - 1, 0, dayData);
                    
                    // Move DOM element manually to avoid full refresh
                    const previousDay = days[currentIndex - 1];
                    const parent = dayBlock.parentNode;
                    parent.insertBefore(dayBlock, previousDay);
                    
                    // Update button states
                    updateDayReorderButtons(dayContainer);
                    
                    // Update day numbers after reordering
                    updateDayNumbers();
                    
                    // Auto-save changes without exiting edit mode
                    autoSaveChanges();
                }
            }
        }

        function moveDayDown(dayBlock) {
            const modal = dayBlock.closest('#itinerary-detail-modal') || dayBlock.closest('.fixed');
            if (!modal) return;
            
            const dayContainer = modal.querySelector('#itinerary-detail-content') || dayBlock.parentElement;
            if (!dayContainer) return;
            
            const days = Array.from(dayContainer.querySelectorAll('.day-block'));
            const currentIndex = days.indexOf(dayBlock);
            
            if (currentIndex < days.length - 1) {
                // Update data first
                if (currentEditingItinerary && currentEditingItinerary.days) {
                    const dayData = currentEditingItinerary.days.splice(currentIndex, 1)[0];
                    currentEditingItinerary.days.splice(currentIndex + 1, 0, dayData);
                    
                    // Move DOM element manually to avoid full refresh
                    const nextDay = days[currentIndex + 1];
                    const parent = dayBlock.parentNode;
                    
                    // Insert current day after the next day
                    const afterNext = nextDay.nextSibling;
                    if (afterNext) {
                        parent.insertBefore(dayBlock, afterNext);
                    } else {
                        parent.appendChild(dayBlock);
                    }
                    
                    // Update button states
                    updateDayReorderButtons(dayContainer);
                    
                    // Update day numbers after reordering
                    updateDayNumbers();
                    
                    // Auto-save changes without exiting edit mode
                    autoSaveChanges();
                }
            }
        }

        function updateDayReorderButtons(dayContainer) {
            const days = Array.from(dayContainer.querySelectorAll('.day-block'));
            days.forEach((day, index) => {
                const moveUpBtn = day.querySelector('.move-day-up');
                const moveDownBtn = day.querySelector('.move-day-down');
                
                if (moveUpBtn) {
                    moveUpBtn.disabled = (index === 0);
                }
                if (moveDownBtn) {
                    moveDownBtn.disabled = (index === days.length - 1);
                }
            });
        }

        function moveActivityUp(activityItem) {
            const activitiesContainer = activityItem.closest('.time-list') || activityItem.parentElement;
            if (!activitiesContainer) return;
            
            const activities = Array.from(activitiesContainer.children);
            const currentIndex = activities.indexOf(activityItem);
            
            if (currentIndex > 0) {
                const previousActivity = activities[currentIndex - 1];
                activitiesContainer.insertBefore(activityItem, previousActivity);
                updateActivityReorderButtons(activitiesContainer);
                
                // Update the itinerary data
                const dayBlock = activitiesContainer.closest('.day-block');
                const dayIndex = getDayIndex(dayBlock);
                if (currentEditingItinerary && currentEditingItinerary.days && currentEditingItinerary.days[dayIndex]) {
                    const activities = currentEditingItinerary.days[dayIndex].activities;
                    const activityData = activities.splice(currentIndex, 1)[0];
                    activities.splice(currentIndex - 1, 0, activityData);
                    
                    // Update activity times after reordering
                    updateActivityTimes(activitiesContainer, dayIndex);
                    autoSaveChanges();
                }
            }
        }

        function moveActivityDown(activityItem) {
            const activitiesContainer = activityItem.closest('.time-list') || activityItem.parentElement;
            if (!activitiesContainer) return;
            
            const activities = Array.from(activitiesContainer.children);
            const currentIndex = activities.indexOf(activityItem);
            
            if (currentIndex < activities.length - 1) {
                const nextActivity = activities[currentIndex + 1];
                activitiesContainer.insertBefore(nextActivity, activityItem);
                updateActivityReorderButtons(activitiesContainer);
                
                // Update the itinerary data
                const dayBlock = activitiesContainer.closest('.day-block');
                const dayIndex = getDayIndex(dayBlock);
                if (currentEditingItinerary && currentEditingItinerary.days && currentEditingItinerary.days[dayIndex]) {
                    const activities = currentEditingItinerary.days[dayIndex].activities;
                    const activityData = activities.splice(currentIndex, 1)[0];
                    activities.splice(currentIndex + 1, 0, activityData);
                    
                    // Update activity times after reordering
                    updateActivityTimes(activitiesContainer, dayIndex);
                    autoSaveChanges();
                }
            }
        }

        // Function to update day numbers after reordering
        function updateDayNumbers() {
            if (!isEditMode) return;
            
            const dayBlocks = document.querySelectorAll('#itinerary-detail-modal .day-block');
            dayBlocks.forEach((dayBlock, index) => {
                const dayTitle = dayBlock.querySelector('.day-title');
                if (dayTitle && currentEditingItinerary && currentEditingItinerary.days[index]) {
                    // Update the visual title to show correct day number
                    const originalTitle = currentEditingItinerary.days[index].title;
                    const baseTitle = originalTitle.replace(/^Day \d+:\s*/, ''); // Remove existing "Day X:" prefix
                    const newTitle = `Day ${index + 1}: ${baseTitle}`;
                    dayTitle.textContent = newTitle;
                    
                    // Update the data as well
                    currentEditingItinerary.days[index].title = newTitle;
                }
            });
        }

        // Function to update activity times after reordering
        function updateActivityTimes(activitiesContainer, dayIndex) {
            if (!isEditMode || !currentEditingItinerary) return;
            
            const activities = Array.from(activitiesContainer.children);
            const baseTime = 9; // Starting at 9:00 AM
            
            activities.forEach((activityElement, index) => {
                const timeBadge = activityElement.querySelector('.badge-time');
                if (timeBadge && currentEditingItinerary.days[dayIndex] && currentEditingItinerary.days[dayIndex].activities[index]) {
                    // Calculate new time (9:00 AM, 11:00 AM, 1:00 PM, etc.)
                    let hour = baseTime + (index * 2);
                    let period = 'AM';
                    
                    if (hour >= 12) {
                        period = 'PM';
                        if (hour > 12) {
                            hour = hour - 12;
                        }
                    }
                    
                    const newTime = `${hour}:00 ${period}`;
                    
                    // Update the visual time badge
                    timeBadge.textContent = newTime;
                    
                    // Update the data as well
                    currentEditingItinerary.days[dayIndex].activities[index].time = newTime;
                }
            });
        }

        function updateActivityReorderButtons(activitiesContainer) {
            const activities = Array.from(activitiesContainer.children);
            activities.forEach((activity, index) => {
                const moveUpBtn = activity.querySelector('.move-up');
                const moveDownBtn = activity.querySelector('.move-down');
                
                if (moveUpBtn) {
                    moveUpBtn.disabled = (index === 0);
                }
                if (moveDownBtn) {
                    moveDownBtn.disabled = (index === activities.length - 1);
                }
            });
        }

        function getDayIndex(dayBlock) {
            const modal = dayBlock.closest('#itinerary-detail-modal') || dayBlock.closest('.fixed');
            if (!modal) return -1;
            
            const dayContainer = modal.querySelector('#itinerary-detail-content') || dayBlock.parentElement;
            if (!dayContainer) return -1;
            
            const days = Array.from(dayContainer.querySelectorAll('.day-block'));
            return days.indexOf(dayBlock);
        }

        function refreshItineraryDisplay() {
            if (!currentEditingItinerary) return;
            
            // Store current edit mode state
            const wasInEditMode = isEditMode;
            
            // Re-render the itinerary content with the updated data
            const contentDiv = $('#itinerary-detail-content');
            if (contentDiv) {
                contentDiv.innerHTML = renderItineraryHTML(currentEditingItinerary);
                
                // Restore edit mode state
                if (wasInEditMode) {
                    isEditMode = true;
                    
                    // Re-setup edit functionality without changing button visibility
                    const dayBlocks = document.querySelectorAll('#itinerary-detail-modal .day-block');
                    dayBlocks.forEach(dayBlock => {
                        setupDayReorderButtons(dayBlock);
                        
                        // Re-wrap activities for editing
                        const activities = dayBlock.querySelectorAll('.activity-item');
                        activities.forEach((activity, index) => {
                            wrapActivityForEditing(activity, index);
                        });
                    });
                    
                    // Restore title editability
                    const title = $('#itinerary-detail-title');
                    if (title) {
                        title.contentEditable = true;
                        title.classList.add('border-b-2', 'border-blue-300', 'focus:outline-none', 'focus:border-blue-500', 'px-2', 'py-1', 'rounded');
                    }
                    
                    // Reinitialize Lucide icons
                    if (typeof lucide !== 'undefined') {
                        lucide.createIcons();
                    }
                }
            }
        }

        function exitEditMode() {
            isEditMode = false;
            
            // Show/hide buttons
            $('#edit-itinerary-btn').classList.remove('hidden');
            $('#save-changes-btn').classList.add('hidden');
            $('#cancel-edit-btn').classList.add('hidden');
            
            // Make title non-editable
            $('#itinerary-detail-title').contentEditable = false;
            $('#itinerary-detail-title').classList.remove('border-b-2', 'border-blue-300', 'focus:outline-none', 'focus:border-blue-500', 'px-2', 'py-1', 'rounded');
            
            // Clean up all editable elements
            const editableElements = document.querySelectorAll('#itinerary-detail-modal [contenteditable="true"]');
            editableElements.forEach(element => {
                element.contentEditable = false;
                element.classList.remove('focus:outline-none', 'focus:ring-2', 'focus:ring-blue-500', 'focus:ring-opacity-50', 'rounded', 'min-h-[2rem]', 'p-1', 'p-2', 'px-2', 'py-1', 'border-b', 'border-gray-300', 'focus:border-blue-500');
            });
            
            // Remove all edit controls
            const editControls = document.querySelectorAll('#itinerary-detail-modal .edit-controls');
            editControls.forEach(control => control.remove());
            
            // Remove edit wrapper classes and styling
            const editWrapped = document.querySelectorAll('#itinerary-detail-modal .edit-wrapped');
            editWrapped.forEach(element => {
                element.classList.remove('edit-wrapped', 'group', 'hover:shadow-md', 'transition-all', 'duration-300', 'border-2', 'border-blue-200', 'hover:border-blue-400', 'rounded-xl', 'relative', 'bg-gradient-to-r', 'from-blue-50', 'to-indigo-50', 'hover:from-blue-100', 'hover:to-indigo-100', 'p-4', 'my-2');
                element.draggable = false;
            });
            
            // Remove day reorder functionality
            const dayBlocks = document.querySelectorAll('#itinerary-detail-modal .day-block');
            dayBlocks.forEach(dayBlock => {
                // Remove day reorder buttons
                const reorderButtons = dayBlock.querySelector('.day-reorder-buttons');
                if (reorderButtons) {
                    reorderButtons.remove();
                }
                
                // Remove setup classes
                dayBlock.classList.remove('reorder-setup', 'draggable', 'day-dragging', 'day-drag-over');
                dayBlock.draggable = false;
            });
            
            // Remove activity reorder buttons
            const activityReorderButtons = document.querySelectorAll('#itinerary-detail-modal .activity-reorder-buttons');
            activityReorderButtons.forEach(buttons => buttons.remove());
            
            // Remove add activity buttons
            const addButtons = document.querySelectorAll('#itinerary-detail-modal .time-list button');
            addButtons.forEach(button => {
                if (button.textContent.includes('Add Activity')) {
                    button.remove();
                }
            });
            
            // Remove edit indicators and instructions
            $('#itinerary-detail-content').classList.remove('border-2', 'border-blue-200', 'rounded-lg', 'edit-mode');
            const instructions = $('#edit-instructions');
            if (instructions) instructions.remove();
            
            // Clean up drag and drop state
            stopAutoScroll();
            clearDropIndicators();
            clearDayDropIndicators();
            draggedElement = null;
            draggedDay = null;
            
            // Note: Document listeners will be cleaned up when elements are removed
            // since they check for draggedElement/draggedDay existence
        }

        async function saveEditedItinerary(itineraryId, updatedItinerary, shouldExitEditMode = true) {
            try {
                if (auth.currentUser) {
                    // Try to save to Firebase first
                    const docRef = doc(db, 'itineraries', itineraryId);
                    await updateDoc(docRef, {
                        ...updatedItinerary,
                        lastModified: new Date().toISOString()
                    });
                } else {
                    throw new Error('Not authenticated');
                }
            } catch (error) {
                console.log('Firebase update failed, saving to localStorage:', error);
                
                // Fallback to localStorage
                const stored = localStorage.getItem('savedItineraries');
                const itineraries = stored ? JSON.parse(stored) : [];
                
                const index = itineraries.findIndex(item => item.id === itineraryId);
                if (index !== -1) {
                    itineraries[index] = { ...updatedItinerary, id: itineraryId };
                    localStorage.setItem('savedItineraries', JSON.stringify(itineraries));
                } else {
                    console.error('Itinerary not found in localStorage');
                    throw new Error('Itinerary not found');
                }
            }
            
            // Exit edit mode and refresh display (only if requested)
            if (shouldExitEditMode) {
                exitEditMode();
            }
            
            // Refresh the saved itineraries list if visible
            const savedPanel = $('#saved-itineraries-panel');
            if (savedPanel && !savedPanel.classList.contains('hidden')) {
                loadSavedItineraries();
            }
            
            showTemporaryMessage('Itinerary updated successfully!', 'success');
        }

        // --- Delete Functionality Functions ---
        let itineraryToDelete = null;

        function confirmDeleteItinerary(itineraryId) {
            itineraryToDelete = itineraryId;
            showModal('delete-confirm-modal');
        }

        async function deleteItinerary(itineraryId) {
            let deletedFromFirebase = false;
            
            try {
                if (auth.currentUser && !itineraryId.startsWith('local-')) {
                    // Try to delete from Firebase first (only if not a local-only ID)
                    const docRef = doc(db, 'itineraries', itineraryId);
                    await deleteDoc(docRef);
                    deletedFromFirebase = true;
                }
            } catch (error) {
                console.log('Firebase delete failed or not applicable:', error);
            }
            
            // Always try localStorage deletion (for local items or as fallback)
            try {
                // Check both possible localStorage keys
                const keys = ['savedItineraries', 'saved_itineraries'];
                let deleted = false;
                
                for (const key of keys) {
                    const stored = localStorage.getItem(key);
                    if (stored) {
                        const itineraries = JSON.parse(stored);
                        const initialLength = itineraries.length;
                        const filteredItineraries = itineraries.filter(item => item.id !== itineraryId);
                        
                        if (filteredItineraries.length < initialLength) {
                            localStorage.setItem(key, JSON.stringify(filteredItineraries));
                            deleted = true;
                        }
                    }
                }
                
                if (!deleted) {
                }
            } catch (error) {
                console.error('Error deleting from localStorage:', error);
            }
            
            // Hide modals
            hideModal('delete-confirm-modal');
            hideModal('itinerary-detail-modal');
            
            // Always refresh the saved itineraries list when in My Trips section
            if (!$('#my-trips-section').classList.contains('hidden')) {
                loadSavedItineraries();
            }
            
            // Reset delete tracking
            itineraryToDelete = null;
            
            // Show success message
            showTemporaryMessage('Itinerary deleted successfully!', 'success');
        }

        function cancelDelete() {
            itineraryToDelete = null;
            hideModal('delete-confirm-modal');
        }

        // Function to show temporary success/error messages
        function showTemporaryMessage(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `fixed top-20 right-4 z-[9999] px-4 py-3 rounded-lg shadow-lg transition-all duration-300 transform translate-x-full max-w-sm`;
            
            // Set colors based on type
            switch(type) {
                case 'success':
                    toast.className += ' bg-green-100 text-green-800 border border-green-200';
                    break;
                case 'error':
                    toast.className += ' bg-red-100 text-red-800 border border-red-200';
                    break;
                default:
                    toast.className += ' bg-blue-100 text-blue-800 border border-blue-200';
            }
            
            toast.innerHTML = `
                <div class="flex items-center gap-2">
                    <i data-lucide="${type === 'success' ? 'check-circle' : type === 'error' ? 'x-circle' : 'info'}" class="w-4 h-4 flex-shrink-0"></i>
                    <span class="font-medium text-sm leading-relaxed">${message}</span>
                </div>
            `;
            
            document.body.appendChild(toast);
            
            // Initialize icon
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
            
            // Animate in
            setTimeout(() => {
                toast.classList.remove('translate-x-full');
            }, 100);
            
            // Animate out and remove after 4 seconds (slightly longer for better readability)
            setTimeout(() => {
                toast.classList.add('translate-x-full');
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            }, 4000);
        }

        // --- Map Functionality ---
        let currentMap = null;
        let mapVisible = false;
        window.progressiveMap = null; // Make global for debugging
        let discoveredLocations = [];
        window.locationMarkers = []; // Make global for debugging
        let routePolyline = null;
        let isProgressiveMode = false;
        let cachedMappedCities = null; // Cache mapped cities to avoid re-geocoding
        
        // Progressive map functions
        function initializeProgressiveMap() {
            
            if (!window.L) {
                console.error('❌ Leaflet not loaded');
                return;
            }
            
            
            isProgressiveMode = true;
            discoveredLocations = [];
            window.locationMarkers = [];
            
            const mapContainer = document.createElement('div');
            mapContainer.className = 'map-container progressive-map-container loading';
            mapContainer.innerHTML = `
                <div class="map-header">
                    <h4 class="font-semibold text-gray-800 flex items-center gap-2">
                        <i data-lucide="map" class="w-5 h-5"></i>
                        🗺️ Your Journey Map
                    </h4>
                    <button id="close-map-btn" class="map-toggle-btn bg-gray-500 hover:bg-gray-600">
                        <i data-lucide="x" class="w-4 h-4"></i>
                        Close Map
                    </button>
                </div>
                <div id="progressive-map" class="itinerary-map" style="height: 450px; position: relative;"></div>
                <div class="progressive-status">Discovering locations...</div>
            `;
            
            // Insert map into the dedicated map section wrapper (side-by-side layout)
            const mapSectionWrapper = document.getElementById('map-section-wrapper');
            
            if (mapSectionWrapper) {
            }
            
            if (mapSectionWrapper) {
                mapSectionWrapper.innerHTML = ''; // Clear any existing content
                mapSectionWrapper.appendChild(mapContainer);
                mapSectionWrapper.classList.remove('hidden'); // Show the map section
                mapSectionWrapper.style.display = 'flex'; // Explicitly set display to flex
                
                // Store map visibility state
                sessionStorage.setItem('mapVisible', 'true');
                
                // Force parent flex container to use row layout on large screens
                const flexContainer = mapSectionWrapper.parentElement;
                if (flexContainer && window.innerWidth >= 1024) {
                    flexContainer.style.flexDirection = 'row';
                }
                
            } else {
                // Fallback: Old behavior for backward compatibility
                const chatContainer = document.getElementById('chat-container') || 
                                     document.querySelector('.chat-container') ||
                                     document.querySelector('#chat-window') ||
                                     document.querySelector('.chat-window');
                
                if (chatContainer) {
                    chatContainer.insertAdjacentElement('afterend', mapContainer);
                } else {
                    // Last resort: find the main content area
                    const mainContent = document.querySelector('main') || 
                                      document.querySelector('.main-content') ||
                                      document.querySelector('#main-content') ||
                                      document.body;
                    
                    mainContent.appendChild(mapContainer);
                }
            }
            
            // Initialize Lucide icons
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
            
            // Initialize Lucide icons first
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
            
            // Wait a moment for DOM to settle, then initialize map
            setTimeout(() => {
                try {
                    // Initialize map centered on world view with enhanced options
                    window.progressiveMap = L.map('progressive-map', {
                        zoomControl: true,
                        scrollWheelZoom: true,
                        doubleClickZoom: true,
                        touchZoom: true,
                        dragging: true,
                        preferCanvas: false // Better for marker interactions
                    }).setView([20, 0], 2);
                    
                    
                    // Define Google Maps style options
                    const mapStyles = {
                        'Roadmap': L.tileLayer('https://mt{s}.google.com/vt/lyrs=m&x={x}&y={y}&z={z}', {
                            attribution: '© Google Maps',
                            subdomains: '0123',
                            maxZoom: 20
                        }),
                        'Satellite': L.tileLayer('https://mt{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
                            attribution: '© Google Maps',
                            subdomains: '0123',
                            maxZoom: 20
                        }),
                        'Hybrid': L.tileLayer('https://mt{s}.google.com/vt/lyrs=y&x={x}&y={y}&z={z}', {
                            attribution: '© Google Maps',
                            subdomains: '0123',
                            maxZoom: 20
                        }),
                        'Terrain': L.tileLayer('https://mt{s}.google.com/vt/lyrs=p&x={x}&y={y}&z={z}', {
                            attribution: '© Google Maps',
                            subdomains: '0123',
                            maxZoom: 20
                        })
                    };
                    
                    // Add the default Google Maps Roadmap style
                    mapStyles['Roadmap'].addTo(progressiveMap);
                    
                    // Add layer control for switching between Google Maps styles
                    const layerControl = L.control.layers(mapStyles, null, {
                        position: 'topright',
                        collapsed: true
                    }).addTo(progressiveMap);
                    
                    
                    // Add close button functionality
                    document.getElementById('close-map-btn').addEventListener('click', () => {
                        hideProgressiveMap();
                    });
                    
                    mapVisible = true;
                } catch (error) {
                    console.error('❌ Error initializing map:', error);
                }
            }, 100);
        }
        
        function hideProgressiveMap() {
            const mapSectionWrapper = document.getElementById('map-section-wrapper');
            const chatContainer = document.getElementById('chat-container');
            
            if (mapSectionWrapper) {
                mapSectionWrapper.classList.add('hidden');
                mapSectionWrapper.style.display = 'none';
            }
            
            // Store map visibility state
            sessionStorage.setItem('mapVisible', 'false');
            
            // Expand chat to full width
            if (chatContainer && window.innerWidth >= 1024) {
                chatContainer.style.width = '100%';
            }
            
            // Add "Show Map" button to action bar
            const actionButtons = document.getElementById('action-buttons');
            if (actionButtons && !document.getElementById('show-map-button')) {
                // Change action-buttons to justify-between to put Show Map on left
                actionButtons.classList.remove('justify-end');
                actionButtons.classList.add('justify-between');
                
                const showMapBtn = document.createElement('button');
                showMapBtn.id = 'show-map-button';
                showMapBtn.className = 'inline-flex items-center gap-2 bg-green-600 text-white px-3 py-2 rounded-lg hover:bg-green-700 transition-colors';
                showMapBtn.innerHTML = '<i data-lucide="map" class="w-4 h-4"></i><span class="text-white font-medium">Show Map</span>';
                showMapBtn.addEventListener('click', showProgressiveMap);
                actionButtons.insertBefore(showMapBtn, actionButtons.firstChild);
                if (typeof lucide !== 'undefined') lucide.createIcons();
            }
            
            mapVisible = false;
        }
        
        function showProgressiveMap() {
            const mapSectionWrapper = document.getElementById('map-section-wrapper');
            const chatContainer = document.getElementById('chat-container');
            const flexContainer = mapSectionWrapper?.parentElement;
            
            if (mapSectionWrapper) {
                mapSectionWrapper.classList.remove('hidden');
                mapSectionWrapper.style.display = 'flex';
            }
            
            // Store map visibility state
            sessionStorage.setItem('mapVisible', 'true');
            
            // Restore chat to 60% width
            if (chatContainer && window.innerWidth >= 1024) {
                chatContainer.style.width = '';
            }
            
            // Force parent back to row layout
            if (flexContainer && window.innerWidth >= 1024) {
                flexContainer.style.flexDirection = 'row';
            }
            
            // Remove "Show Map" button and restore justify-end
            const showMapBtn = document.getElementById('show-map-button');
            const actionButtons = document.getElementById('action-buttons');
            if (showMapBtn) {
                showMapBtn.remove();
            }
            if (actionButtons) {
                actionButtons.classList.remove('justify-between');
                actionButtons.classList.add('justify-end');
            }
            
            mapVisible = true;
            
            // Refresh map if it exists
            if (window.progressiveMap) {
                setTimeout(() => {
                    window.progressiveMap.invalidateSize();
                }, 100);
            }
        }
        
        // Simple approach - no complex tracking needed
        
        // Debounced bounds update to reduce jerky movement
        let boundsUpdateTimeout;
        function debouncedBoundsUpdate() {
            clearTimeout(boundsUpdateTimeout);
            boundsUpdateTimeout = setTimeout(() => {
                updateMapBounds();
            }, 1000); // Wait 1 second after last marker before updating bounds
        }
        
        // Optimized coordinate caching and batch processing
        const coordinateCache = new Map();
        let geocodingQueue = [];
        let isProcessingQueue = false;
        let performanceStats = { cacheHits: 0, geocodingCalls: 0, totalTime: 0 };
        
        async function rateLimitedGeocode(url, detectedCountry = null) {
            // Check cache first
            const cacheKey = url.toLowerCase();
            if (coordinateCache.has(cacheKey)) {
                performanceStats.cacheHits++;
                return coordinateCache.get(cacheKey);
            }
            
            // Try instant coordinate extraction first
            const locationName = extractLocationNameFromUrl(url);
            if (locationName) {
                const instantCoords = getCoordinatesInstantly(locationName);
                if (instantCoords) {
                    coordinateCache.set(cacheKey, instantCoords);
                    return instantCoords;
                }
            }
            
            // Fallback to original method only if needed
            return new Promise((resolve) => {
                geocodingQueue.push({ url, detectedCountry, resolve });
                processGeocodingQueue();
            });
        }
        
        function extractLocationNameFromUrl(url) {
            try {
                // Extract place name from Google Maps URL
                const queryPattern = /[?&]q=([^&]+)/;
                const queryMatch = url.match(queryPattern);
                
                if (queryMatch) {
                    return decodeURIComponent(queryMatch[1]).replace(/\+/g, ' ');
                }
                
                const placeNamePattern = /\/maps\/place\/([^/@]+)/;
                const placeNameMatch = url.match(placeNamePattern);
                
                if (placeNameMatch) {
                    return decodeURIComponent(placeNameMatch[1]).replace(/\+/g, ' ');
                }
                
                return null;
            } catch (error) {
                console.warn('Error extracting location name:', error);
                return null;
            }
        }
        
        async function processGeocodingQueue() {
            if (isProcessingQueue || geocodingQueue.length === 0) return;
            
            isProcessingQueue = true;
            const batch = geocodingQueue.splice(0, 3); // Process up to 3 at once
            
            try {
                // Process batch in parallel with minimal delay
                const promises = batch.map(async ({ url, detectedCountry, resolve }, index) => {
                    // Stagger requests by 30ms to avoid overwhelming the server
                    await new Promise(r => setTimeout(r, index * 30));
                    
                    const cacheKey = url.toLowerCase();
                    let result = coordinateCache.get(cacheKey);
                    
                    if (!result) {
                        const startTime = Date.now();
                        performanceStats.geocodingCalls++;
                        result = await getCoordinatesFromGoogleMapsUrl(url, detectedCountry);
                        performanceStats.totalTime += Date.now() - startTime;
                        
                        if (result) {
                            coordinateCache.set(cacheKey, result);
                        }
                    }
                    
                    resolve(result);
                });
                
                await Promise.all(promises);
            } catch (error) {
                console.error('❌ Error in geocoding queue:', error);
            }
            
            isProcessingQueue = false;
            
            // Process next batch if there are more items
            if (geocodingQueue.length > 0) {
                setTimeout(() => processGeocodingQueue(), 50);
            }
        }

        async function addLocationToProgressiveMap(responseText) {
            if (!progressiveMap || !isProgressiveMode) return;
            
            
            // Detect ALL countries from the response text for multi-country support
            const detectedCountries = detectAllCountriesFromText(responseText);
            if (detectedCountries.length > 0) {
            }
            
            // For backward compatibility, set primary country (first one or single one)
            const primaryCountry = detectedCountries.length > 0 ? detectedCountries[0] : null;
            
            // First, try to extract locations from venue tags and text (faster)
            const textLocations = extractVenuesAndLocationsFromText(responseText);
            console.log('📍 Found text locations:', textLocations);
            
            // Then extract Google Maps URLs
            const googleMapsUrls = extractGoogleMapsUrls(responseText);
            console.log('🗺️ Found Google Maps URLs:', googleMapsUrls);
            
            // Combine both sources
            const allLocations = [...textLocations, ...googleMapsUrls];
            
            if (allLocations.length === 0) {
                console.log('⚠️ No locations found in response');
                return;
            }
            
            // Filter out duplicates first
            const uniqueLocations = allLocations.filter(locationData => 
                !discoveredLocations.some(loc => loc.name.toLowerCase() === locationData.name.toLowerCase())
            );
            
            if (uniqueLocations.length === 0) return;
            
            console.log(`🎯 Processing ${uniqueLocations.length} new locations instantly...`);
            
            // Process locations in parallel for much faster loading
            const locationPromises = uniqueLocations.map(async (locationData) => {
                try {
                    let coords = null;
                    
                    // Determine the specific country context for this location
                    const locationCountry = detectLocationCountryContext(
                        locationData.name, 
                        responseText, 
                        detectedCountries
                    ) || primaryCountry;
                    
                    // If it's a text location, try instant lookup first, then geocode with country context
                    if (locationData.type === 'text') {
                        coords = getCoordinatesInstantly(locationData.name);
                        if (coords) {
                            console.log('⚡ Instant match for:', locationData.name);
                        } else {
                            // Fall back to geocoding with appropriate country context
                            const geocoded = await geocodeLocation(locationData.name, locationCountry);
                            if (geocoded) {
                                coords = { lat: geocoded.lat, lng: geocoded.lng };
                                console.log('🔍 Geocoded text location:', locationData.name, 'in', locationCountry?.name || 'any country');
                            }
                        }
                    } 
                    // If it's a Google Maps URL, use the geocoding function with country context
                    else if (locationData.url) {
                        coords = await getCoordinatesFromGoogleMapsUrl(locationData.url, locationCountry);
                    }
                    
                    if (coords) {
                        return {
                            name: locationData.name,
                            lat: coords.lat,
                            lng: coords.lng,
                            displayName: locationData.name,
                            googleMapsUrl: locationData.url || null
                        };
                    }
                } catch (error) {
                    console.error('❌ Error processing location:', locationData.name, error);
                }
                return null;
            });
            
            // Wait for all locations to be processed
            const locationResults = await Promise.allSettled(locationPromises);
            
            // Add successful locations to map
            locationResults.forEach((result, index) => {
                if (result.status === 'fulfilled' && result.value) {
                    const locationData = result.value;
                    discoveredLocations.push(locationData);
                    
                    // Create marker with enhanced popup
                    const marker = L.marker([locationData.lat, locationData.lng])
                        .addTo(progressiveMap)
                        .bindPopup(`
                            <div style="text-align: center; padding: 10px; min-width: 200px;">
                                <h4 style="margin: 0 0 8px 0; color: #0D5C63; font-size: 15px; font-weight: 600;">${locationData.name}</h4>
                                <div style="font-size: 13px; color: #666; margin-bottom: 8px;">
                                    <div style="margin: 4px 0;">📌 Stop ${discoveredLocations.length}</div>
                                    <div style="margin: 4px 0; font-size: 11px; color: #999;">
                                        ${locationData.lat.toFixed(4)}°, ${locationData.lng.toFixed(4)}°
                                    </div>
                                </div>
                                <a href="${locationData.googleMapsUrl}" target="_blank" 
                                   style="display: inline-block; color: white; background: #667eea; 
                                          text-decoration: none; font-size: 12px; padding: 6px 12px; 
                                          border-radius: 4px; margin-top: 4px;">
                                    📍 View on Google Maps
                                </a>
                            </div>
                        `, {
                            maxWidth: 280,
                            closeButton: true,
                            autoClose: false,
                            closeOnClick: false
                        });
                    
                    // Add hover functionality
                    marker.on('mouseover', function(e) {
                        this.openPopup();
                    });
                    
                    marker.on('mouseout', function(e) {
                        this.closePopup();
                    });
                    
                    window.locationMarkers.push(marker);
                    console.log('✅ Added marker for:', locationData.name);
                }
            });
            
            // Update status and map once after all locations are processed
            const statusElement = document.querySelector('.progressive-status');
            if (statusElement) {
                statusElement.textContent = `Found ${discoveredLocations.length} location${discoveredLocations.length > 1 ? 's' : ''}`;
            }
            
            // Update route and bounds once at the end
            updateProgressiveRoute();
            debouncedBoundsUpdate();
            
            // Log performance stats
            const instantMatches = uniqueLocations.filter(loc => loc.type === 'text').length;
            console.log('📊 Coordinate extraction performance:', {
                totalLocations: uniqueLocations.length,
                instantMatches: instantMatches,
                successful: discoveredLocations.length,
                cacheHits: performanceStats.cacheHits,
                geocodingCalls: performanceStats.geocodingCalls,
                averageTime: performanceStats.geocodingCalls > 0 ? 
                    Math.round(performanceStats.totalTime / performanceStats.geocodingCalls) + 'ms' : 'N/A'
            });
        }
        
        function extractVenuesAndLocationsFromText(text) {
            const locations = [];
            const processedNames = new Set();
            
            // Extract venues from venue tags - most reliable
            const venuePatterns = [
                /<venue>\*\*([^<*]+)\*\*[^<]*<\/venue>/gi,
                /<venue>([^<]+)<\/venue>/gi,
                /\[VENUE\]\*\*([^*\]]+)\*\*/gi,
                /\*\*([^*]+)\*\*(?=\s*[-–—]\s*[A-Z])/gi  // Bold text before descriptions
            ];
            
            venuePatterns.forEach(pattern => {
                let match;
                while ((match = pattern.exec(text)) !== null) {
                    const name = match[1].trim().replace(/\*+/g, '');
                    if (name && name.length > 2 && !processedNames.has(name.toLowerCase())) {
                        processedNames.add(name.toLowerCase());
                        locations.push({ name, type: 'text' });
                    }
                }
            });
            
            // Extract famous landmarks and attractions from descriptive text
            const landmarkPatterns = [
                /(?:visit|explore|see|tour)\s+(?:the\s+)?([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\s+(?:Museum|Palace|Tower|Cathedral|Bridge|Park|Square|Temple|Castle|Gallery|Market|Center|Centre|Station|Airport|Opera|Theater|Theatre|Library|University|Church|Mosque|Synagogue|Memorial|Monument))/gi,
                /(?:at|in|near)\s+(?:the\s+)?([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\s+(?:District|Quarter|Area|Neighborhood|Village|Town|City|Beach|Island|Hill|Mountain))/gi,
            ];
            
            landmarkPatterns.forEach(pattern => {
                let match;
                while ((match = pattern.exec(text)) !== null) {
                    const name = match[1].trim();
                    if (name && name.length > 3 && !processedNames.has(name.toLowerCase())) {
                        processedNames.add(name.toLowerCase());
                        locations.push({ name, type: 'text' });
                    }
                }
            });
            
            // Extract city names from day headers and titles
            const cityPatterns = [
                /Day\s+\d+[:\-–]\s*(?:in\s+)?([A-Z][a-z]+(?:\s+[A-Z][a-z]+)?)/gi,
                /(?:Morning|Afternoon|Evening)\s+in\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)?)/gi
            ];
            
            cityPatterns.forEach(pattern => {
                let match;
                while ((match = pattern.exec(text)) !== null) {
                    const name = match[1].trim();
                    if (name && name.length > 2 && !processedNames.has(name.toLowerCase())) {
                        // Only add if it looks like a real city name
                        if (!/^(Morning|Afternoon|Evening|Day|Start|End|Visit)$/i.test(name)) {
                            processedNames.add(name.toLowerCase());
                            locations.push({ name, type: 'text' });
                        }
                    }
                }
            });
            
            return locations.slice(0, 10); // Limit to top 10 most relevant
        }
        
        function extractPotentialLocations(text) {
            const locations = new Set();
            
            // More precise patterns focused on actual destinations
            const patterns = [
                // Venue tags (most reliable)
                /<venue>\*\*([^<*]+)\*\*[^<]*<\/venue>/gi,
                /\[VENUE\]\*\*([^*\]]+)\*\*/gi,
                
                // City names in titles and day headers
                /Day\s+\d+[:\-–]\s*([A-Z][a-z]+(?:\s+[A-Z][a-z]+)?)/gi,
                /(?:in|visiting|exploring)\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)?)/gi,
                
                // Famous landmarks and attractions
                /\b([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\s+(?:Museum|Palace|Tower|Cathedral|Bridge|Park|Square|Temple|Castle|Gallery|Market|Center|Centre|Station|Airport))\b/gi,
                
                // Neighborhood/district patterns
                /\b(?:in|at|visit|explore)\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\s+(?:District|Quarter|Area|Neighborhood|Village|Town))/gi,
                
                // Geographic locations
                /\b([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*),\s+([A-Z][a-z]+)\b/g
            ];
            
            // Words to exclude (common non-location words)
            const excludeWords = new Set([
                'Day', 'Morning', 'Afternoon', 'Evening', 'Night', 'Today', 'Tomorrow', 'The', 'Visit', 'Explore',
                'Start', 'End', 'Begin', 'Finish', 'Continue', 'Next', 'First', 'Last', 'After', 'Before',
                'Hotel', 'Restaurant', 'Cafe', 'Bar', 'Shop', 'Store', 'Market', 'Street', 'Road', 'Avenue',
                'Time', 'Hour', 'Minute', 'Clock', 'Early', 'Late', 'Quick', 'Slow', 'Fast', 'Long', 'Short',
                'Good', 'Best', 'Great', 'Amazing', 'Beautiful', 'Perfect', 'Wonderful', 'Excellent', 'Popular',
                'Local', 'Traditional', 'Modern', 'Historic', 'Ancient', 'New', 'Old', 'Famous', 'Known',
                'Take', 'Walk', 'Drive', 'Travel', 'Go', 'Head', 'Move', 'Return', 'Come', 'Leave'
            ]);
            
            patterns.forEach(pattern => {
                let match;
                while ((match = pattern.exec(text)) !== null) {
                    let location = match[1]?.trim();
                    
                    // Handle geographic patterns (City, Country)
                    if (match[2]) {
                        location = match[1].trim() + ', ' + match[2].trim();
                    }
                    
                    if (location && location.length > 2 && location.length < 60) {
                        // Check if it's not in our exclude list
                        const words = location.split(' ');
                        const isExcluded = words.some(word => excludeWords.has(word));
                        
                        if (!isExcluded) {
                            // Additional validation: must contain at least one uppercase letter
                            if (/[A-Z]/.test(location)) {
                                console.log('🎯 Found potential location:', location);
                                locations.add(location);
                            }
                        }
                    }
                }
            });
            
            return Array.from(locations).slice(0, 8); // Limit to 8 most relevant locations
        }
        
        function updateProgressiveRoute() {
            if (!progressiveMap || discoveredLocations.length < 2) return;
            
            // Remove existing route (we're using numbered markers instead of lines)
            if (routePolyline) {
                progressiveMap.removeLayer(routePolyline);
                routePolyline = null;
            }
            
            // Calculate route distance for display (no line drawn)
            const coordinates = discoveredLocations.map(loc => [loc.lat, loc.lng]);
            const totalDistance = calculateRouteDistance(coordinates);
            
            // Update status with route info (without drawing lines)
            const statusElement = document.querySelector('.progressive-status');
            if (statusElement && totalDistance > 0) {
                statusElement.innerHTML = `${discoveredLocations.length} locations • <span style="color: #10b981;">${totalDistance.toFixed(0)} km route</span>`;
            }
            
            console.log('🛣️ Route info calculated for', discoveredLocations.length, 'locations, ~' + totalDistance.toFixed(0) + ' km (numbered markers, no lines)');
        }
        
        function calculateRouteDistance(coordinates) {
            if (coordinates.length < 2) return 0;
            
            let totalDistance = 0;
            for (let i = 0; i < coordinates.length - 1; i++) {
                const lat1 = coordinates[i][0];
                const lng1 = coordinates[i][1];
                const lat2 = coordinates[i + 1][0];
                const lng2 = coordinates[i + 1][1];
                
                // Haversine formula for distance calculation
                const R = 6371; // Earth's radius in kilometers
                const dLat = (lat2 - lat1) * Math.PI / 180;
                const dLng = (lng2 - lng1) * Math.PI / 180;
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                         Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                         Math.sin(dLng/2) * Math.sin(dLng/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                totalDistance += R * c;
            }
            
            return totalDistance;
        }
        
        function updateMapBounds() {
            if (!progressiveMap || discoveredLocations.length === 0) return;
            
            try {
                if (discoveredLocations.length === 1) {
                    // For single location, smoothly pan and zoom
                    const location = discoveredLocations[0];
                    progressiveMap.flyTo([location.lat, location.lng], 11, {
                        animate: true,
                        duration: 1.2,
                        easeLinearity: 0.25
                    });
                } else if (discoveredLocations.length > 1) {
                    // For multiple locations, fit all markers with smooth animation
                    const group = new L.featureGroup(window.locationMarkers);
                    const bounds = group.getBounds();
                    
                    // Check if bounds are valid before updating
                    if (bounds.isValid()) {
                        progressiveMap.flyToBounds(bounds, {
                            padding: [30, 30],
                            animate: true,
                            duration: 1.0,
                            easeLinearity: 0.25,
                            maxZoom: 14, // Slightly less aggressive zoom
                            noMoveStart: true // Prevent excessive move events
                        });
                    }
                }
                
                console.log('🎯 Smooth map bounds updated for', discoveredLocations.length, 'locations');
            } catch (error) {
                console.error('❌ Error updating map bounds:', error);
            }
        }
        
        function finalizeProgressiveMap() {
            if (!progressiveMap || !isProgressiveMode) return;
            
            const statusElement = document.querySelector('.progressive-status');
            if (statusElement) {
                statusElement.innerHTML = `✅ Complete - ${discoveredLocations.length} locations mapped`;
                statusElement.classList.add('finished');
                statusElement.classList.remove('text-blue-600');
                statusElement.classList.add('text-green-600');
                // Stop any animations
                statusElement.style.animation = 'none';
            }
            
            // Fit map bounds to show all pins
            if (discoveredLocations.length > 0) {
                console.log('🗺️ Fitting map bounds to', discoveredLocations.length, 'locations...');
                
                if (discoveredLocations.length === 1) {
                    // Single location - center and zoom
                    const location = discoveredLocations[0];
                    progressiveMap.setView([location.lat, location.lng], 12);
                } else {
                    // Multiple locations - fit bounds
                    const group = new L.featureGroup(window.locationMarkers);
                    progressiveMap.fitBounds(group.getBounds(), {
                        padding: [20, 20],
                        maxZoom: 15
                    });
                }
            }
            
            // Add completion animation
            window.locationMarkers.forEach((marker, index) => {
                setTimeout(() => {
                    const element = marker.getElement();
                    if (element) {
                        element.style.animation = 'pulse 0.5s ease-in-out';
                    }
                }, index * 100);
            });
        }
        
        // Clean up a description string
        function cleanDescription(description, locationName) {
            if (!description) return null;
            
            // Remove surrounding quotes
            description = description.replace(/^["']|["']$/g, '');
            
            // Remove markdown formatting (**, *, _, etc.)
            description = description.replace(/(\*\*|__)(.*?)\1/g, '$2'); // bold
            description = description.replace(/(\*|_)(.*?)\1/g, '$2'); // italic
            
            // Remove "Here's..." or "This place..." introductions
            description = description.replace(/^(Here's why|This place|Why visit|About [^:]+):\s*/i, '');
            
            // Remove location name if AI repeats it at the start
            if (locationName) {
                const locationPattern = new RegExp(`^${locationName}[,:]?\\s*`, 'i');
                description = description.replace(locationPattern, '');
            }
            
            // Remove any leading/trailing whitespace
            description = description.trim();
            
            // Ensure first letter is capitalized
            if (description.length > 0) {
                description = description.charAt(0).toUpperCase() + description.slice(1);
            }
            
            // Limit length to ensure it fits nicely in popup
            if (description.length > 150) {
                // Try to cut at a sentence or word boundary
                const cutPoint = description.lastIndexOf('. ', 150);
                if (cutPoint > 100) {
                    description = description.substring(0, cutPoint + 1);
                } else {
                    const spacePoint = description.lastIndexOf(' ', 147);
                    description = description.substring(0, spacePoint > 100 ? spacePoint : 147) + '...';
                }
            }
            
            return description;
        }
        
        // Get AI-generated description for a location (fallback when not preloaded)
        async function getLocationDescription(locationName, detectedCountry) {
            try {
                const countryContext = detectedCountry ? ` in ${detectedCountry.name}` : '';
                const prompt = `Write a brief, engaging description (2-3 sentences, max 150 characters) about ${locationName}${countryContext}. Explain what makes it special or worth visiting. Write in plain text only - no markdown, no formatting, no introductions. Start directly with the interesting facts.

Example format: "Known for stunning cloud forests and incredible biodiversity. Popular for zip-lining and canopy walks."`;
                
                const backendUrl = `${BACKEND_URL}/api/gemini`;
                
                const response = await fetch(backendUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ userInput: prompt })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    const description = cleanDescription(data.response.trim(), locationName);
                    console.log(`📝 Got description for ${locationName}:`, description);
                    return description;
                }
            } catch (error) {
                console.warn('⚠️ Could not get description for:', locationName, error);
            }
            return null;
        }
        
        // Create map from AI-extracted cities (clean and simple)
        async function createMapFromCities(cities, responseText) {
            if (!progressiveMap || !isProgressiveMode || !cities || cities.length === 0) {
                return;
            }

            console.log('🚀 Starting AI-powered city mapping for:', cities);
            console.log('🔍 Cache check - cachedMappedCities:', cachedMappedCities);
            console.log('🔍 Cache check - has cache?', !!cachedMappedCities);
            console.log('🔍 Cache check - cache length:', cachedMappedCities ? cachedMappedCities.length : 0);
            
            // Check if we have cached cities from a previous session
            if (cachedMappedCities && cachedMappedCities.length > 0) {
                console.log('✅ Using cached mapped cities, skipping geocoding!');
                const statusElement = document.querySelector('.progressive-status');
                
                // Immediately show the cached cities
                discoveredLocations.length = 0;
                discoveredLocations.push(...cachedMappedCities);
                
                // Add markers for all cached cities
                cachedMappedCities.forEach((city, i) => {
                    const detectedCountry = detectCountryFromText(responseText || '');
                    
                    // Create custom numbered marker icon
                    const numberIcon = L.divIcon({
                        className: 'custom-numbered-marker',
                        html: `<div style="
                            background: linear-gradient(135deg, #0D5C63 0%, #0a4a4f 100%);
                            color: white;
                            width: 32px;
                            height: 32px;
                            border-radius: 50% 50% 50% 0;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-weight: bold;
                            font-size: 14px;
                            border: 3px solid white;
                            box-shadow: 0 3px 8px rgba(0,0,0,0.3);
                            transform: rotate(-45deg);
                            position: relative;
                        ">
                            <span style="transform: rotate(45deg);">${i + 1}</span>
                        </div>`,
                        iconSize: [32, 32],
                        iconAnchor: [16, 32],
                        popupAnchor: [0, -32]
                    });
                    
                    const marker = L.marker([city.lat, city.lng], {
                        icon: numberIcon
                    }).addTo(progressiveMap);
                    
                    const descriptionHtml = city.description ? 
                        `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #eee; text-align: left;">
                            <div style="font-size: 11px; color: #555; line-height: 1.4; font-style: italic;">
                                ${city.description}
                            </div>
                        </div>` : '';
                    
                    marker.bindPopup(`
                        <div style="text-align: center; min-width: 220px; max-width: 280px; padding: 8px;">
                            <h4 style="margin: 0 0 8px 0; color: #0D5C63; font-size: 16px; font-weight: 600;">${city.name}</h4>
                            <div style="font-size: 13px; color: #666; margin-bottom: 8px;">
                                <div style="margin: 4px 0;">📍 Destination ${i + 1} of ${cachedMappedCities.length}</div>
                                ${detectedCountry ? `<div style="margin: 4px 0;">🌍 ${detectedCountry.name}</div>` : ''}
                                <div style="margin: 4px 0; font-size: 11px; color: #999;">
                                    ${city.lat.toFixed(4)}°, ${city.lng.toFixed(4)}°
                                </div>
                            </div>
                            ${descriptionHtml}
                        </div>
                    `, {
                        closeButton: true,
                        autoClose: false,
                        closeOnClick: false,
                        maxWidth: 300
                    });
                    
                    marker.on('mouseover', function(e) { this.openPopup(); });
                    marker.on('mouseout', function(e) { this.closePopup(); });
                    window.locationMarkers.push(marker);
                });
                
                updateProgressiveRoute();
                
                // Fit bounds
                if (cachedMappedCities.length === 1) {
                    const city = cachedMappedCities[0];
                    progressiveMap.setView([city.lat, city.lng], 10);
                } else {
                    const bounds = L.latLngBounds(cachedMappedCities.map(city => [city.lat, city.lng]));
                    progressiveMap.fitBounds(bounds, { padding: [20, 20] });
                }
                
                if (statusElement) {
                    statusElement.textContent = `Found ${cachedMappedCities.length} cities`;
                    statusElement.classList.add('finished');
                }
                
                return cachedMappedCities;
            }
            
            // No cache - proceed with normal geocoding
            // Detect ALL countries from the original response for multi-country support
            const detectedCountries = detectAllCountriesFromText(responseText || '');
            console.log('🌍 Country context for geocoding:', detectedCountries.length, 'countries');
            
            // Update status
            const statusElement = document.querySelector('.progressive-status');
            if (statusElement) {
                statusElement.textContent = `Mapping ${cities.length} cities...`;
            }

            const mappedCities = [];

            // Process each city
            for (let i = 0; i < cities.length; i++) {
                const cityData = cities[i];
                // Handle both formats: string or object with {city, description}
                const cityName = typeof cityData === 'string' ? cityData : cityData.city;
                const preloadedDescription = typeof cityData === 'object' ? cityData.description : null;
                
                console.log(`🔍 Geocoding city ${i + 1}/${cities.length}: ${cityName}`);

                try {
                    // Update status for geocoding
                    if (statusElement) {
                        statusElement.textContent = `Mapping ${cityName}...`;
                    }
                    
                    // Determine which country this specific city belongs to
                    const cityCountry = detectLocationCountryContext(
                        cityName,
                        responseText || '',
                        detectedCountries
                    ) || (detectedCountries.length > 0 ? detectedCountries[0] : null);
                    
                    if (cityCountry) {
                        console.log('📍 City country context:', cityName, '→', cityCountry.name);
                    }
                    
                    const coords = await geocodeLocation(cityName, cityCountry);
                    
                    if (coords && coords.lat && coords.lng) {
                        // Use preloaded description if available (much faster!)
                        let description = preloadedDescription;
                        
                        if (description) {
                            // Clean the preloaded description
                            description = cleanDescription(description, cityName);
                            console.log(`✅ Using preloaded description for ${cityName}`);
                        } else {
                            // Fallback: fetch description if not provided by AI
                            console.log(`⚠️ No preloaded description for ${cityName}, fetching...`);
                            if (statusElement) {
                                statusElement.textContent = `Getting info about ${cityName}...`;
                            }
                            description = await getLocationDescription(cityName, cityCountry);
                        }
                        
                        const mappedCity = {
                            name: cityName,
                            lat: coords.lat,
                            lng: coords.lng,
                            displayName: coords.displayName || cityName,
                            description: description
                        };
                        
                        mappedCities.push(mappedCity);
                        
                        // Build description HTML
                        let descriptionHtml = '';
                        if (description) {
                            descriptionHtml = `
                                <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #eee; text-align: left;">
                                    <div style="font-size: 11px; color: #555; line-height: 1.4; font-style: italic;">
                                        ${description}
                                    </div>
                                </div>
                            `;
                        }
                        
                        // Create custom numbered marker icon
                        const numberIcon = L.divIcon({
                            className: 'custom-numbered-marker',
                            html: `<div style="
                                background: linear-gradient(135deg, #0D5C63 0%, #0a4a4f 100%);
                                color: white;
                                width: 32px;
                                height: 32px;
                                border-radius: 50% 50% 50% 0;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                font-weight: bold;
                                font-size: 14px;
                                border: 3px solid white;
                                box-shadow: 0 3px 8px rgba(0,0,0,0.3);
                                transform: rotate(-45deg);
                                position: relative;
                            ">
                                <span style="transform: rotate(45deg);">${i + 1}</span>
                            </div>`,
                            iconSize: [32, 32],
                            iconAnchor: [16, 32],
                            popupAnchor: [0, -32]
                        });
                        
                        // Add marker with enhanced popup information
                        const marker = L.marker([coords.lat, coords.lng], { icon: numberIcon })
                            .addTo(progressiveMap)
                            .bindPopup(`
                                <div style="text-align: center; min-width: 220px; max-width: 280px; padding: 8px;">
                                    <h4 style="margin: 0 0 8px 0; color: #0D5C63; font-size: 16px; font-weight: 600;">${cityName}</h4>
                                    <div style="font-size: 13px; color: #666; margin-bottom: 8px;">
                                        <div style="margin: 4px 0;">📍 Destination ${i + 1} of ${cities.length}</div>
                                        ${cityCountry ? `<div style="margin: 4px 0;">🌍 ${cityCountry.name}</div>` : ''}
                                        <div style="margin: 4px 0; font-size: 11px; color: #999;">
                                            ${coords.lat.toFixed(4)}°, ${coords.lng.toFixed(4)}°
                                        </div>
                                    </div>
                                    ${descriptionHtml}
                                    ${coords.displayName && coords.displayName !== cityName ? 
                                        `<div style="font-size: 11px; color: #999; font-style: italic; margin-top: 4px; border-top: 1px solid #eee; padding-top: 4px;">
                                            ${coords.displayName}
                                        </div>` : ''}
                                </div>
                            `, {
                                closeButton: true,
                                autoClose: false,
                                closeOnClick: false,
                                maxWidth: 300
                            });
                        
                        // Add hover functionality to show/hide popup
                        marker.on('mouseover', function(e) {
                            this.openPopup();
                        });
                        
                        marker.on('mouseout', function(e) {
                            this.closePopup();
                        });
                        
                        window.locationMarkers.push(marker);
                        console.log('✅ Mapped city:', cityName, 'at', coords.lat, coords.lng);

                        // Update status after each city
                        if (statusElement) {
                            statusElement.textContent = `Mapped ${mappedCities.length}/${cities.length} cities`;
                        }

                        // Update route
                        if (mappedCities.length > 1) {
                            updateProgressiveRoute();
                        }
                        
                        // Small delay to avoid rate limiting (reduced since we're not fetching descriptions)
                        await new Promise(resolve => setTimeout(resolve, 500));
                        
                    } else {
                        console.warn('⚠️ Could not geocode city:', cityName);
                    }
                } catch (error) {
                    console.error('❌ Error geocoding city:', cityName, error);
                }
            }

            console.log(`🎉 City mapping complete! Mapped ${mappedCities.length}/${cities.length} cities`);
            
            // Cache the mapped cities for future use
            cachedMappedCities = mappedCities;
            console.log('💾 Cached mapped cities for future map regeneration:', cachedMappedCities.length, 'cities');
            console.log('💾 Cache contents:', cachedMappedCities);
            
            // Final map adjustments
            if (mappedCities.length > 0) {
                // Store the mapped cities globally
                discoveredLocations.length = 0; // Clear existing
                discoveredLocations.push(...mappedCities);
                
                updateProgressiveRoute();
                
                // Fit bounds to show all cities
                if (mappedCities.length === 1) {
                    const city = mappedCities[0];
                    progressiveMap.setView([city.lat, city.lng], 10);
                } else {
                    const bounds = L.latLngBounds(mappedCities.map(city => [city.lat, city.lng]));
                    progressiveMap.fitBounds(bounds, { padding: [20, 20] });
                }

                if (statusElement) {
                    statusElement.textContent = `Found ${mappedCities.length} cities`;
                    statusElement.classList.add('finished');
                }
            }

            return mappedCities;
        }

        async function createAnimatedMapFromResponse(responseText) {
            if (!progressiveMap || !isProgressiveMode) {
                return;
            }
            
            if (!responseText || typeof responseText !== 'string') {
                return;
            }
            
            try {
                console.log('🚀 Starting optimized pin generation...');
                
                // Detect ALL countries in the itinerary for multi-country support
                const detectedCountries = detectAllCountriesFromText(responseText);
                console.log('🌍 Detected country context:', detectedCountries.length, 'countries');
                
                // Extract all Google Maps URLs from the complete response
                const googleMapsUrls = extractGoogleMapsUrls(responseText);
                
                if (googleMapsUrls.length === 0) {
                    return;
                }
                
                console.log(`📍 Processing ${googleMapsUrls.length} locations, extracting main cities only...`);
                
                // Update status immediately
                const statusElement = document.querySelector('.progressive-status');
                if (statusElement) {
                    statusElement.textContent = `Extracting main cities from ${googleMapsUrls.length} locations...`;
                }
                
                // Limit to maximum number of cities to keep map clean
                const MAX_CITIES = 6;
                
                // Process locations with rate limiting to avoid API limits
                const batchSize = 2; // Reduced batch size to avoid rate limits
                const batches = [];
                
                for (let i = 0; i < googleMapsUrls.length; i += batchSize) {
                    batches.push(googleMapsUrls.slice(i, i + batchSize));
                }
                
                let processedCount = 0;
                
                for (const batch of batches) {
                    // Stop if we already have enough cities
                    if (discoveredLocations.length >= MAX_CITIES) {
                        console.log(`🛑 Reached maximum of ${MAX_CITIES} cities, stopping processing`);
                        break;
                    }
                    
                    // Process each batch in parallel
                    const batchPromises = batch.map(async (urlData) => {
                        // Extract main city from the location name
                        const mainCity = extractMainCity(urlData.name);
                        
                        // Skip if this location was filtered out (restaurants, etc.)
                        if (!mainCity) {
                            console.log('⏭️ Skipping filtered non-city location:', urlData.name);
                            return null;
                        }
                        
                        // Aggressive duplicate city detection
                        const cityExists = discoveredLocations.some(loc => {
                            const existingCity = loc.name.toLowerCase();
                            const newCity = mainCity.toLowerCase();
                            
                            // Exact match or very similar match
                            return existingCity === newCity || 
                                   existingCity.includes(newCity) || 
                                   newCity.includes(existingCity) ||
                                   // Handle common variations
                                   (existingCity === 'athens' && newCity.includes('athens')) ||
                                   (newCity === 'athens' && existingCity.includes('athens')) ||
                                   (existingCity === 'santorini' && (newCity.includes('santorini') || newCity.includes('thira'))) ||
                                   (existingCity === 'mykonos' && newCity.includes('mykonos'));
                        });
                        
                        if (cityExists) {
                            console.log('⏭️ Skipping duplicate city:', mainCity, '(from', urlData.name + ')');
                            return null;
                        }
                        
                        console.log('🔍 Processing city location:', mainCity, '(extracted from', urlData.name + ')');
                        
                        try {
                            // Determine which country this specific city belongs to
                            const cityCountry = detectLocationCountryContext(
                                mainCity,
                                responseText,
                                detectedCountries
                            ) || (detectedCountries.length > 0 ? detectedCountries[0] : null);
                            
                            if (cityCountry) {
                                console.log('📍 City country context:', mainCity, '→', cityCountry.name);
                            }
                            
                            // Get coordinates for the main city with country context
                            const coords = await geocodeLocation(mainCity, cityCountry);
                            
                            if (coords && coords.lat && coords.lng) {
                                console.log('✅ Found coordinates for city:', mainCity, coords);
                                return {
                                    name: mainCity,
                                    originalAttraction: urlData.name,
                                    lat: coords.lat,
                                    lng: coords.lng,
                                    googleMapsUrl: urlData.url
                                };
                            } else {
                                console.warn('⚠️ No coordinates found for city:', mainCity);
                            }
                        } catch (error) {
                            console.error('❌ Error processing city:', mainCity, error);
                        }
                        return null;
                    });
                    
                    // Wait for batch to complete
                    const batchResults = await Promise.all(batchPromises);
                    
                    // Add successful results to map
                    const validLocations = batchResults.filter(location => location !== null);
                    
                    // Add all locations to discoveredLocations array first
                    validLocations.forEach(location => {
                        discoveredLocations.push(location);
                    });
                    
                    // Then add markers to map immediately (no delays that might cause issues)
                    validLocations.forEach((location, index) => {
                        const locationIndex = discoveredLocations.indexOf(location) + 1; // Get correct index
                        
                        // Add marker to map immediately with enhanced popup
                        const marker = L.marker([location.lat, location.lng])
                            .addTo(progressiveMap)
                            .bindPopup(`
                                <div style="text-align: center; min-width: 200px; padding: 8px;">
                                    <h4 style="margin: 0 0 8px 0; color: #0D5C63; font-size: 15px; font-weight: 600;">${location.name}</h4>
                                    ${location.originalAttraction ? `<p style="margin: 0 0 8px 0; color: #888; font-size: 11px; font-style: italic;">Includes: ${location.originalAttraction}</p>` : ''}
                                    <div style="font-size: 13px; color: #666; margin-bottom: 8px;">
                                        <div style="margin: 4px 0;">📌 City ${locationIndex}</div>
                                        <div style="margin: 4px 0; font-size: 11px; color: #999;">
                                            ${location.lat.toFixed(4)}°, ${location.lng.toFixed(4)}°
                                        </div>
                                    </div>
                                    <a href="${location.googleMapsUrl}" target="_blank" 
                                       style="display: inline-block; color: white; background: #667eea; 
                                              text-decoration: none; font-size: 12px; padding: 6px 12px; 
                                              border-radius: 4px; margin-top: 4px;">
                                        📍 View on Google Maps
                                    </a>
                                </div>
                            `, {
                                closeButton: true,
                                autoClose: false,
                                closeOnClick: false
                            });
                        
                        // Add hover functionality
                        marker.on('mouseover', function(e) {
                            this.openPopup();
                        });
                        
                        marker.on('mouseout', function(e) {
                            this.closePopup();
                        });
                        
                        window.locationMarkers.push(marker);
                        console.log('✅ Added marker:', location.name, 'at', location.lat, location.lng);
                    });
                    
                    processedCount += batch.length;
                    
                    // Update status after each batch
                    if (statusElement) {
                        const foundCount = discoveredLocations.length;
                        statusElement.textContent = `Found ${foundCount} location${foundCount !== 1 ? 's' : ''} (${Math.round((processedCount / googleMapsUrls.length) * 100)}%)`;
                    }
                    
                    // Update route and bounds after each batch
                    if (discoveredLocations.length > 0) {
                        updateProgressiveRoute();
                        
                        // Adjust map view to show new pins
                        if (discoveredLocations.length === 1) {
                            const location = discoveredLocations[0];
                            progressiveMap.setView([location.lat, location.lng], 10);
                        } else if (window.locationMarkers.length > 1) {
                            const group = new L.featureGroup(window.locationMarkers);
                            progressiveMap.fitBounds(group.getBounds(), {
                                padding: [15, 15],
                                maxZoom: 13
                            });
                        }
                    }
                    
                    // Longer delay between batches to respect API rate limits
                    if (batches.indexOf(batch) < batches.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 2500)); // 2.5 second delay
                    }
                }
                
                console.log(`🎯 Processing complete!`);
                console.log(`📊 Results: ${discoveredLocations.length}/${googleMapsUrls.length} locations mapped`);
                console.log(`🗺️ Total markers on map: ${window.locationMarkers.length}`);
                
                // Log discovered locations for debugging
                console.log('📍 Discovered locations:', discoveredLocations.map(loc => `${loc.name} (${loc.lat}, ${loc.lng})`));
                
                // Log any locations that failed
                const failedLocations = googleMapsUrls.filter(urlData => 
                    !discoveredLocations.some(loc => loc.name.toLowerCase() === urlData.name.toLowerCase())
                );
                
                if (failedLocations.length > 0) {
                    console.warn('⚠️ Failed to map locations:', failedLocations.map(f => f.name));
                }
                
                // Final map adjustment
                updateProgressiveRoute();
                
                // Wait a moment for all markers to be added, then finalize
                setTimeout(() => {
                    finalizeProgressiveMap();
                }, 200);
                
                // Update final status
                if (statusElement) {
                    statusElement.textContent = `Mapped ${discoveredLocations.length}/${googleMapsUrls.length} locations`;
                }
                
                console.log('🎉 Progressive map animation complete!');
                
            } catch (error) {
                console.error('❌ Error creating animated map:', error);
            }
        }
        
        function extractGoogleMapsUrls(text) {
            const googleMapsUrls = [];
            
            // Convert object to string if needed
            const textContent = typeof text === 'object' ? JSON.stringify(text) : text;
            
            // Look for Google Maps URLs with names - pattern: [Name](https://maps.google.com/...)
            const markdownLinkPattern = /\[([^\]]+)\]\((https:\/\/maps\.google\.com\/[^)]+)\)/g;
            let match;
            
            while ((match = markdownLinkPattern.exec(textContent)) !== null) {
                const name = match[1];
                const url = match[2];
                
                // Clean up the name (remove any markdown formatting)
                const cleanName = name.replace(/\*\*/g, '').replace(/\*/g, '').trim();
                
                if (cleanName && url) {
                    googleMapsUrls.push({
                        name: cleanName,
                        url: url
                    });
                }
            }
            
            // Also look for venue tags with Google Maps URLs - fix the pattern to handle [/VENUE] at the end
            const venuePattern = /\[VENUE\]\*\*([^*]+)\*\*\|(https:\/\/maps\.google\.com\/[^\]]+)\[\/VENUE\]/g;
            
            while ((match = venuePattern.exec(textContent)) !== null) {
                const name = match[1];
                let url = match[2];
                
                // Clean up the URL - remove any trailing characters that shouldn't be there
                url = url.trim();
                
                if (name && url) {
                    googleMapsUrls.push({
                        name: name.trim(),
                        url: url
                    });
                }
            }
            
            // Remove duplicates based on URL
            const unique = googleMapsUrls.filter((item, index, array) => 
                index === array.findIndex(other => other.url === item.url)
            );
            
            console.log(`📍 Extracted ${unique.length} unique locations:`, unique.map(u => u.name).join(', '));
            
            return unique;
        }

        async function getCoordinatesFromGoogleMapsUrl(url, detectedCountry = null) {
            try {
                console.log('🌐 Extracting coordinates from URL:', url.substring(0, 100) + '...');
                
                // Method 1: Look for coordinates in the URL directly (fastest method)
                // Multiple coordinate patterns for different Google Maps URL formats
                const coordPatterns = [
                    /@(-?\d+\.?\d*),(-?\d+\.?\d*)/,           // Standard: /@lat,lng
                    /!3d(-?\d+\.?\d*)!4d(-?\d+\.?\d*)/,       // New format: !3dlat!4dlng
                    /ll=(-?\d+\.?\d*),(-?\d+\.?\d*)/,         // Legacy: ll=lat,lng
                    /center=(-?\d+\.?\d*),(-?\d+\.?\d*)/      // Center parameter
                ];
                
                for (const pattern of coordPatterns) {
                    const coordMatch = url.match(pattern);
                    if (coordMatch) {
                        const lat = parseFloat(coordMatch[1]);
                        const lng = parseFloat(coordMatch[2]);
                        
                        if (!isNaN(lat) && !isNaN(lng) && Math.abs(lat) <= 90 && Math.abs(lng) <= 180) {
                            console.log('✅ Found coordinates in URL:', lat, lng);
                            return { lat, lng };
                        } else {
                            console.warn('⚠️ Invalid coordinates in URL:', lat, lng);
                        }
                    }
                }
                
                console.log('🔍 No coordinates in URL, trying geocoding...');
                
                // Method 2: Extract place name from ?q= parameter (most common format)
                const queryPattern = /[?&]q=([^&]+)/;
                const queryMatch = url.match(queryPattern);
                
                if (queryMatch) {
                    const placeName = decodeURIComponent(queryMatch[1]).replace(/\+/g, ' ');
                    console.log('📍 Extracted place name from ?q=:', placeName);
                    
                    // Try to geocode the place name
                    const geocoded = await geocodeLocation(placeName, detectedCountry);
                    if (geocoded) {
                        console.log('✅ Geocoded from ?q= parameter:', geocoded.lat, geocoded.lng);
                        return { lat: geocoded.lat, lng: geocoded.lng };
                    }
                }
                
                // Method 3: Extract place name from /maps/place/ pattern
                const placeNamePattern = /\/maps\/place\/([^/@]+)/;
                const placeNameMatch = url.match(placeNamePattern);
                
                if (placeNameMatch) {
                    const placeName = decodeURIComponent(placeNameMatch[1]).replace(/\+/g, ' ');
                    console.log('📍 Extracted place name from URL path:', placeName);
                    
                    // Try to geocode the place name
                    const geocoded = await geocodeLocation(placeName, detectedCountry);
                    if (geocoded) {
                        console.log('✅ Geocoded from URL path:', geocoded.lat, geocoded.lng);
                        return { lat: geocoded.lat, lng: geocoded.lng };
                    }
                }
                
                console.warn('⚠️ Could not extract coordinates from URL:', url.substring(0, 50) + '...');
                return null;
                
            } catch (error) {
                console.error('❌ Error extracting coordinates from Google Maps URL:', error);
                return null;
            }
        }
        
        function extractLocationsFromItinerary(itinerary) {
            const locations = new Set();
            
            // Extract destination from title if it's a single location
            if (itinerary.title) {
                const titleMatch = itinerary.title.match(/to\s+([^,\(]+)/i);
                if (titleMatch) {
                    locations.add(titleMatch[1].trim());
                }
            }
            
            // Extract locations from day titles and activities
            if (itinerary.days && Array.isArray(itinerary.days)) {
                itinerary.days.forEach(day => {
                    // Extract from day titles - better pattern matching
                    if (day.title) {
                        // Try to extract city/location from day titles like "Day 1 in Athens"
                        const dayMatch = day.title.match(/(?:in|at|to)\s+([A-Z][a-zA-Z\s]+?)(?:\s*[-–—:]|$)/i);
                        if (dayMatch) {
                            locations.add(dayMatch[1].trim());
                        }
                    }
                    
                    // Extract from activities
                    if (day.activities && Array.isArray(day.activities)) {
                        day.activities.forEach(activity => {
                            if (activity.description) {
                                // Look for [VENUE]**Name**|url format (saved itineraries)
                                const venueMarkdownMatches = activity.description.match(/\[VENUE\]\*\*([^\*\|]+)\*\*\|/g);
                                if (venueMarkdownMatches) {
                                    venueMarkdownMatches.forEach(match => {
                                        const location = match.replace(/\[VENUE\]\*\*/, '').replace(/\*\*\|.*/, '').trim();
                                        if (location && location.length > 2) {
                                            locations.add(location);
                                        }
                                    });
                                }
                                
                                // Look for <a> tags with venue class (rendered HTML)
                                const venueHtmlMatches = activity.description.match(/<a[^>]*class="[^"]*venue-link[^"]*"[^>]*>([^<]+)<\/a>/gi);
                                if (venueHtmlMatches) {
                                    venueHtmlMatches.forEach(match => {
                                        const location = match.replace(/<[^>]+>/g, '').trim();
                                        if (location && location.length > 2) {
                                            locations.add(location);
                                        }
                                    });
                                }
                                
                                // Look for <venue> tags (legacy format)
                                const venueTags = activity.description.match(/<venue>([^<]+)<\/venue>/g);
                                if (venueTags) {
                                    venueTags.forEach(match => {
                                        const location = match.replace(/<\/?venue>/g, '').trim();
                                        if (location && location.length > 2) {
                                            locations.add(location);
                                        }
                                    });
                                }
                                
                                // Extract major landmarks/museums from activity titles (more precise)
                                if (activity.title) {
                                    const titleLocations = activity.title.match(/(?:visit|explore|at|to|the)\s+([A-Z][a-zA-Z\s&'-]+(?:Museum|Temple|Palace|Cathedral|Church|Castle|Fort|Ruins|Site))/gi);
                                    if (titleLocations) {
                                        titleLocations.forEach(match => {
                                            const location = match.replace(/^(?:visit|explore|at|to|the)\s+/i, '').trim();
                                            if (location.length > 3 && location.length < 60) {
                                                locations.add(location);
                                            }
                                        });
                                    }
                                }
                            }
                        });
                    }
                });
            }
            
            return Array.from(locations).slice(0, 15); // Increased to 15 locations for better map coverage
        }
        
        function detectCountryFromText(text) {
            // Comprehensive country list with ISO codes - no hardcoded cities
            // This allows dynamic country detection for ANY destination worldwide
            const countries = {
                // Europe
                'greece': { name: 'Greece', code: 'gr' },
                'italy': { name: 'Italy', code: 'it' },
                'spain': { name: 'Spain', code: 'es' },
                'france': { name: 'France', code: 'fr' },
                'germany': { name: 'Germany', code: 'de' },
                'portugal': { name: 'Portugal', code: 'pt' },
                'netherlands': { name: 'Netherlands', code: 'nl' },
                'united kingdom': { name: 'United Kingdom', code: 'gb' },
                'england': { name: 'United Kingdom', code: 'gb' },
                'scotland': { name: 'United Kingdom', code: 'gb' },
                'wales': { name: 'United Kingdom', code: 'gb' },
                'ireland': { name: 'Ireland', code: 'ie' },
                'belgium': { name: 'Belgium', code: 'be' },
                'switzerland': { name: 'Switzerland', code: 'ch' },
                'austria': { name: 'Austria', code: 'at' },
                'poland': { name: 'Poland', code: 'pl' },
                'czech republic': { name: 'Czech Republic', code: 'cz' },
                'czechia': { name: 'Czech Republic', code: 'cz' },
                'hungary': { name: 'Hungary', code: 'hu' },
                'croatia': { name: 'Croatia', code: 'hr' },
                'slovenia': { name: 'Slovenia', code: 'si' },
                'romania': { name: 'Romania', code: 'ro' },
                'bulgaria': { name: 'Bulgaria', code: 'bg' },
                'norway': { name: 'Norway', code: 'no' },
                'sweden': { name: 'Sweden', code: 'se' },
                'denmark': { name: 'Denmark', code: 'dk' },
                'finland': { name: 'Finland', code: 'fi' },
                'iceland': { name: 'Iceland', code: 'is' },
                'turkey': { name: 'Turkey', code: 'tr' },
                'türkiye': { name: 'Turkey', code: 'tr' },
                
                // Asia
                'japan': { name: 'Japan', code: 'jp' },
                'china': { name: 'China', code: 'cn' },
                'south korea': { name: 'South Korea', code: 'kr' },
                'korea': { name: 'South Korea', code: 'kr' },
                'thailand': { name: 'Thailand', code: 'th' },
                'vietnam': { name: 'Vietnam', code: 'vn' },
                'cambodia': { name: 'Cambodia', code: 'kh' },
                'laos': { name: 'Laos', code: 'la' },
                'myanmar': { name: 'Myanmar', code: 'mm' },
                'singapore': { name: 'Singapore', code: 'sg' },
                'malaysia': { name: 'Malaysia', code: 'my' },
                'indonesia': { name: 'Indonesia', code: 'id' },
                'philippines': { name: 'Philippines', code: 'ph' },
                'india': { name: 'India', code: 'in' },
                'nepal': { name: 'Nepal', code: 'np' },
                'sri lanka': { name: 'Sri Lanka', code: 'lk' },
                'bhutan': { name: 'Bhutan', code: 'bt' },
                'pakistan': { name: 'Pakistan', code: 'pk' },
                'bangladesh': { name: 'Bangladesh', code: 'bd' },
                'united arab emirates': { name: 'United Arab Emirates', code: 'ae' },
                'uae': { name: 'United Arab Emirates', code: 'ae' },
                'dubai': { name: 'United Arab Emirates', code: 'ae' },
                'israel': { name: 'Israel', code: 'il' },
                'jordan': { name: 'Jordan', code: 'jo' },
                'saudi arabia': { name: 'Saudi Arabia', code: 'sa' },
                
                // Americas
                'united states': { name: 'United States', code: 'us' },
                'usa': { name: 'United States', code: 'us' },
                'canada': { name: 'Canada', code: 'ca' },
                'mexico': { name: 'Mexico', code: 'mx' },
                'costa rica': { name: 'Costa Rica', code: 'cr' },
                'panama': { name: 'Panama', code: 'pa' },
                'guatemala': { name: 'Guatemala', code: 'gt' },
                'belize': { name: 'Belize', code: 'bz' },
                'honduras': { name: 'Honduras', code: 'hn' },
                'nicaragua': { name: 'Nicaragua', code: 'ni' },
                'el salvador': { name: 'El Salvador', code: 'sv' },
                'brazil': { name: 'Brazil', code: 'br' },
                'argentina': { name: 'Argentina', code: 'ar' },
                'chile': { name: 'Chile', code: 'cl' },
                'peru': { name: 'Peru', code: 'pe' },
                'colombia': { name: 'Colombia', code: 'co' },
                'ecuador': { name: 'Ecuador', code: 'ec' },
                'bolivia': { name: 'Bolivia', code: 'bo' },
                'uruguay': { name: 'Uruguay', code: 'uy' },
                'paraguay': { name: 'Paraguay', code: 'py' },
                'venezuela': { name: 'Venezuela', code: 've' },
                
                // Oceania
                'australia': { name: 'Australia', code: 'au' },
                'new zealand': { name: 'New Zealand', code: 'nz' },
                'fiji': { name: 'Fiji', code: 'fj' },
                
                // Africa
                'south africa': { name: 'South Africa', code: 'za' },
                'egypt': { name: 'Egypt', code: 'eg' },
                'morocco': { name: 'Morocco', code: 'ma' },
                'kenya': { name: 'Kenya', code: 'ke' },
                'tanzania': { name: 'Tanzania', code: 'tz' },
                'ethiopia': { name: 'Ethiopia', code: 'et' },
                'tunisia': { name: 'Tunisia', code: 'tn' },
                'algeria': { name: 'Algeria', code: 'dz' },
                'nigeria': { name: 'Nigeria', code: 'ng' },
                'ghana': { name: 'Ghana', code: 'gh' }
            };
            
            const textLower = text.toLowerCase();
            
            // Check for country names in the text
            for (const [key, country] of Object.entries(countries)) {
                if (textLower.includes(key)) {
                    console.log('🌍 Detected country:', country.name, `(${country.code})`);
                    return country;
                }
            }
            
            return null;
        }
        
        // NEW: Detect ALL countries in text for multi-country itineraries
        function detectAllCountriesFromText(text) {
            const countries = {
                // Europe - Greece
                'greece': { name: 'Greece', code: 'gr' },
                'greek': { name: 'Greece', code: 'gr' },
                'athens': { name: 'Greece', code: 'gr' },
                'santorini': { name: 'Greece', code: 'gr' },
                'mykonos': { name: 'Greece', code: 'gr' },
                'crete': { name: 'Greece', code: 'gr' },
                'rhodes': { name: 'Greece', code: 'gr' },
                'thessaloniki': { name: 'Greece', code: 'gr' },
                'corfu': { name: 'Greece', code: 'gr' },
                
                // Europe - Italy
                'italy': { name: 'Italy', code: 'it' },
                'italian': { name: 'Italy', code: 'it' },
                'rome': { name: 'Italy', code: 'it' },
                'venice': { name: 'Italy', code: 'it' },
                'florence': { name: 'Italy', code: 'it' },
                'milan': { name: 'Italy', code: 'it' },
                'naples': { name: 'Italy', code: 'it' },
                'tuscany': { name: 'Italy', code: 'it' },
                'bologna': { name: 'Italy', code: 'it' },
                'verona': { name: 'Italy', code: 'it' },
                
                // Europe - Spain
                'spain': { name: 'Spain', code: 'es' },
                'spanish': { name: 'Spain', code: 'es' },
                'barcelona': { name: 'Spain', code: 'es' },
                'madrid': { name: 'Spain', code: 'es' },
                'seville': { name: 'Spain', code: 'es' },
                'valencia': { name: 'Spain', code: 'es' },
                'granada': { name: 'Spain', code: 'es' },
                'ibiza': { name: 'Spain', code: 'es' },
                
                // Europe - France
                'france': { name: 'France', code: 'fr' },
                'french': { name: 'France', code: 'fr' },
                'paris': { name: 'France', code: 'fr' },
                'lyon': { name: 'France', code: 'fr' },
                'marseille': { name: 'France', code: 'fr' },
                'nice': { name: 'France', code: 'fr' },
                'bordeaux': { name: 'France', code: 'fr' },
                'cannes': { name: 'France', code: 'fr' },
                
                // Europe - Germany
                'germany': { name: 'Germany', code: 'de' },
                'german': { name: 'Germany', code: 'de' },
                'berlin': { name: 'Germany', code: 'de' },
                'munich': { name: 'Germany', code: 'de' },
                'hamburg': { name: 'Germany', code: 'de' },
                'frankfurt': { name: 'Germany', code: 'de' },
                'cologne': { name: 'Germany', code: 'de' },
                
                // Europe - Portugal
                'portugal': { name: 'Portugal', code: 'pt' },
                'portuguese': { name: 'Portugal', code: 'pt' },
                'lisbon': { name: 'Portugal', code: 'pt' },
                'porto': { name: 'Portugal', code: 'pt' },
                'algarve': { name: 'Portugal', code: 'pt' },
                
                // Europe - Netherlands
                'netherlands': { name: 'Netherlands', code: 'nl' },
                'dutch': { name: 'Netherlands', code: 'nl' },
                'amsterdam': { name: 'Netherlands', code: 'nl' },
                'rotterdam': { name: 'Netherlands', code: 'nl' },
                'the hague': { name: 'Netherlands', code: 'nl' },
                
                // Europe - UK/Ireland
                'united kingdom': { name: 'United Kingdom', code: 'gb' },
                'england': { name: 'United Kingdom', code: 'gb' },
                'british': { name: 'United Kingdom', code: 'gb' },
                'london': { name: 'United Kingdom', code: 'gb' },
                'manchester': { name: 'United Kingdom', code: 'gb' },
                'liverpool': { name: 'United Kingdom', code: 'gb' },
                'scotland': { name: 'United Kingdom', code: 'gb' },
                'scottish': { name: 'United Kingdom', code: 'gb' },
                'edinburgh': { name: 'United Kingdom', code: 'gb' },
                'glasgow': { name: 'United Kingdom', code: 'gb' },
                'wales': { name: 'United Kingdom', code: 'gb' },
                'welsh': { name: 'United Kingdom', code: 'gb' },
                'cardiff': { name: 'United Kingdom', code: 'gb' },
                'ireland': { name: 'Ireland', code: 'ie' },
                'irish': { name: 'Ireland', code: 'ie' },
                'dublin': { name: 'Ireland', code: 'ie' },
                'galway': { name: 'Ireland', code: 'ie' },
                'cork': { name: 'Ireland', code: 'ie' },
                
                // Europe - Other Western
                'belgium': { name: 'Belgium', code: 'be' },
                'belgian': { name: 'Belgium', code: 'be' },
                'brussels': { name: 'Belgium', code: 'be' },
                'bruges': { name: 'Belgium', code: 'be' },
                'switzerland': { name: 'Switzerland', code: 'ch' },
                'swiss': { name: 'Switzerland', code: 'ch' },
                'zurich': { name: 'Switzerland', code: 'ch' },
                'geneva': { name: 'Switzerland', code: 'ch' },
                'austria': { name: 'Austria', code: 'at' },
                'austrian': { name: 'Austria', code: 'at' },
                'vienna': { name: 'Austria', code: 'at' },
                'salzburg': { name: 'Austria', code: 'at' },
                
                // Europe - Eastern
                'poland': { name: 'Poland', code: 'pl' },
                'polish': { name: 'Poland', code: 'pl' },
                'warsaw': { name: 'Poland', code: 'pl' },
                'krakow': { name: 'Poland', code: 'pl' },
                'czech republic': { name: 'Czech Republic', code: 'cz' },
                'czechia': { name: 'Czech Republic', code: 'cz' },
                'czech': { name: 'Czech Republic', code: 'cz' },
                'prague': { name: 'Czech Republic', code: 'cz' },
                'hungary': { name: 'Hungary', code: 'hu' },
                'hungarian': { name: 'Hungary', code: 'hu' },
                'budapest': { name: 'Hungary', code: 'hu' },
                'croatia': { name: 'Croatia', code: 'hr' },
                'croatian': { name: 'Croatia', code: 'hr' },
                'zagreb': { name: 'Croatia', code: 'hr' },
                'dubrovnik': { name: 'Croatia', code: 'hr' },
                'slovenia': { name: 'Slovenia', code: 'si' },
                'slovenian': { name: 'Slovenia', code: 'si' },
                'ljubljana': { name: 'Slovenia', code: 'si' },
                'romania': { name: 'Romania', code: 'ro' },
                'romanian': { name: 'Romania', code: 'ro' },
                'bucharest': { name: 'Romania', code: 'ro' },
                'bulgaria': { name: 'Bulgaria', code: 'bg' },
                'bulgarian': { name: 'Bulgaria', code: 'bg' },
                'sofia': { name: 'Bulgaria', code: 'bg' },
                
                // Europe - Nordic
                'norway': { name: 'Norway', code: 'no' },
                'norwegian': { name: 'Norway', code: 'no' },
                'oslo': { name: 'Norway', code: 'no' },
                'bergen': { name: 'Norway', code: 'no' },
                'sweden': { name: 'Sweden', code: 'se' },
                'swedish': { name: 'Sweden', code: 'se' },
                'stockholm': { name: 'Sweden', code: 'se' },
                'gothenburg': { name: 'Sweden', code: 'se' },
                'denmark': { name: 'Denmark', code: 'dk' },
                'danish': { name: 'Denmark', code: 'dk' },
                'copenhagen': { name: 'Denmark', code: 'dk' },
                'finland': { name: 'Finland', code: 'fi' },
                'finnish': { name: 'Finland', code: 'fi' },
                'helsinki': { name: 'Finland', code: 'fi' },
                'iceland': { name: 'Iceland', code: 'is' },
                'icelandic': { name: 'Iceland', code: 'is' },
                'reykjavik': { name: 'Iceland', code: 'is' },
                
                // Europe/Asia - Turkey
                'turkey': { name: 'Turkey', code: 'tr' },
                'turkish': { name: 'Turkey', code: 'tr' },
                'istanbul': { name: 'Turkey', code: 'tr' },
                'ankara': { name: 'Turkey', code: 'tr' },
                'cappadocia': { name: 'Turkey', code: 'tr' },
                'türkiye': { name: 'Turkey', code: 'tr' },
                
                // Asia - East Asia
                'japan': { name: 'Japan', code: 'jp' },
                'japanese': { name: 'Japan', code: 'jp' },
                'tokyo': { name: 'Japan', code: 'jp' },
                'kyoto': { name: 'Japan', code: 'jp' },
                'osaka': { name: 'Japan', code: 'jp' },
                'hiroshima': { name: 'Japan', code: 'jp' },
                'nara': { name: 'Japan', code: 'jp' },
                'china': { name: 'China', code: 'cn' },
                'chinese': { name: 'China', code: 'cn' },
                'beijing': { name: 'China', code: 'cn' },
                'shanghai': { name: 'China', code: 'cn' },
                'hong kong': { name: 'Hong Kong', code: 'hk' },
                'macau': { name: 'Macau', code: 'mo' },
                'south korea': { name: 'South Korea', code: 'kr' },
                'korea': { name: 'South Korea', code: 'kr' },
                'korean': { name: 'South Korea', code: 'kr' },
                'seoul': { name: 'South Korea', code: 'kr' },
                'busan': { name: 'South Korea', code: 'kr' },
                'jeju': { name: 'South Korea', code: 'kr' },
                'taiwan': { name: 'Taiwan', code: 'tw' },
                'taiwanese': { name: 'Taiwan', code: 'tw' },
                'taipei': { name: 'Taiwan', code: 'tw' },
                
                // Asia - Southeast Asia
                'thailand': { name: 'Thailand', code: 'th' },
                'thai': { name: 'Thailand', code: 'th' },
                'bangkok': { name: 'Thailand', code: 'th' },
                'phuket': { name: 'Thailand', code: 'th' },
                'chiang mai': { name: 'Thailand', code: 'th' },
                'krabi': { name: 'Thailand', code: 'th' },
                'vietnam': { name: 'Vietnam', code: 'vn' },
                'vietnamese': { name: 'Vietnam', code: 'vn' },
                'hanoi': { name: 'Vietnam', code: 'vn' },
                'ho chi minh': { name: 'Vietnam', code: 'vn' },
                'saigon': { name: 'Vietnam', code: 'vn' },
                'hoi an': { name: 'Vietnam', code: 'vn' },
                'cambodia': { name: 'Cambodia', code: 'kh' },
                'cambodian': { name: 'Cambodia', code: 'kh' },
                'siem reap': { name: 'Cambodia', code: 'kh' },
                'phnom penh': { name: 'Cambodia', code: 'kh' },
                'angkor': { name: 'Cambodia', code: 'kh' },
                'laos': { name: 'Laos', code: 'la' },
                'vientiane': { name: 'Laos', code: 'la' },
                'luang prabang': { name: 'Laos', code: 'la' },
                'myanmar': { name: 'Myanmar', code: 'mm' },
                'burma': { name: 'Myanmar', code: 'mm' },
                'yangon': { name: 'Myanmar', code: 'mm' },
                'bagan': { name: 'Myanmar', code: 'mm' },
                'singapore': { name: 'Singapore', code: 'sg' },
                'singaporean': { name: 'Singapore', code: 'sg' },
                'malaysia': { name: 'Malaysia', code: 'my' },
                'malaysian': { name: 'Malaysia', code: 'my' },
                'kuala lumpur': { name: 'Malaysia', code: 'my' },
                'penang': { name: 'Malaysia', code: 'my' },
                'langkawi': { name: 'Malaysia', code: 'my' },
                'indonesia': { name: 'Indonesia', code: 'id' },
                'indonesian': { name: 'Indonesia', code: 'id' },
                'bali': { name: 'Indonesia', code: 'id' },
                'jakarta': { name: 'Indonesia', code: 'id' },
                'yogyakarta': { name: 'Indonesia', code: 'id' },
                'philippines': { name: 'Philippines', code: 'ph' },
                'filipino': { name: 'Philippines', code: 'ph' },
                'manila': { name: 'Philippines', code: 'ph' },
                'cebu': { name: 'Philippines', code: 'ph' },
                'boracay': { name: 'Philippines', code: 'ph' },
                
                // Asia - South Asia
                'india': { name: 'India', code: 'in' },
                'indian': { name: 'India', code: 'in' },
                'delhi': { name: 'India', code: 'in' },
                'mumbai': { name: 'India', code: 'in' },
                'bangalore': { name: 'India', code: 'in' },
                'kolkata': { name: 'India', code: 'in' },
                'jaipur': { name: 'India', code: 'in' },
                'agra': { name: 'India', code: 'in' },
                'goa': { name: 'India', code: 'in' },
                'kerala': { name: 'India', code: 'in' },
                'varanasi': { name: 'India', code: 'in' },
                'nepal': { name: 'Nepal', code: 'np' },
                'nepalese': { name: 'Nepal', code: 'np' },
                'kathmandu': { name: 'Nepal', code: 'np' },
                'pokhara': { name: 'Nepal', code: 'np' },
                'sri lanka': { name: 'Sri Lanka', code: 'lk' },
                'colombo': { name: 'Sri Lanka', code: 'lk' },
                'kandy': { name: 'Sri Lanka', code: 'lk' },
                'bhutan': { name: 'Bhutan', code: 'bt' },
                'bhutanese': { name: 'Bhutan', code: 'bt' },
                'thimphu': { name: 'Bhutan', code: 'bt' },
                'pakistan': { name: 'Pakistan', code: 'pk' },
                'pakistani': { name: 'Pakistan', code: 'pk' },
                'karachi': { name: 'Pakistan', code: 'pk' },
                'lahore': { name: 'Pakistan', code: 'pk' },
                'islamabad': { name: 'Pakistan', code: 'pk' },
                'bangladesh': { name: 'Bangladesh', code: 'bd' },
                'dhaka': { name: 'Bangladesh', code: 'bd' },
                'maldives': { name: 'Maldives', code: 'mv' },
                'malé': { name: 'Maldives', code: 'mv' },
                
                // Asia - Middle East
                'united arab emirates': { name: 'United Arab Emirates', code: 'ae' },
                'uae': { name: 'United Arab Emirates', code: 'ae' },
                'emirati': { name: 'United Arab Emirates', code: 'ae' },
                'dubai': { name: 'United Arab Emirates', code: 'ae' },
                'abu dhabi': { name: 'United Arab Emirates', code: 'ae' },
                'sharjah': { name: 'United Arab Emirates', code: 'ae' },
                'israel': { name: 'Israel', code: 'il' },
                'israeli': { name: 'Israel', code: 'il' },
                'jerusalem': { name: 'Israel', code: 'il' },
                'tel aviv': { name: 'Israel', code: 'il' },
                'jordan': { name: 'Jordan', code: 'jo' },
                'jordanian': { name: 'Jordan', code: 'jo' },
                'amman': { name: 'Jordan', code: 'jo' },
                'petra': { name: 'Jordan', code: 'jo' },
                'saudi arabia': { name: 'Saudi Arabia', code: 'sa' },
                'saudi': { name: 'Saudi Arabia', code: 'sa' },
                'riyadh': { name: 'Saudi Arabia', code: 'sa' },
                'jeddah': { name: 'Saudi Arabia', code: 'sa' },
                'mecca': { name: 'Saudi Arabia', code: 'sa' },
                'qatar': { name: 'Qatar', code: 'qa' },
                'doha': { name: 'Qatar', code: 'qa' },
                'oman': { name: 'Oman', code: 'om' },
                'muscat': { name: 'Oman', code: 'om' },
                'lebanon': { name: 'Lebanon', code: 'lb' },
                'beirut': { name: 'Lebanon', code: 'lb' },
                
                // Americas - North America
                'united states': { name: 'United States', code: 'us' },
                'usa': { name: 'United States', code: 'us' },
                'america': { name: 'United States', code: 'us' },
                'american': { name: 'United States', code: 'us' },
                'new york': { name: 'United States', code: 'us' },
                'los angeles': { name: 'United States', code: 'us' },
                'chicago': { name: 'United States', code: 'us' },
                'san francisco': { name: 'United States', code: 'us' },
                'las vegas': { name: 'United States', code: 'us' },
                'miami': { name: 'United States', code: 'us' },
                'seattle': { name: 'United States', code: 'us' },
                'boston': { name: 'United States', code: 'us' },
                'washington dc': { name: 'United States', code: 'us' },
                'canada': { name: 'Canada', code: 'ca' },
                'canadian': { name: 'Canada', code: 'ca' },
                'toronto': { name: 'Canada', code: 'ca' },
                'vancouver': { name: 'Canada', code: 'ca' },
                'montreal': { name: 'Canada', code: 'ca' },
                'quebec': { name: 'Canada', code: 'ca' },
                'mexico': { name: 'Mexico', code: 'mx' },
                'mexican': { name: 'Mexico', code: 'mx' },
                'mexico city': { name: 'Mexico', code: 'mx' },
                'cancun': { name: 'Mexico', code: 'mx' },
                'playa del carmen': { name: 'Mexico', code: 'mx' },
                'tulum': { name: 'Mexico', code: 'mx' },
                
                // Americas - Central America
                'costa rica': { name: 'Costa Rica', code: 'cr' },
                'san jose': { name: 'Costa Rica', code: 'cr' },
                'panama': { name: 'Panama', code: 'pa' },
                'guatemala': { name: 'Guatemala', code: 'gt' },
                'belize': { name: 'Belize', code: 'bz' },
                'honduras': { name: 'Honduras', code: 'hn' },
                'nicaragua': { name: 'Nicaragua', code: 'ni' },
                'el salvador': { name: 'El Salvador', code: 'sv' },
                
                // Americas - South America
                'brazil': { name: 'Brazil', code: 'br' },
                'brazilian': { name: 'Brazil', code: 'br' },
                'rio de janeiro': { name: 'Brazil', code: 'br' },
                'são paulo': { name: 'Brazil', code: 'br' },
                'argentina': { name: 'Argentina', code: 'ar' },
                'argentinian': { name: 'Argentina', code: 'ar' },
                'buenos aires': { name: 'Argentina', code: 'ar' },
                'chile': { name: 'Chile', code: 'cl' },
                'chilean': { name: 'Chile', code: 'cl' },
                'santiago': { name: 'Chile', code: 'cl' },
                'peru': { name: 'Peru', code: 'pe' },
                'peruvian': { name: 'Peru', code: 'pe' },
                'lima': { name: 'Peru', code: 'pe' },
                'cusco': { name: 'Peru', code: 'pe' },
                'machu picchu': { name: 'Peru', code: 'pe' },
                'colombia': { name: 'Colombia', code: 'co' },
                'colombian': { name: 'Colombia', code: 'co' },
                'bogota': { name: 'Colombia', code: 'co' },
                'cartagena': { name: 'Colombia', code: 'co' },
                'ecuador': { name: 'Ecuador', code: 'ec' },
                'quito': { name: 'Ecuador', code: 'ec' },
                'galapagos': { name: 'Ecuador', code: 'ec' },
                'bolivia': { name: 'Bolivia', code: 'bo' },
                'la paz': { name: 'Bolivia', code: 'bo' },
                'uruguay': { name: 'Uruguay', code: 'uy' },
                'montevideo': { name: 'Uruguay', code: 'uy' },
                'paraguay': { name: 'Paraguay', code: 'py' },
                'venezuela': { name: 'Venezuela', code: 've' },
                
                // Oceania
                'australia': { name: 'Australia', code: 'au' },
                'australian': { name: 'Australia', code: 'au' },
                'sydney': { name: 'Australia', code: 'au' },
                'melbourne': { name: 'Australia', code: 'au' },
                'brisbane': { name: 'Australia', code: 'au' },
                'perth': { name: 'Australia', code: 'au' },
                'new zealand': { name: 'New Zealand', code: 'nz' },
                'auckland': { name: 'New Zealand', code: 'nz' },
                'wellington': { name: 'New Zealand', code: 'nz' },
                'queenstown': { name: 'New Zealand', code: 'nz' },
                'fiji': { name: 'Fiji', code: 'fj' },
                'nadi': { name: 'Fiji', code: 'fj' },
                
                // Africa - North Africa
                'egypt': { name: 'Egypt', code: 'eg' },
                'egyptian': { name: 'Egypt', code: 'eg' },
                'cairo': { name: 'Egypt', code: 'eg' },
                'luxor': { name: 'Egypt', code: 'eg' },
                'morocco': { name: 'Morocco', code: 'ma' },
                'moroccan': { name: 'Morocco', code: 'ma' },
                'marrakech': { name: 'Morocco', code: 'ma' },
                'casablanca': { name: 'Morocco', code: 'ma' },
                'fez': { name: 'Morocco', code: 'ma' },
                'tunisia': { name: 'Tunisia', code: 'tn' },
                'tunis': { name: 'Tunisia', code: 'tn' },
                'algeria': { name: 'Algeria', code: 'dz' },
                
                // Africa - Sub-Saharan
                'south africa': { name: 'South Africa', code: 'za' },
                'cape town': { name: 'South Africa', code: 'za' },
                'johannesburg': { name: 'South Africa', code: 'za' },
                'kenya': { name: 'Kenya', code: 'ke' },
                'nairobi': { name: 'Kenya', code: 'ke' },
                'tanzania': { name: 'Tanzania', code: 'tz' },
                'zanzibar': { name: 'Tanzania', code: 'tz' },
                'ethiopia': { name: 'Ethiopia', code: 'et' },
                'addis ababa': { name: 'Ethiopia', code: 'et' },
                'nigeria': { name: 'Nigeria', code: 'ng' },
                'lagos': { name: 'Nigeria', code: 'ng' },
                'ghana': { name: 'Ghana', code: 'gh' },
                'accra': { name: 'Ghana', code: 'gh' }
            };
            
            const textLower = text.toLowerCase();
            const detectedCountries = [];
            const countryCodesAdded = new Set();
            
            // Check for all country names in the text
            for (const [key, country] of Object.entries(countries)) {
                if (textLower.includes(key)) {
                    // Avoid duplicates (e.g., "england" and "united kingdom" both map to 'gb')
                    if (!countryCodesAdded.has(country.code)) {
                        detectedCountries.push(country);
                        countryCodesAdded.add(country.code);
                        console.log('🌍 Detected country:', country.name, `(${country.code})`);
                    }
                }
            }
            
            if (detectedCountries.length > 0) {
                console.log('🗺️ Multi-country itinerary detected:', detectedCountries.length, 'countries');
            }
            
            return detectedCountries;
        }
        
        // Smart context-based location matching for multi-country itineraries
        function detectLocationCountryContext(locationName, responseText, detectedCountries) {
            if (!detectedCountries || detectedCountries.length === 0) {
                return null;
            }
            
            // If single country, use it
            if (detectedCountries.length === 1) {
                return detectedCountries[0];
            }
            
            // For multi-country, try to detect which country this specific location belongs to
            const locationLower = locationName.toLowerCase();
            
            // Known city-country mappings for common destinations
            const cityCountryMap = {
                // Italy
                'rome': 'italy', 'florence': 'italy', 'venice': 'italy', 'milan': 'italy',
                'naples': 'italy', 'turin': 'italy', 'bologna': 'italy', 'verona': 'italy',
                'pisa': 'italy', 'siena': 'italy', 'genoa': 'italy', 'palermo': 'italy',
                'san gimignano': 'italy', 'cinque terre': 'italy', 'amalfi': 'italy',
                'positano': 'italy', 'sorrento': 'italy', 'capri': 'italy',
                
                // Greece
                'athens': 'greece', 'santorini': 'greece', 'mykonos': 'greece', 'crete': 'greece',
                'rhodes': 'greece', 'corfu': 'greece', 'delphi': 'greece', 'meteora': 'greece',
                'thessaloniki': 'greece', 'zakynthos': 'greece', 'naxos': 'greece', 'paros': 'greece',
                'kalabaka': 'greece', 'olympia': 'greece', 'sparta': 'greece',
                'sounion': 'greece', 'cape sounion': 'greece', 'sounio': 'greece',
                'nafplio': 'greece', 'mycenae': 'greece', 'epidaurus': 'greece',
                'hydra': 'greece', 'kastraki': 'greece', 'arachova': 'greece',
                
                // France
                'paris': 'france', 'marseille': 'france', 'lyon': 'france', 'nice': 'france',
                'bordeaux': 'france', 'cannes': 'france', 'monaco': 'france', 'toulouse': 'france',
                'strasbourg': 'france', 'nantes': 'france', 'montpellier': 'france',
                
                // Spain
                'madrid': 'spain', 'barcelona': 'spain', 'seville': 'spain', 'valencia': 'spain',
                'granada': 'spain', 'bilbao': 'spain', 'malaga': 'spain', 'toledo': 'spain',
                'cordoba': 'spain', 'ibiza': 'spain', 'mallorca': 'spain',
                
                // UK
                'london': 'united kingdom', 'edinburgh': 'united kingdom', 'manchester': 'united kingdom',
                'liverpool': 'united kingdom', 'oxford': 'united kingdom', 'cambridge': 'united kingdom',
                
                // Germany
                'berlin': 'germany', 'munich': 'germany', 'hamburg': 'germany', 'frankfurt': 'germany',
                'cologne': 'germany', 'dresden': 'germany', 'heidelberg': 'germany',
                
                // Other Europe
                'amsterdam': 'netherlands', 'vienna': 'austria', 'prague': 'czech republic',
                'budapest': 'hungary', 'lisbon': 'portugal', 'porto': 'portugal',
                'zurich': 'switzerland', 'geneva': 'switzerland', 'dublin': 'ireland',
                'brussels': 'belgium', 'copenhagen': 'denmark', 'stockholm': 'sweden',
                'oslo': 'norway', 'helsinki': 'finland', 'warsaw': 'poland',
                
                // Asia
                'tokyo': 'japan', 'kyoto': 'japan', 'osaka': 'japan', 'bangkok': 'thailand',
                'singapore': 'singapore', 'hong kong': 'hong kong', 'seoul': 'south korea',
                'beijing': 'china', 'shanghai': 'china', 'dubai': 'united arab emirates',
                'mumbai': 'india', 'delhi': 'india', 'jaipur': 'india', 'agra': 'india'
            };
            
            // Check if we have a known mapping for this city
            if (cityCountryMap[locationLower]) {
                const expectedCountryName = cityCountryMap[locationLower];
                // Find the matching country in detectedCountries
                for (const country of detectedCountries) {
                    if (country.name.toLowerCase().includes(expectedCountryName) || 
                        expectedCountryName.includes(country.name.toLowerCase())) {
                        console.log('📍 Known city match:', locationName, '→', country.name);
                        return country;
                    }
                }
            }
            
            // Try to find the location in context with a country name (tighter window)
            const lines = responseText.split('\n');
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].toLowerCase();
                
                // If this line mentions the location
                if (line.includes(locationLower)) {
                    // Check only the SAME line and 2 lines after (not before, to avoid previous day titles)
                    const contextWindow = 2;
                    const endIdx = Math.min(lines.length, i + contextWindow + 1);
                    const contextText = lines.slice(i, endIdx).join(' ').toLowerCase();
                    
                    // Check which country is mentioned in this tight context
                    for (const country of detectedCountries) {
                        if (contextText.includes(country.name.toLowerCase())) {
                            console.log('📍 Context match:', locationName, '→', country.name);
                            return country;
                        }
                    }
                }
            }
            
            // Fallback: try direct location name matching with country
            for (const country of detectedCountries) {
                if (locationLower.includes(country.name.toLowerCase())) {
                    console.log('📍 Direct match:', locationName, '→', country.name);
                    return country;
                }
            }
            
            // If still no match, return first country as fallback
            console.log('📍 No specific country context for:', locationName, '- using first country:', detectedCountries[0].name);
            return detectedCountries[0];
        }

        // Cache for geocoding results to avoid repeated API calls
        const geocodeCache = new Map();
        
        // Global city coordinates as intelligent fallback - WORLDWIDE COVERAGE
        const globalFallbackCoordinates = {
            // Europe
            'paris': { lat: 48.8566, lng: 2.3522 },
            'london': { lat: 51.5074, lng: -0.1278 },
            'rome': { lat: 41.9028, lng: 12.4964 },
            'athens': { lat: 37.9838, lng: 23.7275 },
            'barcelona': { lat: 41.3851, lng: 2.1734 },
            'amsterdam': { lat: 52.3676, lng: 4.9041 },
            'berlin': { lat: 52.5200, lng: 13.4050 },
            'madrid': { lat: 40.4168, lng: -3.7038 },
            'lisbon': { lat: 38.7223, lng: -9.1393 },
            'vienna': { lat: 48.2082, lng: 16.3738 },
            'prague': { lat: 50.0755, lng: 14.4378 },
            'budapest': { lat: 47.4979, lng: 19.0402 },
            'istanbul': { lat: 41.0082, lng: 28.9784 },
            'zurich': { lat: 47.3769, lng: 8.5417 },
            'florence': { lat: 43.7696, lng: 11.2558 },
            'venice': { lat: 45.4408, lng: 12.3155 },
            'milan': { lat: 45.4642, lng: 9.1900 },
            'naples': { lat: 40.8518, lng: 14.2681 },
            'santorini': { lat: 36.3932, lng: 25.4615 },
            'mykonos': { lat: 37.4467, lng: 25.3289 },
            'delphi': { lat: 38.4824, lng: 22.5012 },
            'rhodes': { lat: 36.4341, lng: 28.2176 },
            'sounion': { lat: 37.6500, lng: 24.0256 },
            'cape sounion': { lat: 37.6500, lng: 24.0256 },
            'sounio': { lat: 37.6500, lng: 24.0256 },
            'meteora': { lat: 39.7217, lng: 21.6306 },
            'kalabaka': { lat: 39.7070, lng: 21.6279 },
            'kastraki': { lat: 39.7168, lng: 21.6206 },
            'nafplio': { lat: 37.5667, lng: 22.8000 },
            'mycenae': { lat: 37.7309, lng: 22.7564 },
            'epidaurus': { lat: 37.5967, lng: 23.0789 },
            'hydra': { lat: 37.3500, lng: 23.4667 },
            'arachova': { lat: 38.4801, lng: 22.5842 },
            'thessaloniki': { lat: 40.6401, lng: 22.9444 },
            'corfu': { lat: 39.6243, lng: 19.9217 },
            'crete': { lat: 35.2401, lng: 24.8093 },
            'edinburgh': { lat: 55.9533, lng: -3.1883 },
            'dublin': { lat: 53.3498, lng: -6.2603 },
            'copenhagen': { lat: 55.6761, lng: 12.5683 },
            'stockholm': { lat: 59.3293, lng: 18.0686 },
            'oslo': { lat: 59.9139, lng: 10.7522 },
            'helsinki': { lat: 60.1699, lng: 24.9384 },
            
            // Asia
            'tokyo': { lat: 35.6762, lng: 139.6503 },
            'kyoto': { lat: 35.0116, lng: 135.7681 },
            'osaka': { lat: 34.6937, lng: 135.5023 },
            'bangkok': { lat: 13.7563, lng: 100.5018 },
            'singapore': { lat: 1.3521, lng: 103.8198 },
            'hong kong': { lat: 22.3193, lng: 114.1694 },
            'shanghai': { lat: 31.2304, lng: 121.4737 },
            'beijing': { lat: 39.9042, lng: 116.4074 },
            'seoul': { lat: 37.5665, lng: 126.9780 },
            'mumbai': { lat: 19.0760, lng: 72.8777 },
            'delhi': { lat: 28.7041, lng: 77.1025 },
            'dubai': { lat: 25.2048, lng: 55.2708 },
            'kuala lumpur': { lat: 3.1390, lng: 101.6869 },
            
            // Americas  
            'new york': { lat: 40.7128, lng: -74.0060 },
            'los angeles': { lat: 34.0522, lng: -118.2437 },
            'chicago': { lat: 41.8781, lng: -87.6298 },
            'san francisco': { lat: 37.7749, lng: -122.4194 },
            'miami': { lat: 25.7617, lng: -80.1918 },
            'toronto': { lat: 43.6532, lng: -79.3832 },
            'vancouver': { lat: 49.2827, lng: -123.1207 },
            'mexico city': { lat: 19.4326, lng: -99.1332 },
            'rio de janeiro': { lat: -22.9068, lng: -43.1729 },
            'buenos aires': { lat: -34.6037, lng: -58.3816 },
            'santiago': { lat: -33.4489, lng: -70.6693 },
            'lima': { lat: -12.0464, lng: -77.0428 },
            
            // Africa & Oceania
            'cairo': { lat: 30.0444, lng: 31.2357 },
            'cape town': { lat: -33.9249, lng: 18.4241 },
            'sydney': { lat: -33.8688, lng: 151.2093 },
            'melbourne': { lat: -37.8136, lng: 144.9631 },
            'moscow': { lat: 55.7558, lng: 37.6176 },
            'dubai': { lat: 25.2048, lng: 55.2708 },
            'singapore': { lat: 1.3521, lng: 103.8198 },
            'hong kong': { lat: 22.3193, lng: 114.1694 },
            'sydney': { lat: -33.8688, lng: 151.2093 },
            'melbourne': { lat: -37.8136, lng: 144.9631 },
            'toronto': { lat: 43.6532, lng: -79.3832 },
            'vancouver': { lat: 49.2827, lng: -123.1207 },
            'san francisco': { lat: 37.7749, lng: -122.4194 },
            'los angeles': { lat: 34.0522, lng: -118.2437 },
            'chicago': { lat: 41.8781, lng: -87.6298 },
            'miami': { lat: 25.7617, lng: -80.1918 },
            'mexico city': { lat: 19.4326, lng: -99.1332 },
            'rio de janeiro': { lat: -22.9068, lng: -43.1729 },
            'buenos aires': { lat: -34.6037, lng: -58.3816 },
            'santiago': { lat: -33.4489, lng: -70.6693 },
            'cape town': { lat: -33.9249, lng: 18.4241 },
            'cairo': { lat: 30.0444, lng: 31.2357 },
            'mumbai': { lat: 19.0760, lng: 72.8777 },
            'delhi': { lat: 28.7041, lng: 77.1025 },
            'bangkok': { lat: 13.7563, lng: 100.5018 },
            'seoul': { lat: 37.5665, lng: 126.9780 },
            'beijing': { lat: 39.9042, lng: 116.4074 },
            'shanghai': { lat: 31.2304, lng: 121.4737 }
        };
        
        // Extract main city from detailed location names - AGGRESSIVE CITY-ONLY APPROACH
        function extractMainCity(locationName) {
            const name = locationName.toLowerCase().trim();
            
            console.log('🔍 Analyzing location for city extraction:', locationName);
            
            // FILTER OUT non-city locations first
            const nonCityKeywords = [
                'restaurant', 'tavern', 'taverna', 'cafe', 'bar', 'hotel', 'resort', 'beach', 
                'museum', 'gallery', 'church', 'temple', 'monastery', 'castle', 'palace',
                'archaeological', 'site', 'ruins', 'square', 'plaza', 'park', 'garden',
                'airport', 'port', 'station', 'center', 'mall', 'market', 'shop', 'store',
                'sunset', 'sunrise', 'viewpoint', 'lookout', 'bridge', 'tower', 'monument'
            ];
            
            // Check if this location should be filtered out (not a city)
            const isNonCity = nonCityKeywords.some(keyword => name.includes(keyword));
            if (isNonCity) {
                console.log('🚫 Filtering out non-city location:', locationName);
                return null; // Return null for non-city locations
            }
            
            // Check if any major world city is mentioned in the location name
            const globalCities = Object.keys(globalFallbackCoordinates);
            for (const city of globalCities) {
                if (name.includes(city)) {
                    console.log('🏙️ Found known global city:', locationName, '→', city.toUpperCase());
                    return city.charAt(0).toUpperCase() + city.slice(1);
                }
            }
            
            // Universal pattern-based extraction for global cities
            const cityPatterns = [
                // "Something in CityName" 
                /\bin\s+([a-zA-Z\s]+?)(?:,|$)/i,
                // "Something, CityName"  
                /,\s*([a-zA-Z\s]+?)(?:,|$)/i,
                // "CityName - Something"
                /^([a-zA-Z\s]+?)\s*[-–]/i,
                // "CityName (" for locations like "Paris (France)"
                /^([a-zA-Z\s]+?)\s*\(/i
            ];
            
            for (const pattern of cityPatterns) {
                const match = name.match(pattern);
                if (match && match[1]) {
                    let extractedCity = match[1].trim();
                    
                    // Clean up common non-city words
                    extractedCity = extractedCity.replace(/\b(the|of|and|or|at|on|from|to|city|town|village)\b/gi, '').trim();
                    
                    // Must be a reasonable city name (not too generic, reasonable length)
                    if (extractedCity.length >= 3 && extractedCity.length <= 25 && 
                        extractedCity.split(' ').length <= 3 && // Max 3 words
                        !/^\d/.test(extractedCity) && // Don't start with numbers
                        !/\b(center|centre|downtown|old|new|north|south|east|west|upper|lower)\b/i.test(extractedCity)) {
                        
                        console.log('🏙️ Extracted potential city via pattern:', locationName, '→', extractedCity.toUpperCase());
                        return extractedCity.charAt(0).toUpperCase() + extractedCity.slice(1);
                    }
                }
            }
            
            // Try single word extraction as last resort (for simple city names)
            const words = name.split(/[\s,\-()]+/).filter(word => 
                word.length >= 4 && 
                word.length <= 15 &&
                !/\b(the|and|or|of|in|at|on|to|from|for|with|by|this|that|here|there)\b/i.test(word) &&
                !/\d/.test(word) // No numbers
            );
            
            if (words.length > 0) {
                const potentialCity = words[0];
                console.log('🏙️ Using first meaningful word as city:', locationName, '→', potentialCity.toUpperCase());
                return potentialCity.charAt(0).toUpperCase() + potentialCity.slice(1);
            }
            
            // If no pattern matches, this is likely not a city-level location
            console.log('🚫 Could not extract city from:', locationName, '- skipping');
            return null;
        }

        // Smart fallback that tries to find city context from location name
        function getFallbackCoordinates(locationName, detectedCountry = null) {
            const name = locationName.toLowerCase().trim();
            
            // Check for EXACT match first (highest priority)
            if (globalFallbackCoordinates[name]) {
                console.log('📌 Using exact fallback match:', locationName, '→', globalFallbackCoordinates[name]);
                return globalFallbackCoordinates[name];
            }
            
            // Check for close variations (handles spelling differences)
            // Only if the names are very similar (edit distance)
            for (const [city, coords] of Object.entries(globalFallbackCoordinates)) {
                // Check if they're very close (accounting for spaces, hyphens, etc.)
                const normalizedCity = city.replace(/[\s-]/g, '');
                const normalizedName = name.replace(/[\s-]/g, '');
                
                // Match if:
                // 1. Normalized exact match (e.g., "Cape Sounion" vs "capesounion")
                // 2. One is contained in the other AND length difference is tiny (≤3 chars)
                //    This handles "Sounio" vs "Sounion" type variations
                if (normalizedCity === normalizedName) {
                    console.log('📌 Using normalized fallback match:', locationName, '→', city, coords);
                    return coords;
                }
                
                // Allow minor spelling variations (1-2 character difference)
                if ((normalizedCity.includes(normalizedName) || normalizedName.includes(normalizedCity)) &&
                    Math.abs(normalizedCity.length - normalizedName.length) <= 2) {
                    console.log('📌 Using close variation fallback:', locationName, '→', city, coords);
                    return coords;
                }
            }
            
            // NO FALLBACKS - Better to skip than show wrong location
            console.log('⏭️ No fallback found for:', locationName, '- will attempt API geocoding');
            return null;
        }
        
        async function geocodeLocation(locationName, detectedCountry = null) {
            // Create cache key
            const cacheKey = `${locationName}-${detectedCountry?.code || 'none'}`;
            
            // Check cache first
            if (geocodeCache.has(cacheKey)) {
                const cached = geocodeCache.get(cacheKey);
                return cached;
            }
            
            try {
                // Try proper geocoding first - only use fallbacks as last resort
                console.log('🔍 Attempting geocoding for:', locationName);
                
                let searchQuery = locationName;
                let countryCode = null;
                
                // If we have a detected country context, use it to improve accuracy
                if (detectedCountry) {
                    // Add country to search if not already mentioned
                    const locationLower = locationName.toLowerCase();
                    const countryLower = detectedCountry.name.toLowerCase();
                    
                    // Add country context to query for better geocoding accuracy
                    if (!locationLower.includes(countryLower)) {
                        searchQuery = `${locationName}, ${detectedCountry.name}`;
                        console.log('🌍 Enhanced query with country context:', searchQuery);
                    }
                    
                    countryCode = detectedCountry.code;
                    console.log('🔒 Restricting geocoding to country code:', countryCode);
                }
                
                // Using Nominatim with optimized parameters for speed
                // Request multiple results to find the best match
                const searchParams = new URLSearchParams({
                    format: 'json',
                    q: searchQuery,
                    limit: '5', // Get multiple results for better accuracy
                    addressdetails: '1', // Enable to verify country match
                    extratags: '0', // Disabled for speed
                    namedetails: '0' // Disabled for speed
                });
                
                // Add country code filter if we detected a country - CRITICAL for accuracy
                if (countryCode) {
                    searchParams.set('countrycodes', countryCode);
                }
                
                // Increased timeout to handle rate limiting
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 8000); // Increased to 8 second timeout
                
                const response = await fetch(`https://nominatim.openstreetmap.org/search?${searchParams}`, {
                    signal: controller.signal,
                    headers: {
                        'User-Agent': 'KimatAI/1.0'  // Add user agent for better API response
                    }
                });
                clearTimeout(timeoutId);
                
                if (response.status === 429) {
                    console.warn('⏳ Rate limited by geocoding service for:', locationName);
                    // Only try exact city match fallbacks, not country defaults
                    const fallback = getFallbackCoordinates(locationName, null);
                    if (fallback) {
                        const result = {
                            name: locationName,
                            lat: fallback.lat,
                            lng: fallback.lng,
                            displayName: locationName,
                            category: 'fallback_rate_limited',
                            type: 'tourist_attraction'
                        };
                        geocodeCache.set(cacheKey, result);
                        return result;
                    }
                    console.log('⏭️ Skipping rate-limited location without exact match:', locationName);
                    geocodeCache.set(cacheKey, null);
                    return null;
                }
                
                const data = await response.json();
                
                if (data && data.length > 0) {
                    console.log('🔍 Received', data.length, 'geocoding results');
                    
                    // First priority: Verify country match using address details
                    let relevantResult = null;
                    
                    if (detectedCountry && countryCode) {
                        // Filter results to only those in the target country
                        const countryFilteredResults = data.filter(result => {
                            // Check address details for country code match (most reliable)
                            if (result.address && result.address.country_code) {
                                const matchesCode = result.address.country_code.toLowerCase() === countryCode.toLowerCase();
                                if (matchesCode) {
                                    console.log('✅ Country code match:', result.display_name);
                                }
                                return matchesCode;
                            }
                            
                            // Fallback: Check display name for country name
                            const matchesName = result.display_name && 
                                result.display_name.toLowerCase().includes(detectedCountry.name.toLowerCase());
                            if (matchesName) {
                                console.log('✅ Country name match in display:', result.display_name);
                            }
                            return matchesName;
                        });
                        
                        console.log('🌍 Filtered to', countryFilteredResults.length, 'results in', detectedCountry.name);
                        
                        // Now find the best result from country-filtered results
                        if (countryFilteredResults.length > 0) {
                            // Score each result based on relevance
                            const scoredResults = countryFilteredResults.map(result => {
                                let score = 0;
                                const category = result.category;
                                const type = result.type;
                                const placeRank = parseInt(result.place_rank) || 999;
                                
                                // High priority: Tourism attractions and landmarks
                                if (category === 'tourism') score += 100;
                                if (type === 'attraction' || type === 'museum' || type === 'monument' || 
                                    type === 'castle' || type === 'ruins' || type === 'archaeological_site') score += 50;
                                
                                // Medium priority: Cities and amenities
                                if (type === 'city' || type === 'town') score += 30;
                                if (category === 'amenity') score += 25;
                                if (category === 'place') score += 20;
                                
                                // Boost by place rank (lower is more important)
                                if (placeRank <= 10) score += 40;
                                else if (placeRank <= 16) score += 20;
                                else if (placeRank <= 20) score += 10;
                                
                                console.log('📊 Score', score, 'for:', result.display_name, 
                                    `(${category}/${type}, rank: ${placeRank})`);
                                
                                return { result, score };
                            });
                            
                            // Sort by score (highest first) and pick the best
                            scoredResults.sort((a, b) => b.score - a.score);
                            relevantResult = scoredResults[0].result;
                            console.log('🎯 Selected best match:', relevantResult.display_name, 
                                'with score', scoredResults[0].score);
                        }
                    }
                    
                    // If no country-specific result found, try general filtering
                    if (!relevantResult) {
                        console.log('⚠️ No country-specific match, trying general filtering...');
                        relevantResult = data.find(result => {
                            const category = result.category;
                            const type = result.type;
                            const placeRank = parseInt(result.place_rank) || 999;
                            
                            return category === 'tourism' ||
                                   category === 'amenity' ||
                                   type === 'city' ||
                                   type === 'town' ||
                                   type === 'attraction' ||
                                   type === 'museum' ||
                                   type === 'monument' ||
                                   placeRank <= 16;
                        });
                    }
                    
                    // Last resort: Use first result but log warning
                    if (!relevantResult) {
                        console.warn('⚠️ No ideal match found, using first result');
                        relevantResult = data[0];
                    }
                    
                    const lat = parseFloat(relevantResult.lat);
                    const lng = parseFloat(relevantResult.lon);
                    
                    // Validate coordinates
                    if (isNaN(lat) || isNaN(lng) || Math.abs(lat) > 90 || Math.abs(lng) > 180) {
                        console.warn('⚠️ Invalid coordinates from geocoding:', lat, lng);
                        geocodeCache.set(cacheKey, null);
                        return null;
                    }
                    
                    const result = {
                        name: locationName,
                        lat: lat,
                        lng: lng,
                        displayName: relevantResult.display_name,
                        category: relevantResult.category,
                        type: relevantResult.type
                    };
                    
                    // Cache the successful result
                    geocodeCache.set(cacheKey, result);
                    
                    console.log('✅ Successfully geocoded:', locationName, '→', lat, lng);
                    return result;
                }
                
                console.log('❌ No geocoding results for:', locationName);
                
                // Only now try fallback coordinates as last resort
                const fallback = getFallbackCoordinates(locationName, detectedCountry);
                if (fallback) {
                    console.log('🔄 Using fallback after no geocoding results for:', locationName);
                    const result = {
                        name: locationName,
                        lat: fallback.lat,
                        lng: fallback.lng,
                        displayName: locationName,
                        category: 'fallback_no_results',
                        type: 'tourist_attraction'
                    };
                    geocodeCache.set(cacheKey, result);
                    return result;
                }
                
                // Cache null result to avoid repeated failed attempts
                geocodeCache.set(cacheKey, null);
                return null;
            } catch (error) {
                console.error('❌ Geocoding error for', locationName, ':', error);
                
                // Only try exact city match fallbacks after errors, not country defaults
                const fallback = getFallbackCoordinates(locationName, null);
                if (fallback) {
                    console.log('🔄 Using exact match fallback after error for:', locationName);
                    const result = {
                        name: locationName,
                        lat: fallback.lat,
                        lng: fallback.lng,
                        displayName: locationName,
                        category: 'fallback_error',
                        type: 'tourist_attraction'
                    };
                    geocodeCache.set(cacheKey, result);
                    return result;
                }
                
                console.log('⏭️ Skipping failed location without exact match:', locationName);
                
                // Cache null result to avoid repeated failed attempts
                geocodeCache.set(cacheKey, null);
                return null;
            }
        }
        
        async function createItineraryMap(itinerary) {
            if (!window.L) {
                console.error('Leaflet not loaded');
                return;
            }
            
            // Detect country from itinerary text
            const itineraryText = typeof itinerary === 'string' ? itinerary : JSON.stringify(itinerary);
            const detectedCountries = detectAllCountriesFromText(itineraryText);
            const detectedCountry = detectedCountries.length > 0 ? detectedCountries[0] : null;
            console.log('🌍 Detected country for map:', detectedCountry?.name || 'None');
            
            const mapContainer = document.createElement('div');
            mapContainer.className = 'map-container';
            mapContainer.innerHTML = `
                <div class="map-header">
                    <h4 class="font-semibold text-gray-800 flex items-center gap-2">
                        <i data-lucide="map" class="w-5 h-5"></i>
                        Itinerary Map
                    </h4>
                    <button id="close-map-btn" class="map-toggle-btn bg-gray-500 hover:bg-gray-600">
                        <i data-lucide="x" class="w-4 h-4"></i>
                        Close Map
                    </button>
                </div>
                <div class="map-loading" id="map-loading">
                    <i data-lucide="loader" class="w-5 h-5 mr-2 animate-spin"></i>
                    Loading locations...
                </div>
                <div id="itinerary-map" class="itinerary-map" style="display: none;"></div>
            `;
            
            // Insert map container at the top of itinerary content
            const content = document.getElementById('itinerary-detail-content');
            content.insertBefore(mapContainer, content.firstChild);
            
            // Initialize Lucide icons for the new elements
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
            
            // Extract locations
            const locationNames = extractLocationsFromItinerary(itinerary);
            console.log('Extracted locations:', locationNames);
            
            if (locationNames.length === 0) {
                document.getElementById('map-loading').innerHTML = `
                    <i data-lucide="map-pin-off" class="w-5 h-5 mr-2"></i>
                    No locations found in itinerary
                `;
                lucide.createIcons();
                return;
            }
            
            // Geocode locations sequentially to avoid rate limiting and abort issues
            const geocodedLocations = [];
            const loadingEl = document.getElementById('map-loading');
            
            for (let i = 0; i < locationNames.length; i++) {
                const locationName = locationNames[i];
                
                // Update progress
                loadingEl.innerHTML = `
                    <i data-lucide="loader" class="w-5 h-5 mr-2 animate-spin"></i>
                    Loading locations... (${i + 1}/${locationNames.length})
                `;
                lucide.createIcons();
                
                try {
                    // Stagger requests to avoid overwhelming the geocoding service
                    if (i > 0) {
                        await new Promise(resolve => setTimeout(resolve, 200)); // 200ms between requests
                    }
                    
                    const location = await geocodeLocation(locationName, detectedCountry);
                    if (location) {
                        geocodedLocations.push(location);
                        console.log(`✅ Geocoded: ${locationName} -> ${location.lat}, ${location.lng}`);
                    }
                } catch (error) {
                    console.warn(`⚠️ Failed to geocode: ${locationName}`, error.message);
                }
            }
            
            console.log('Geocoded locations:', geocodedLocations);
            
            if (geocodedLocations.length === 0) {
                loadingEl.innerHTML = `
                    <i data-lucide="alert-circle" class="w-5 h-5 mr-2"></i>
                    Could not find coordinates for locations
                `;
                lucide.createIcons();
                return;
            }
            
            // Hide loading and show map
            loadingEl.style.display = 'none';
            document.getElementById('itinerary-map').style.display = 'block';
            
            // Initialize map with Google Maps styling
            const map = L.map('itinerary-map').setView([geocodedLocations[0].lat, geocodedLocations[0].lng], 10);
            currentMap = map;
            
            // Add Google Maps Roadmap tile layer
            L.tileLayer('https://mt{s}.google.com/vt/lyrs=m&x={x}&y={y}&z={z}', {
                attribution: '© Google Maps',
                subdomains: '0123',
                maxZoom: 20
            }).addTo(map);
            
            // Add markers for each location with enhanced popups
            geocodedLocations.forEach((location, index) => {
                const marker = L.marker([location.lat, location.lng])
                    .addTo(map)
                    .bindPopup(`
                        <div style="text-align: center; min-width: 200px; padding: 8px;">
                            <h4 style="margin: 0 0 8px 0; color: #0D5C63; font-size: 15px; font-weight: 600;">${location.name}</h4>
                            <div style="font-size: 13px; color: #666; margin-bottom: 8px;">
                                <div style="margin: 4px 0;">📍 Stop ${index + 1} of ${geocodedLocations.length}</div>
                                ${detectedCountry ? `<div style="margin: 4px 0;">🌍 ${detectedCountry.name}</div>` : ''}
                                <div style="margin: 4px 0; font-size: 11px; color: #999;">
                                    ${location.lat.toFixed(4)}°, ${location.lng.toFixed(4)}°
                                </div>
                            </div>
                            ${location.displayName && location.displayName !== location.name ? 
                                `<div style="font-size: 11px; color: #999; font-style: italic; margin-top: 4px; border-top: 1px solid #eee; padding-top: 4px;">
                                    ${location.displayName}
                                </div>` : ''}
                        </div>
                    `, {
                        closeButton: true,
                        autoClose: false,
                        closeOnClick: false
                    });
                
                // Add hover functionality
                marker.on('mouseover', function(e) {
                    this.openPopup();
                });
                
                marker.on('mouseout', function(e) {
                    this.closePopup();
                });
            });
            
            // Route lines disabled - using numbered markers for cleaner look
            // (No crisscrossing lines)
            
            // Fit map to show all markers
            if (geocodedLocations.length > 1) {
                const group = new L.featureGroup(
                    geocodedLocations.map(loc => L.marker([loc.lat, loc.lng]))
                );
                map.fitBounds(group.getBounds().pad(0.1));
            }
            
            // Add close button functionality
            document.getElementById('close-map-btn').addEventListener('click', () => {
                hideItineraryMap();
                
                // Update the Show Map button text
                const showMapBtn = document.getElementById('show-map-btn');
                if (showMapBtn) {
                    showMapBtn.innerHTML = `
                        <i data-lucide="map" class="w-4 h-4"></i>
                        <span>Map</span>
                    `;
                    lucide.createIcons();
                }
            });
            
            mapVisible = true;
        }
        
        function hideItineraryMap() {
            const mapContainer = document.querySelector('.map-container');
            if (mapContainer) {
                mapContainer.style.display = 'none';
            }
            mapVisible = false;
        }
        
        async function showItineraryMap() {
            const mapContainer = document.querySelector('.map-container');
            
            // If map already exists, just show it
            if (mapContainer) {
                mapContainer.style.display = 'block';
                mapVisible = true;
                
                // Refresh the map size in case container dimensions changed
                if (currentMap) {
                    setTimeout(() => {
                        currentMap.invalidateSize();
                    }, 100);
                }
                return;
            }
            
            // Create map for the first time
            if (currentEditingItinerary) {
                console.log('Creating map for itinerary:', currentEditingItinerary);
                await createItineraryMap(currentEditingItinerary);
                mapVisible = true;
            } else {
                throw new Error('No itinerary data available');
            }
        }

        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            lucide.createIcons();

            // Clean up localStorage inconsistencies
            function cleanupLocalStorage() {
                // Migrate old key to new key if exists
                const oldItineraries = localStorage.getItem('saved_itineraries');
                const newItineraries = localStorage.getItem('savedItineraries');
                
                if (oldItineraries && !newItineraries) {
                    localStorage.setItem('savedItineraries', oldItineraries);
                    localStorage.removeItem('saved_itineraries');
                    console.log('Migrated localStorage from old key to new key');
                } else if (oldItineraries && newItineraries) {
                    // Both exist, merge them
                    try {
                        const old = JSON.parse(oldItineraries);
                        const current = JSON.parse(newItineraries);
                        const merged = [...current];
                        
                        old.forEach(oldItem => {
                            if (!merged.find(item => item.id === oldItem.id)) {
                                merged.push(oldItem);
                            }
                        });
                        
                        localStorage.setItem('savedItineraries', JSON.stringify(merged));
                        localStorage.removeItem('saved_itineraries');
                        console.log('Merged localStorage entries and removed old key');
                    } catch (error) {
                        console.error('Error merging localStorage:', error);
                        localStorage.removeItem('saved_itineraries');
                    }
                }
            }

            // Test Firebase connectivity
            async function testFirebaseConnection() {
                try {
                    console.log('Testing Firestore connectivity...');
                    const testCollection = collection(db, 'test');
                    console.log('Firestore collection reference created successfully');
                    return true;
                } catch (error) {
                    console.error('Firebase connectivity test failed:', error);
                    return false;
                }
            }

            // Initialize cleanup
            cleanupLocalStorage();
            
            // Initialize pricing section for non-logged in users
            updatePricingSection(null);
            
            // Debug function - add to window for console access
            window.clearAllLocalStorage = function() {
                localStorage.removeItem('savedItineraries');
                localStorage.removeItem('saved_itineraries');
                console.log('All localStorage cleared');
                if (!$('#my-trips-section').classList.contains('hidden')) {
                    loadSavedItineraries();
                }
            };
            
            window.debugLocalStorage = function() {
                console.log('=== localStorage Debug Info ===');
                console.log('savedItineraries:', JSON.parse(localStorage.getItem('savedItineraries') || '[]'));
                console.log('saved_itineraries:', JSON.parse(localStorage.getItem('saved_itineraries') || '[]'));
                console.log('All localStorage keys:', Object.keys(localStorage));
                
                // Check for any orphaned itineraries
                const savedItineraries = JSON.parse(localStorage.getItem('savedItineraries') || '[]');
                const oldItineraries = JSON.parse(localStorage.getItem('saved_itineraries') || '[]');
                
                console.log('Orphaned items (no userId):', savedItineraries.filter(item => !item.userId));
                console.log('Items from old key:', oldItineraries);
            };

            window.removeOrphanedItineraries = function() {
                console.log('Removing orphaned itineraries...');
                const stored = localStorage.getItem('savedItineraries');
                if (stored) {
                    const itineraries = JSON.parse(stored);
                    const validItineraries = itineraries.filter(item => 
                        item.userId && item.userId === auth.currentUser?.uid
                    );
                    
                    console.log('Before cleanup:', itineraries.length, 'items');
                    console.log('After cleanup:', validItineraries.length, 'items');
                    
                    localStorage.setItem('savedItineraries', JSON.stringify(validItineraries));
                    if (auth.currentUser) {
                        loadSavedItineraries();
                    }
                }
            };

            // Auth State
            onAuthStateChanged(auth, async (user) => {
                console.log('Auth state changed:', user ? 'User logged in' : 'User logged out');
                if (user) {
                    console.log('User UID:', user.uid);
                    await testFirebaseConnection();
                    await checkUserSubscriptionStatus(user.uid);
                    loadSavedItineraries();
                } else {
                    currentUserSubscription = 'free';
                }
                updateAuthUI(user);
            });

            // Auth Modal
            $('#auth-form').addEventListener('submit', async (e) => {
                e.preventDefault();
                const email = $('#email').value.trim();
                const password = $('#password').value;
                const errorEl = $('#auth-error');
                
                // Clear previous errors
                errorEl.classList.add('hidden');
                errorEl.textContent = '';
                
                // Basic validation
                if (!email || !password) {
                    errorEl.textContent = 'Please enter both email and password.';
                    errorEl.classList.remove('hidden');
                    return;
                }
                
                if (password.length < 6) {
                    errorEl.textContent = 'Password must be at least 6 characters long.';
                    errorEl.classList.remove('hidden');
                    return;
                }
                
                try {
                    if (isLoginMode) {
                        console.log('🔐 Attempting login...');
                        await signInWithEmailAndPassword(auth, email, password);
                        console.log('✅ Login successful');
                    } else {
                        // Create new user account
                        console.log('📝 Attempting to create new user account...');
                        const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                        const newUser = userCredential.user;
                        console.log('✅ User account created:', newUser.uid);
                        
                        // Initialize user document in Firestore for new users
                        console.log('✅ New user created, initializing Firestore document...');
                        const userDocRef = doc(db, "users", newUser.uid);
                        await setDoc(userDocRef, {
                            email: newUser.email,
                            createdAt: serverTimestamp(),
                            itineraryCount: 0,
                            subscriptionStatus: 'free'
                        });
                        console.log('✅ User document initialized in Firestore');
                    }
                    hideModal('auth-modal');
                } catch (error) {
                    console.error('❌ Registration error:', error);
                    console.error('Error code:', error.code);
                    console.error('Error message:', error.message);
                    errorEl.textContent = getFriendlyAuthError(error);
                    errorEl.classList.remove('hidden');
                }
            });

            // Auth Toggle Button
            $('#auth-toggle-button').addEventListener('click', () => {
                isLoginMode = !isLoginMode;
                $('#auth-title').textContent = isLoginMode ? 'Log In' : 'Create Account';
                $('#auth-submit-button').textContent = isLoginMode ? 'Log In' : 'Create Account';
                $('#auth-toggle-text').textContent = isLoginMode ? "Don't have an account?" : 'Already have an account?';
                $('#auth-toggle-button').textContent = isLoginMode ? 'Sign Up' : 'Log In';
                $('#auth-error').classList.add('hidden');
                $('#auth-form').reset();
            });

            // Planner Tabs
            $('#guided-tab-btn').addEventListener('click', () => {
                $('#guided-mode-container').classList.remove('hidden');
                $('#manual-panel').classList.add('hidden');
                $('#guided-tab-btn').classList.add('active');
                $('#manual-tab-btn').classList.remove('active');
            });

            $('#manual-tab-btn').addEventListener('click', () => {
                $('#manual-panel').classList.remove('hidden');
                $('#guided-mode-container').classList.add('hidden');
                $('#manual-tab-btn').classList.add('active');
                $('#guided-tab-btn').classList.remove('active');
            });

            // Guided Planner
            $$('.interest-btn').forEach(button => {
                button.addEventListener('click', () => {
                    const isSelected = button.getAttribute('data-selected') === 'true';
                    button.setAttribute('data-selected', String(!isSelected));
                    button.classList.toggle('active', !isSelected);
                });
            });

            $('#generate-prompt-btn').addEventListener('click', async () => {
                // Check if limit reached - show modal immediately
                if (hasReachedLimit) {
                    showModal('limit-reached-modal');
                    return;
                }
                
                // Additional check for safety
                if (currentUserSubscription === 'free' && auth.currentUser) {
                    const userDocRef = doc(db, "users", auth.currentUser.uid);
                    const docSnap = await getDoc(userDocRef);
                    const userData = docSnap.data() || {};
                    const itineraryCount = userData.itineraryCount || 0;
                    
                    if (itineraryCount >= 3) {
                        showModal('limit-reached-modal');
                        return;
                    }
                }
                
                const prompt = buildGuidedPrompt();
                if (prompt) {
                    // Scroll to planner section when generating
                    const plannerSection = document.getElementById('planner');
                    if (plannerSection) {
                        plannerSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    } else {
                        window.scrollTo({ top: 0, behavior: 'smooth' });
                        console.log('⬆️ Scrolled to top on generate click');
                    }
                    
                    handleSendV2(prompt);
                }
            });

            // Multi-city toggle
            $('#multi-city-toggle').addEventListener('change', (e) => {
                const isMultiCity = e.target.checked;
                
                // Check if user is premium when trying to enable multi-city
                if (isMultiCity && currentUserSubscription === 'free') {
                    // Prevent the toggle from being checked
                    e.target.checked = false;
                    
                    // Show upgrade modal
                    showModal('upgrade-modal');
                    
                    // Show a temporary message
                    showTemporaryMessage('Multi-city trips are available with premium subscription', 'info');
                    return;
                }
                
                const singleContainer = $('#single-destination-container');
                const multiContainer = $('#multi-destination-container');
                const durationContainer = $('#duration').closest('div');
                const travelDetailsContainer = $('#single-travel-details');
                const multiTravelersContainer = $('#multi-city-travelers');
                
                if (isMultiCity) {
                    singleContainer.classList.add('hidden');
                    multiContainer.classList.remove('hidden');
                    // Hide duration field since each city has its own duration
                    if (durationContainer) durationContainer.classList.add('hidden');
                    // Hide single travel details section and show multi-city travel details
                    if (travelDetailsContainer) travelDetailsContainer.classList.add('hidden');
                    if (multiTravelersContainer) multiTravelersContainer.classList.remove('hidden');
                } else {
                    singleContainer.classList.remove('hidden');
                    multiContainer.classList.add('hidden');
                    // Show duration field for single destination trips
                    if (durationContainer) durationContainer.classList.remove('hidden');
                    // Show single travel details section and hide multi-city travel details
                    if (travelDetailsContainer) travelDetailsContainer.classList.remove('hidden');
                    if (multiTravelersContainer) multiTravelersContainer.classList.add('hidden');
                }
            });

            // Manual Planner - Updated to use new chat system
            $('#send-button').addEventListener('click', () => handleSendV2());
            $('#chat-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') handleSendV2();
            });
            
            // Destination Suggestion Buttons (both guided and manual) - Pro Feature
            $('#suggest-destination-btn')?.addEventListener('click', () => {
                if (currentUserSubscription === 'free') {
                    showModal('upgrade-modal');
                    return;
                }
                showModal('destination-suggest-modal');
                lucide.createIcons(); // Refresh icons in modal
            });
            
            $('#suggest-destination-btn-guided')?.addEventListener('click', () => {
                if (currentUserSubscription === 'free') {
                    showModal('upgrade-modal');
                    return;
                }
                showModal('destination-suggest-modal');
                lucide.createIcons(); // Refresh icons in modal
            });
            
            // Destination Suggestion Form
            $('#destination-suggest-form')?.addEventListener('submit', async (e) => {
                e.preventDefault();
                await handleDestinationSuggestion();
            });

            // Action Buttons (Save & Download)
            $('#save-button').addEventListener('click', async () => {
                if (!auth.currentUser) {
                    console.log('User not authenticated, showing auth modal');
                    showModal('auth-modal');
                    return;
                }
                if (!lastItineraryJson) {
                    alert('No itinerary to save!');
                    return;
                }
                
                // Show loading state
                const saveButton = $('#save-button');
                const originalText = saveButton.innerHTML;
                saveButton.innerHTML = '<i data-lucide="loader-2" class="w-4 h-4 animate-spin"></i><span>Saving...</span>';
                saveButton.disabled = true;
                
                try {
                    console.log('Attempting to save itinerary:', lastItineraryJson.title);
                    console.log('Current user:', auth.currentUser.uid);
                    console.log('Itinerary data:', lastItineraryJson);
                    
                    const itineraryData = {
                        ...lastItineraryJson,
                        ownerId: auth.currentUser.uid,  // Changed from userId to ownerId to match Firestore rules
                        userId: auth.currentUser.uid,   // Keep userId for backward compatibility
                        collaborators: [auth.currentUser.uid],
                        createdAt: serverTimestamp(),
                        updatedAt: serverTimestamp(),
                        // Add some additional metadata that might be required
                        version: 1,
                        status: 'active'
                    };
                    
                    console.log('Prepared itinerary data:', itineraryData);
                    
                    const docRef = await addDoc(collection(db, "itineraries"), itineraryData);
                    console.log('Itinerary saved with ID:', docRef.id);
                    
                    // Show success feedback
                    saveButton.innerHTML = '<i data-lucide="check" class="w-4 h-4"></i><span>Saved!</span>';
                    setTimeout(() => {
                        saveButton.innerHTML = originalText;
                        saveButton.disabled = false;
                        lucide.createIcons();
                    }, 2000);
                    
                } catch (error) {
                    console.error("Error saving itinerary:", error);
                    console.error("Error details:", error.code, error.message);
                    
                    // Try fallback save to localStorage
                    try {
                        console.log('Attempting fallback save to localStorage...');
                        const savedItineraries = JSON.parse(localStorage.getItem('saved_itineraries') || '[]');
                        const itineraryWithId = {
                            ...lastItineraryJson,
                            id: Date.now().toString(),
                            userId: auth.currentUser.uid,
                            savedAt: new Date().toISOString(),
                            source: 'localStorage'
                        };
                        savedItineraries.push(itineraryWithId);
                        localStorage.setItem('saved_itineraries', JSON.stringify(savedItineraries));
                        
                        console.log('Itinerary saved to localStorage successfully');
                        
                        // Show user notification about fallback save
                        const notification = document.createElement('div');
                        notification.style.cssText = `
                            position: fixed; top: 20px; right: 20px; z-index: 9999;
                            background: #dbeafe; color: #1e40af; padding: 12px 16px;
                            border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                            max-width: 300px; font-size: 14px; line-height: 1.4;
                        `;
                        notification.innerHTML = `
                            <strong>Saved Locally</strong><br>
                            Cloud save failed, but your itinerary is saved in your browser. You can still download it!
                        `;
                        document.body.appendChild(notification);
                        setTimeout(() => notification.remove(), 5000);
                        
                        // Show success feedback
                        saveButton.innerHTML = '<i data-lucide="check" class="w-4 h-4"></i><span>Saved Locally!</span>';
                        setTimeout(() => {
                            saveButton.innerHTML = originalText;
                            saveButton.disabled = false;
                            lucide.createIcons();
                        }, 3000);
                        
                    } catch (localError) {
                        console.error('Local save also failed:', localError);
                        
                        // Show error feedback
                        saveButton.innerHTML = '<i data-lucide="x" class="w-4 h-4"></i><span>Error</span>';
                        setTimeout(() => {
                            saveButton.innerHTML = originalText;
                            saveButton.disabled = false;
                            lucide.createIcons();
                        }, 2000);
                        
                        let errorMessage = 'Failed to save itinerary. ';
                        if (error.code === 'permission-denied') {
                            errorMessage += 'Database permissions issue - please check your account settings or try again later.';
                        } else {
                            errorMessage += `Error: ${error.message || 'Unknown error'}`;
                        }
                        alert(errorMessage);
                    }
                }
            });

            $('#share-button').addEventListener('click', async () => {
                if (!auth.currentUser) {
                    showModal('auth-modal');
                    return;
                }
                if (!lastItineraryJson) {
                    alert('No itinerary to share!');
                    return;
                }
                
                try {
                    // First save the itinerary if not already saved
                    let shareableId = lastItineraryJson.id;
                    
                    if (!shareableId) {
                        // Save to Firebase to get a shareable ID
                        const itineraryData = {
                            ...lastItineraryJson,
                            ownerId: auth.currentUser.uid,
                            userId: auth.currentUser.uid,
                            collaborators: [auth.currentUser.uid],
                            createdAt: serverTimestamp(),
                            updatedAt: serverTimestamp(),
                            isShared: true,
                            version: 1,
                            status: 'active'
                        };
                        
                        const docRef = await addDoc(collection(db, "itineraries"), itineraryData);
                        shareableId = docRef.id;
                    } else {
                        // Update existing itinerary to mark as shared
                        const docRef = doc(db, "itineraries", shareableId);
                        await updateDoc(docRef, { isShared: true });
                    }
                    
                    // Generate share link
                    const shareUrl = `${window.location.origin}${window.location.pathname}?shared=${shareableId}`;
                    $('#share-link-input').value = shareUrl;
                    showModal('share-modal');
                    
                } catch (error) {
                    console.error('Error sharing itinerary:', error);
                    alert('Failed to create share link. Please try again.');
                }
            });

            $('#download-button').addEventListener('click', () => {
                if (currentUserSubscription === 'free') {
                    showModal('upgrade-modal');
                    return;
                }
                if (!lastItineraryJson) {
                    alert('No itinerary to download!');
                    return;
                }
                
                // Show loading state
                const downloadButton = $('#download-button');
                const originalText = downloadButton.innerHTML;
                downloadButton.innerHTML = '<i data-lucide="loader-2" class="w-4 h-4 animate-spin"></i><span>Generating PDF...</span>';
                downloadButton.disabled = true;
                
                // Use timeout to allow UI to update
                setTimeout(async () => {
                    try {
                        await generatePDF(lastItineraryJson);
                        
                        // Show success feedback
                        downloadButton.innerHTML = '<i data-lucide="check" class="w-4 h-4"></i><span>Downloaded!</span>';
                        setTimeout(() => {
                            downloadButton.innerHTML = originalText;
                            downloadButton.disabled = false;
                            lucide.createIcons();
                        }, 2000);
                        
                    } catch (error) {
                        console.error('PDF generation error:', error);
                        
                        // Show error feedback
                        downloadButton.innerHTML = '<i data-lucide="x" class="w-4 h-4"></i><span>Error</span>';
                        setTimeout(() => {
                            downloadButton.innerHTML = originalText;
                            downloadButton.disabled = false;
                            lucide.createIcons();
                        }, 2000);
                        
                        alert(`Failed to generate PDF: ${error.message || 'Unknown error'}. A text version was downloaded instead.`);
                    }
                }, 100);
            });

            // General UI Actions (delegated)
            document.body.addEventListener('click', (e) => {
                const target = e.target.closest('[data-action]');
                if (target) {
                    const action = target.dataset.action;
                    if (action.startsWith('show-')) {
                        isLoginMode = action.includes('login');
                        showModal('auth-modal');
                        $('#auth-title').textContent = isLoginMode ? 'Log In' : 'Create Account';
                        $('#auth-submit-button').textContent = isLoginMode ? 'Log In' : 'Create Account';
                        $('#auth-toggle-text').textContent = isLoginMode ? "Don't have an account?" : 'Already have an account?';
                        $('#auth-toggle-button').textContent = isLoginMode ? 'Sign Up' : 'Log In';
                        $('#auth-error').classList.add('hidden');
                        $('#auth-form').reset();
                    } else if (action.startsWith('hide-')) {
                        hideModal(action.replace('hide-', ''));
                    }
                }

                if (e.target.closest('#logout-button, #mobile-logout-button')) signOut(auth);
                if (e.target.closest('#my-trips-btn, #mobile-my-trips-btn')) showMyTrips();
                if (e.target.closest('#back-to-planner-btn')) showPlanner();
                if (e.target.closest('#guest-signup-btn')) {
                    hideModal('guest-custom-plan-modal');
                    isLoginMode = false;
                    showModal('auth-modal');
                }
                if (e.target.closest('#upgrade-button')) redirectToCheckout();
                
                // Upgrade modal "View Pricing Plans" button
                if (e.target.closest('#upgrade-modal-link')) {
                    e.preventDefault();
                    hideModal('upgrade-modal');
                    // Redirect to Stripe checkout for pro plan
                    redirectToCheckout();
                }
                
                // Multi-city add/remove buttons
                if (e.target.closest('#add-city-btn')) {
                    const cityList = $('#city-list');
                    if (!cityList) {
                        showTemporaryMessage('Please enable multi-city mode first', 'error');
                        return;
                    }
                    const existingCities = cityList.querySelectorAll('.multi-city-item').length;
                    const newItem = document.createElement('div');
                    newItem.className = 'multi-city-item bg-white rounded-lg border border-gray-200 p-4 shadow-sm hover:shadow-md transition-shadow';
                    
                    // Determine city number and color
                    const cityNum = existingCities + 1;
                    const colors = [
                        { bg: 'bg-green-100', text: 'text-green-600' },
                        { bg: 'bg-blue-100', text: 'text-blue-600' },
                        { bg: 'bg-purple-100', text: 'text-purple-600' },
                        { bg: 'bg-orange-100', text: 'text-orange-600' },
                        { bg: 'bg-pink-100', text: 'text-pink-600' },
                        { bg: 'bg-teal-100', text: 'text-teal-600' }
                    ];
                    const color = colors[(cityNum - 1) % colors.length];
                    
                    newItem.innerHTML = `
                        <div class="flex items-center justify-between mb-3">
                            <div class="flex items-center gap-2">
                                <div class="w-6 h-6 ${color.bg} rounded-full flex items-center justify-center text-xs font-semibold ${color.text}">${cityNum}</div>
                                <span class="font-medium text-gray-700">${getOrdinalNumber(cityNum)} Stop</span>
                            </div>
                            <button type="button" class="remove-city-btn p-1 text-red-500 hover:text-red-700 hover:bg-red-50 rounded-full transition-colors">
                                <i data-lucide="x" class="w-4 h-4"></i>
                            </button>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                            <div>
                                <label class="block text-xs font-medium text-gray-600 mb-1">Destination</label>
                                <input type="text" class="city-input w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all" placeholder="e.g., Tokyo, Japan">
                            </div>
                            <div>
                                <label class="block text-xs font-medium text-gray-600 mb-1">Duration</label>
                                <input type="text" class="days-input w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all" placeholder="e.g., 2 days">
                            </div>
                        </div>
                    `;
                    
                    // Insert the new city item at the end of the city list
                    cityList.appendChild(newItem);
                    lucide.createIcons();
                }
                if (e.target.closest('.remove-city-btn')) {
                    const cityItem = e.target.closest('.multi-city-item');
                    if (cityItem) {
                        cityItem.remove();
                        // Update city numbers after removal
                        const remainingCities = $$('#city-list .multi-city-item');
                        
                        const colors = [
                            { bg: 'bg-green-100', text: 'text-green-600' },
                            { bg: 'bg-blue-100', text: 'text-blue-600' },
                            { bg: 'bg-purple-100', text: 'text-purple-600' },
                            { bg: 'bg-orange-100', text: 'text-orange-600' },
                            { bg: 'bg-pink-100', text: 'text-pink-600' },
                            { bg: 'bg-teal-100', text: 'text-teal-600' }
                        ];
                        
                        remainingCities.forEach((item, index) => {
                            const cityNum = index + 1;
                            const color = colors[index % colors.length];
                            
                            // Update the city number badge
                            const badge = item.querySelector('.w-6.h-6');
                            if (badge) {
                                badge.className = `w-6 h-6 ${color.bg} rounded-full flex items-center justify-center text-xs font-semibold ${color.text}`;
                                badge.textContent = cityNum;
                            }
                            
                            // Update the stop label
                            const stopLabel = item.querySelector('.font-medium');
                            if (stopLabel) stopLabel.textContent = `${getOrdinalNumber(cityNum)} Stop`;
                        });
                    }
                }
            });
            
            // Sample Itinerary Cards
            $$('.sample-itinerary-card').forEach(card => {
                card.addEventListener('click', () => {
                    const prompt = card.dataset.prompt;
                    if (prompt) {
                        // Scroll to planner section
                        document.getElementById('planner').scrollIntoView({ behavior: 'smooth' });
                        // Wait for scroll, then trigger the prompt
                        setTimeout(() => {
                            handleSendV2(prompt);
                        }, 500);
                    }
                });
            });

            // Mobile Menu
            $('#mobile-menu-button').addEventListener('click', function() {
                const mobileMenu = $('#mobile-menu');
                const isExpanded = this.getAttribute('aria-expanded') === 'true';
                this.setAttribute('aria-expanded', !isExpanded);
                mobileMenu.classList.toggle('hidden');
            });

            // About Modal
            $('#about-link').addEventListener('click', function(e) {
                e.preventDefault();
                showModal('about-modal');
            });
            $('#about-link-mobile').addEventListener('click', function(e) {
                e.preventDefault();
                showModal('about-modal');
                // Close mobile menu
                $('#mobile-menu').classList.add('hidden');
                $('#mobile-menu-button').setAttribute('aria-expanded', 'false');
            });
            $('#about-link-footer').addEventListener('click', function(e) {
                e.preventDefault();
                showModal('about-modal');
            });
            // Close About modal when clicking backdrop
            $('#about-modal').addEventListener('click', function(e) {
                if (e.target === this) {
                    hideModal('about-modal');
                }
            });

            // Show Map functionality event handler
            $('#show-map-btn').addEventListener('click', async function(event) {
                event.stopPropagation();
                const mapContainer = document.querySelector('.map-container');
                
                if (mapContainer && mapVisible) {
                    // Map is visible, hide it
                    hideItineraryMap();
                    this.innerHTML = `
                        <i data-lucide="map-pin" class="w-4 h-4"></i>
                        <span>Map</span>
                    `;
                } else {
                    // Map is hidden or doesn't exist, show it
                    if (!currentEditingItinerary) {
                        alert('No itinerary data available. Please try reopening this trip.');
                        return;
                    }
                    
                    // Show loading state
                    this.disabled = true;
                    this.innerHTML = `
                        <i data-lucide="loader" class="w-4 h-4 animate-spin"></i>
                        <span>Loading...</span>
                    `;
                    lucide.createIcons();
                    
                    try {
                        await showItineraryMap();
                        this.disabled = false;
                        this.innerHTML = `
                            <i data-lucide="eye-off" class="w-4 h-4"></i>
                            <span>Hide Map</span>
                        `;
                    } catch (error) {
                        console.error('Error showing map:', error);
                        alert('Failed to load map. Please check your internet connection and try again.');
                        this.disabled = false;
                        this.innerHTML = `
                            <i data-lucide="map-pin" class="w-4 h-4"></i>
                            <span>Map</span>
                        `;
                    }
                }
                
                // Reinitialize Lucide icons
                lucide.createIcons();
            });

            $('#share-itinerary-btn').addEventListener('click', function(event) {
                event.stopPropagation();
                if (currentItineraryId) {
                    shareCurrentItinerary(currentItineraryId);
                } else {
                    alert('No itinerary selected to share.');
                }
            });

            // Edit functionality event handlers
            $('#edit-itinerary-btn').addEventListener('click', function(event) {
                event.stopPropagation();
                console.log('Edit button clicked!');
                enterEditMode();
            });

            $('#save-changes-btn').addEventListener('click', function(event) {
                event.stopPropagation();
                saveItineraryChanges();
            });

            $('#cancel-edit-btn').addEventListener('click', function(event) {
                event.stopPropagation();
                cancelEditMode();
            });

            // Delete functionality event handlers
            $('#delete-itinerary-btn').addEventListener('click', function(event) {
                event.stopPropagation();
                if (currentItineraryId) {
                    confirmDeleteItinerary(currentItineraryId);
                }
            });

            $('#confirm-delete-btn').addEventListener('click', function(event) {
                event.stopPropagation();
                if (itineraryToDelete) {
                    deleteItinerary(itineraryToDelete);
                }
            });

            $('#cancel-delete-btn').addEventListener('click', function(event) {
                event.stopPropagation();
                cancelDelete();
            });

            // Handle navigation links to switch back to main sections from My Trips
            document.querySelectorAll('a[href^="#"]').forEach(link => {
                link.addEventListener('click', function(e) {
                    const target = this.getAttribute('href');
                    
                    // If we're in My Trips and clicking a section link, switch back to planner
                    if (!$('#my-trips-section').classList.contains('hidden') && 
                        (target === '#features' || target === '#itineraries' || target === '#pricing' || target === '#hero' || target === '#planner')) {
                        e.preventDefault();
                        showPlanner();
                        
                        // Smooth scroll to the target section after showing planner
                        setTimeout(() => {
                            const targetElement = $(target);
                            if (targetElement) {
                                targetElement.scrollIntoView({ 
                                    behavior: 'smooth',
                                    block: 'start'
                                });
                            }
                        }, 100);
                    }
                });
            });

            // Handle "Plan a New Trip" button in My Trips section
            $('#back-to-planner-btn').addEventListener('click', function() {
                showPlanner();
                // Scroll to planner section
                setTimeout(() => {
                    const plannerSection = $('#planner');
                    if (plannerSection) {
                        plannerSection.scrollIntoView({ 
                            behavior: 'smooth',
                            block: 'start'
                        });
                    }
                }, 100);
            });

            // Share functionality
            $('#copy-share-link-btn').addEventListener('click', async () => {
                const shareLink = $('#share-link-input').value;
                const copyMsg = $('#copy-success-msg');
                
                try {
                    await navigator.clipboard.writeText(shareLink);
                    copyMsg.classList.remove('hidden');
                    setTimeout(() => {
                        copyMsg.classList.add('hidden');
                    }, 3000);
                } catch (err) {
                    // Fallback for older browsers
                    $('#share-link-input').select();
                    document.execCommand('copy');
                    copyMsg.classList.remove('hidden');
                    setTimeout(() => {
                        copyMsg.classList.add('hidden');
                    }, 3000);
                }
            });

            // Event delegation for modal actions
            document.addEventListener('click', function(e) {
                const action = e.target.getAttribute('data-action');
                if (action) {
                    e.preventDefault();
                    
                    switch(action) {
                        case 'show-login-modal':
                            isLoginMode = true;
                            $('#auth-title').textContent = 'Log In';
                            $('#auth-submit-button').textContent = 'Log In';
                            $('#auth-toggle-text').textContent = "Don't have an account?";
                            $('#auth-toggle-button').textContent = 'Sign Up';
                            $('#auth-error').classList.add('hidden');
                            $('#auth-form').reset();
                            showModal('auth-modal');
                            break;
                        case 'show-signup-modal':
                            isLoginMode = false;
                            $('#auth-title').textContent = 'Create Account';
                            $('#auth-submit-button').textContent = 'Create Account';
                            $('#auth-toggle-text').textContent = 'Already have an account?';
                            $('#auth-toggle-button').textContent = 'Log In';
                            $('#auth-error').classList.add('hidden');
                            $('#auth-form').reset();
                            showModal('auth-modal');
                            break;
                        case 'hide-auth-modal':
                            hideModal('auth-modal');
                            break;
                        case 'hide-about-modal':
                            hideModal('about-modal');
                            break;
                        case 'hide-share-modal':
                            hideModal('share-modal');
                            break;
                        case 'hide-itinerary-detail-modal':
                            hideModal('itinerary-detail-modal');
                            break;
                        case 'hide-upgrade-modal':
                            hideModal('upgrade-modal');
                            break;
                        case 'hide-limit-reached-modal':
                            hideModal('limit-reached-modal');
                            break;
                        case 'hide-guest-custom-plan-modal':
                            hideModal('guest-custom-plan-modal');
                            break;
                    }
                }
            });

            // Function to share current itinerary from detail modal
            async function shareCurrentItinerary(itineraryId) {
                try {
                    // Update itinerary to mark as shared
                    const docRef = doc(db, "itineraries", itineraryId);
                    await updateDoc(docRef, { isShared: true });
                    
                    // Generate share link
                    const shareUrl = `${window.location.origin}${window.location.pathname}?shared=${itineraryId}`;
                    $('#share-link-input').value = shareUrl;
                    showModal('share-modal');
                    
                } catch (error) {
                    console.error('Error sharing itinerary:', error);
                    alert('Failed to create share link. Please try again.');
                }
            }



            // Function to load shared itinerary
            async function loadSharedItinerary(itineraryId) {
                try {
                    console.log('Loading shared itinerary:', itineraryId);
                    const docRef = doc(db, "itineraries", itineraryId);
                    const docSnap = await getDoc(docRef);
                    
                    if (docSnap.exists()) {
                        const itinerary = docSnap.data();
                        console.log('Shared itinerary loaded:', itinerary);
                        
                        // Set current itinerary ID and data for edit functionality
                        currentItineraryId = itineraryId;
                        currentItineraryData = itinerary;
                        currentEditingItinerary = itinerary; // Set editing data for edit mode
                        
                        // Add current user as collaborator if logged in and not already a collaborator
                        if (auth.currentUser && itinerary.collaborators && !itinerary.collaborators.includes(auth.currentUser.uid)) {
                            try {
                                console.log('Adding user as collaborator');
                                await updateDoc(docRef, {
                                    collaborators: arrayUnion(auth.currentUser.uid)
                                });
                                // Update local itinerary object
                                itinerary.collaborators.push(auth.currentUser.uid);
                                currentItineraryData = itinerary; // Update stored data
                            } catch (updateError) {
                                console.log('Could not add as collaborator (permissions), but can still view:', updateError);
                                // This is OK - they can still view the shared itinerary
                            }
                        }
                        
                        // Display the itinerary
                        $('#itinerary-detail-title').textContent = itinerary.title || 'Shared Itinerary';
                        
                        // Set up permission-based UI
                        setupSharedItineraryPermissions(itinerary);
                        
                        // Safely render the itinerary HTML
                        try {
                            $('#itinerary-detail-content').innerHTML = renderItineraryHTML(itinerary);
                        } catch (renderError) {
                            console.error('Error rendering itinerary:', renderError);
                            $('#itinerary-detail-content').innerHTML = `
                                <div class="text-center p-8">
                                    <h3 class="text-xl font-bold mb-4">${itinerary.title || 'Shared Itinerary'}</h3>
                                    <p class="text-gray-600">This shared trip is available, but there was an issue displaying the details.</p>
                                    <p class="text-sm text-gray-500 mt-2">Raw data: ${JSON.stringify(itinerary, null, 2)}</p>
                                </div>
                            `;
                        }
                        
                        showModal('itinerary-detail-modal');
                        
                        // Show notification
                        const notification = document.createElement('div');
                        notification.className = 'fixed top-4 right-4 bg-blue-600 text-white p-4 rounded-lg shadow-lg z-50';
                        
                        if (auth.currentUser) {
                            notification.innerHTML = `
                                <strong>Shared Trip Loaded!</strong><br>
                                You now have access to this trip.
                            `;
                        } else {
                            notification.innerHTML = `
                                <strong>Shared Trip Loaded!</strong><br>
                                <a href="#" onclick="showModal('auth-modal')" class="underline">Log in</a> to save this trip to your account.
                            `;
                        }
                        
                        document.body.appendChild(notification);
                        setTimeout(() => notification.remove(), 5000);
                        
                    } else {
                        console.log('Shared itinerary not found');
                        alert('Shared itinerary not found or no longer available.');
                    }
                } catch (error) {
                    console.error('Error loading shared itinerary:', error);
                    alert('Failed to load shared itinerary: ' + error.message);
                }
            }

            // Check for shared itinerary on page load - delay until Firebase is ready
            setTimeout(() => {
                const urlParams = new URLSearchParams(window.location.search);
                const sharedId = urlParams.get('shared');
                if (sharedId) {
                    console.log('Shared itinerary detected in URL:', sharedId);
                    loadSharedItinerary(sharedId);
                }
            }, 2000); // Wait 2 seconds for Firebase to initialize

            // Debug function - you can call this from console to test sharing
            window.testSharing = function() {
                console.log('Testing sharing functionality...');
                if (!auth.currentUser) {
                    console.log('Please log in first to test sharing');
                    return;
                }
                
                // Create a test itinerary
                const testItinerary = {
                    title: 'Test Shared Trip',
                    destination: 'Paris, France',
                    days: [
                        {
                            day: 1,
                            date: '2025-10-10',
                            activities: [
                                {
                                    time: '09:00',
                                    activity: 'Visit Eiffel Tower',
                                    description: 'Iconic landmark and symbol of Paris'
                                }
                            ]
                        }
                    ]
                };
                
                // Simulate the share button functionality
                lastItineraryJson = testItinerary;
                $('#share-button').click();
            };
            
            console.log('Sharing functionality loaded. You can test with: testSharing()');
            
            // --- Inline Chat Chip Functionality - Updated for new chat system ---
            // Handle inline chat chips (in the chat messages)
            document.addEventListener('click', (e) => {
                if (e.target.closest('.inline-chat-chip')) {
                    const chip = e.target.closest('.inline-chat-chip');
                    const prompt = chip.getAttribute('data-prompt');
                    if (prompt) {
                        // Auto-send the prompt using new chat system
                        handleSendV2(prompt);
                    }
                }
            });

            // Handle inline send button (now persistent)
            document.addEventListener('click', (e) => {
                if (e.target.closest('#persistent-send-button')) {
                    const persistentInput = document.getElementById('persistent-chat-input');
                    if (persistentInput && persistentInput.value.trim()) {
                        const prompt = persistentInput.value.trim();
                        persistentInput.value = '';
                        handleSendV2(prompt);
                    }
                }
            });

            // Handle Enter key in persistent input
            document.addEventListener('keypress', (e) => {
                if (e.target.id === 'persistent-chat-input' && e.key === 'Enter') {
                    const persistentInput = document.getElementById('persistent-chat-input');
                    if (persistentInput.value.trim()) {
                        const prompt = persistentInput.value.trim();
                        persistentInput.value = '';
                        handleSendV2(prompt);
                    }
                }
            });
            
            console.log('✅ New conversational chat system loaded and ready!');
            
            // Debug function - run this in console: debugMapWrapper()
            window.debugMapWrapper = function() {
                const wrapper = document.getElementById('map-section-wrapper');
                console.log('=== MAP WRAPPER DEBUG ===');
                console.log('Element found:', !!wrapper);
                if (wrapper) {
                    console.log('HTML:', wrapper.outerHTML.substring(0, 200));
                    console.log('Classes:', wrapper.className);
                    console.log('Inline style:', wrapper.style.cssText);
                    console.log('Computed display:', window.getComputedStyle(wrapper).display);
                    console.log('Computed width:', window.getComputedStyle(wrapper).width);
                    console.log('Computed flex-direction:', window.getComputedStyle(wrapper).flexDirection);
                    console.log('offsetWidth:', wrapper.offsetWidth);
                    console.log('offsetHeight:', wrapper.offsetHeight);
                    console.log('Parent:', wrapper.parentElement);
                    console.log('Parent display:', window.getComputedStyle(wrapper.parentElement).display);
                    console.log('Parent flex-direction:', window.getComputedStyle(wrapper.parentElement).flexDirection);
                    console.log('Children count:', wrapper.children.length);
                    console.log('Has map container:', !!wrapper.querySelector('.map-container'));
                }
                console.log('======================');
            };
            console.log('💡 Debug helper loaded. Run debugMapWrapper() in console to inspect the map wrapper.');
        });
    </script>

    <script>



    </script>
</body>
</html>
